Index: TMessagesProj/src/main/java/org/telegram/ui/ChatActivity.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/ChatActivity.java b/TMessagesProj/src/main/java/org/telegram/ui/ChatActivity.java
--- a/TMessagesProj/src/main/java/org/telegram/ui/ChatActivity.java	(revision e672c7f3737ff39507d246aecc820df247607992)
+++ b/TMessagesProj/src/main/java/org/telegram/ui/ChatActivity.java	(revision 92b516a8a2db084a3b52a9b20cb5b3c665717774)
@@ -945,6 +945,7 @@
     private FireworksOverlay fireworksOverlay;
 
     private boolean swipeBackEnabled = true;
+    private long popupStartTime;
 
     public static Pattern publicMsgUrlPattern;
     public static Pattern voiceChatUrlPattern;
@@ -36240,12 +36241,15 @@
         @Override
         public void didLongPress(ChatMessageCell cell, float x, float y) {
             if (cell.drawSideButton == 1 && x >= cell.sideStartX) {
-                if (popupView != null) {
+                if (popupView != null && popupView.getParent() != null) {
                     contentView.removeView(popupView);
                 }
                 swipeBackEnabled = false;
-                int defaultColor = Theme.blendOver(cell.getThemedColor(Theme.key_chat_inBubble), Theme.multAlpha(cell.getThemedColor(Theme.key_windowBackgroundWhiteGrayText), .85f));
-                popupView = new MetaballViewFINAL(getContext(), getThemedDrawable(Theme.key_drawable_shareIcon), ChatActivity.this, defaultColor) {
+                popupStartTime = SystemClock.elapsedRealtime();
+                popupView = new MetaballViewFINAL(getContext(), getThemedDrawable(Theme.key_drawable_shareIcon),
+                        ChatActivity.this, contentView, getResourceProvider(),
+                        contentView.getHeight(), contentView.getWidth(), contentPaddingTop
+                ) {
                     @Override
                     protected void onSend(TLRPC.Dialog did, int count, TLRPC.TL_forumTopic topic) {
                         createUndoView();
@@ -36265,9 +36269,13 @@
 
                     @Override
                     protected void onCollapseAnimationFinished() {
-                        contentView.removeView(popupView);
-                        popupView = null;
-                        swipeBackEnabled = true;
+                        if (popupView != null && popupView.getParent() != null) {
+                            contentView.removeView(popupView);
+                            popupView = null;
+                        }
+                        if ((SystemClock.elapsedRealtime()) > popupStartTime) {
+                            swipeBackEnabled = true;
+                        }
                     }
                 };
                 ArrayList<MessageObject> arrayList = null;
@@ -36282,16 +36290,26 @@
                     arrayList = new ArrayList<>();
                     arrayList.add(messageObject);
                 }
-                int[] position = new int[2];
-                cell.getLocationOnScreen(position);
-                int[] position2 = new int[2];
-//                cell.getTransitionParams().ignoreAlpha = true;
-//                cell.setAlpha(0.0f);
-//                cell.setTimeAlpha(0.0f);
-                cell.getLocationOnScreen(position2);
-                Rect rect = new Rect();
-                cell.getGlobalVisibleRect(rect);
-                popupView.init(cell.sideStartX, cell.getY(), cell.getHeight(), cell.sideStartY, arrayList, x, y, position);
+
+                int height = 0;
+                int popupY;
+                popupY = (int) (chatListView.getY() + cell.getTop() + cell.sideStartY);
+                if (isInsideContainer) {
+                    int[] location = new int[2];
+                    cell.getLocationInWindow(location);
+                    popupY = (int) (location[1] + cell.sideStartY);
+
+                    chatListView.getLocationInWindow(location);
+                } else {
+                    Rect backgroundPaddings = new Rect();
+                    Drawable shadowDrawable = getParentActivity().getResources().getDrawable(R.drawable.popup_fixed_alert).mutate();
+                    shadowDrawable.getPadding(backgroundPaddings);
+                    if (height - backgroundPaddings.top - backgroundPaddings.bottom > AndroidUtilities.dp(240)) {
+                        popupY += AndroidUtilities.dp(240) - height;
+                    }
+                }
+                float finalY = popupY - ActionBar.getCurrentActionBarHeight() - AndroidUtilities.statusBarHeight + dp(16);
+                popupView.init(cell.sideStartX, arrayList, finalY);
                 contentView.addView(popupView);
                 cell.showSideButton1240 = true;
             } else {
Index: TMessagesProj/src/main/java/org/telegram/ui/MetaballViewFINAL.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/MetaballViewFINAL.java b/TMessagesProj/src/main/java/org/telegram/ui/MetaballViewFINAL.java
--- a/TMessagesProj/src/main/java/org/telegram/ui/MetaballViewFINAL.java	(revision 5e86e28674ba8709b9f7da45ba03f65c548e4b07)
+++ b/TMessagesProj/src/main/java/org/telegram/ui/MetaballViewFINAL.java	(revision 90807f9385ec2588e4df174dc957e7879ecade91)
@@ -8,6 +8,7 @@
 import android.graphics.BlurMaskFilter;
 import android.graphics.Canvas;
 import android.graphics.Color;
+import android.graphics.LinearGradient;
 import android.graphics.Paint;
 import android.graphics.Path;
 import android.graphics.PathMeasure;
@@ -15,22 +16,15 @@
 import android.graphics.Rect;
 import android.graphics.RectF;
 import android.graphics.Shader;
-import android.graphics.drawable.BitmapDrawable;
 import android.graphics.drawable.Drawable;
-import android.os.Handler;
-import android.os.Looper;
 import android.text.TextPaint;
 import android.text.TextUtils;
-import android.util.Log;
 import android.util.Pair;
-import android.view.Choreographer;
 import android.view.MotionEvent;
 import android.view.View;
 import android.view.animation.LinearInterpolator;
 import android.view.animation.OvershootInterpolator;
 
-import androidx.core.graphics.ColorUtils;
-
 import org.telegram.messenger.AccountInstance;
 import org.telegram.messenger.AndroidUtilities;
 import org.telegram.messenger.ChatObject;
@@ -44,7 +38,6 @@
 import org.telegram.messenger.SendMessagesHelper;
 import org.telegram.messenger.UserConfig;
 import org.telegram.messenger.UserObject;
-import org.telegram.messenger.Utilities;
 import org.telegram.tgnet.TLRPC;
 import org.telegram.ui.ActionBar.Theme;
 import org.telegram.ui.Components.AlertsCreator;
@@ -52,8 +45,6 @@
 
 import java.util.ArrayList;
 import java.util.List;
-import java.util.concurrent.Executor;
-import java.util.concurrent.Executors;
 
 public class MetaballViewFINAL extends View {
 
@@ -62,10 +53,8 @@
     private final Drawable drawable;
     private Paint circlePaint1;
     private Paint circlePaint2;
-    private Paint rectPaint;
     private Paint popupPaint;
     private Paint gradientPaint;
-    private Paint avatarPaint;
     private Paint tooltipPaint;
     private TextPaint textPaint;
     private int targetIconAlfa;
@@ -79,22 +68,35 @@
     private float popupX, popupY, popupSize;
 
     private float targetWidth;
-    private int circleColor = 0xFF646464;
-    private int rectColor = 0xFFFFFFFF;
-    private final int defaultAvatarColor;
+    private int circleColor;
+    private int rectColor;
+    private int contentPaddingTop;
     private Paint shadowPaint;
-    protected ArrayList<MessageObject> sendingMessageObjects;
+    private ArrayList<MessageObject> sendingMessageObjects;
+    private final View parentView;
+    private boolean darkTheme = Theme.getActiveTheme().isDark();
+    private Theme.ResourcesProvider resourcesProvider;
 
-    public MetaballViewFINAL(Context context, Drawable drawable, ChatActivity chatActivity, int defaultAvatarColor) {
+    public MetaballViewFINAL(Context context, Drawable drawable, ChatActivity chatActivity, View parentView, Theme.ResourcesProvider resourcesProvider, int h, int w, int contentPaddingTop) {
         super(context);
+        this.parentView = parentView;
         this.drawable = drawable;
-        this.defaultAvatarColor = defaultAvatarColor;
         this.chatActivity = chatActivity;
+        this.resourcesProvider = resourcesProvider;
+        this.h = h;
+        this.w = w;
+        this.contentPaddingTop = contentPaddingTop;
         init();
     }
 
+//    private Paint thresholdPaint;
+
     private void init() {
+//        thresholdPaint = new Paint();
+//        thresholdPaint.setFilterBitmap(true);
+//        thresholdPaint.setColorFilter(new PorterDuffColorFilter(Color.argb(THRESHOLD, 0, 0, 0), PorterDuff.Mode.DST_IN));
 //        choreographer = Choreographer.getInstance();
+        rectColor = getThemedColor(darkTheme ? Theme.key_voipgroup_searchBackground : Theme.key_dialogSearchBackground);
         circleColor = Theme.getThemePaint(Theme.key_paint_chatActionBackground).getColor();
         targetIconAlfa = Color.alpha(circleColor);
         circleColor = Color.argb(255, Color.red(circleColor), Color.green(circleColor), Color.blue(circleColor));
@@ -110,17 +112,12 @@
         shadowPaint.setStyle(Paint.Style.FILL);
         shadowPaint.setMaskFilter(new BlurMaskFilter(dpToPx(80f), BlurMaskFilter.Blur.NORMAL));
 
-        rectPaint = new Paint(Paint.ANTI_ALIAS_FLAG);
-        rectPaint.setColor(rectColor);
         gradientPaint = new Paint(Paint.ANTI_ALIAS_FLAG);
-        avatarPaint = new Paint(Paint.ANTI_ALIAS_FLAG);
-        avatarPaint.setColor(Color.BLUE);
+
         circleSize = dpToPx(32f);
         popupSize = dpToPx(58f);
-        targetWidth = popupSize * 6;
 
         tooltipPaint = new Paint(Paint.ANTI_ALIAS_FLAG);
-        tooltipPaint.setColor(Color.parseColor("#80000000"));
         tooltipPaint.setStyle(Paint.Style.FILL);
 
         textPaint = new TextPaint(Paint.ANTI_ALIAS_FLAG);
@@ -128,8 +125,6 @@
         textPaint.setTextSize(dpToPx(11));
         textPaint.setTypeface(AndroidUtilities.bold());
         textPaint.setTextAlign(Paint.Align.CENTER);
-
-        setLayerType(LAYER_TYPE_HARDWARE, null);
     }
 
     float minY, maxY;
@@ -155,20 +150,6 @@
         minY -= padding + dpToPx(40f);
         maxY += padding;
 
-        drawingAreaTop = minY;
-        drawingAreaBottom = maxY;
-        drawingAreaHeight = drawingAreaBottom - drawingAreaTop;
-    }
-
-
-    @Override
-    protected void onSizeChanged(int width, int height, int oldWidth, int oldHeight) {
-        super.onSizeChanged(width, height, oldWidth, oldHeight);
-
-        // Get view dimensions
-        w = width;
-        h = height;
-
         drawingAreaTop = minY;
         drawingAreaBottom = maxY;
         drawingAreaHeight = drawingAreaBottom - drawingAreaTop;
@@ -181,9 +162,199 @@
         pixels = new int[bitmapWidth * bitmapHeight];
     }
 
+    boolean skipForBitmap;
+
+    private Bitmap captureParentView() {
+        skipForBitmap = true;
+        float scaleFactor = .1f;
+        int scaledWidth = (int) (tooltipRect.width() * scaleFactor);
+        int scaledHeight = (int) (tooltipRect.height() * scaleFactor);
+
+        Bitmap bitmap = Bitmap.createBitmap(
+                scaledWidth,
+                scaledHeight,
+                Bitmap.Config.ARGB_8888
+        );
+
+        Canvas canvas = new Canvas(bitmap);
+        canvas.translate(-tooltipRect.left * scaleFactor, -tooltipRect.top * scaleFactor - dpToPx(87) * scaleFactor);
+        canvas.scale(scaleFactor, scaleFactor);
+
+        parentView.draw(canvas);
+        skipForBitmap = false;
+
+        return bitmap;
+    }
+
+    private int getAdjustedColor(Bitmap bitmap, int prevColor) {
+        int color = getAverageColorSampled(bitmap, 10);
+        float lightThreshold = 200f;
+        float darkThreshold = 55f;
+        float darkenFactor = 0.8f;
+        float lightenFactor = 1.2f;
+
+        if (isColorTooLight(color, lightThreshold)) {
+            color = darkenColor(color, darkenFactor);
+        } else if (isColorTooDark(color, darkThreshold)) {
+            color = lightenColor(color, lightenFactor);
+        }
+        if (prevColor != 0) {
+            color = AndroidUtilities.getAverageColor(prevColor, color);
+        }
+        return color;
+    }
+
+    private static int getAverageColor(Bitmap bitmap, int startX, int startY, int regionWidth, int regionHeight) {
+        long redSum = 0;
+        long greenSum = 0;
+        long blueSum = 0;
+        long pixelCount = 0;
+
+        for (int x = startX; x < startX + regionWidth; x++) {
+            for (int y = startY; y < startY + regionHeight; y++) {
+                if (x >= bitmap.getWidth() || y >= bitmap.getHeight()) {
+                    continue;
+                }
+
+                int pixel = bitmap.getPixel(x, y);
+                redSum += Color.red(pixel);
+                greenSum += Color.green(pixel);
+                blueSum += Color.blue(pixel);
+                pixelCount++;
+            }
+        }
+
+        if (pixelCount == 0) {
+            return Color.GRAY;
+        }
+
+        int avgRed = (int) (redSum / pixelCount);
+        int avgGreen = (int) (greenSum / pixelCount);
+        int avgBlue = (int) (blueSum / pixelCount);
+
+        return Color.rgb(avgRed, avgGreen, avgBlue);
+    }
+
+    public static List<Integer> getTopTwoColors(Bitmap bitmap) {
+        List<Integer> topColors = new ArrayList<>();
+
+        if (bitmap == null || bitmap.isRecycled()) {
+            return topColors;
+        }
+
+        int width = bitmap.getWidth();
+        int height = bitmap.getHeight();
+
+        int midX = width / 2;
+
+        int leftAverageColor = getAverageColor(bitmap, 0, 0, midX, height);
+        topColors.add(leftAverageColor);
+
+        int rightAverageColor = getAverageColor(bitmap, midX, 0, width - midX, height);
+        topColors.add(rightAverageColor);
+
+        return topColors;
+    }
+
+    private int[] getAdjusted2Color(Bitmap bitmap, int[] prevColor) {
+        List<Integer> topColors = getTopTwoColors(bitmap);
+        int[] adjustedColors = new int[2];
+
+        float lightThreshold = 200f;
+        float darkThreshold = 55f;
+        float darkenFactor = 0.8f;
+        float lightenFactor = 1.2f;
+
+        for (int i = 0; i < topColors.size(); i++) {
+            int color = topColors.get(i);
+
+            if (isColorTooLight(color, lightThreshold)) {
+                color = darkenColor(color, darkenFactor);
+            } else if (isColorTooDark(color, darkThreshold)) {
+                color = lightenColor(color, lightenFactor);
+            }
+            adjustedColors[i] = color;
+        }
+
+        if (prevColor[0] != 0) {
+            adjustedColors[0] = AndroidUtilities.getAverageColor(prevColor[0], adjustedColors[0]);
+            adjustedColors[1] = AndroidUtilities.getAverageColor(prevColor[1], adjustedColors[1]);
+        }
+
+        return adjustedColors;
+    }
+
+    public static int lightenColor(int color, float factor) {
+        if (isColorVeryDarkHSV(color, 55f)) return Color.GRAY;
+        float[] hsv = new float[3];
+        Color.colorToHSV(color, hsv);
+        hsv[2] = hsv[2] * factor;
+        hsv[2] = Math.min(hsv[2], 1);
+        return Color.HSVToColor(Color.alpha(color), hsv);
+    }
+
+    public static boolean isColorVeryDarkHSV(int color, float valueThreshold) {
+        float[] hsv = new float[3];
+        Color.colorToHSV(color, hsv);
+        return hsv[2] < valueThreshold;
+    }
+
+    public static int darkenColor(int color, float factor) {
+        float[] hsv = new float[3];
+        Color.colorToHSV(color, hsv);
+        hsv[2] = hsv[2] * factor;
+        hsv[2] = Math.max(hsv[2], 0);
+        return Color.HSVToColor(Color.alpha(color), hsv);
+    }
+
+    public static boolean isColorTooLight(int color, float threshold) {
+        double luminance = 0.299 * Color.red(color) +
+                0.587 * Color.green(color) +
+                0.114 * Color.blue(color);
+        return luminance > threshold;
+    }
+
+    public static boolean isColorTooDark(int color, float threshold) {
+        double luminance = 0.299 * Color.red(color) +
+                0.587 * Color.green(color) +
+                0.114 * Color.blue(color);
+        return luminance < threshold;
+    }
+
+    public int getAverageColorSampled(Bitmap bitmap, int step) {
+        long redSum = 0;
+        long greenSum = 0;
+        long blueSum = 0;
+        int width = bitmap.getWidth();
+        int height = bitmap.getHeight();
+        int count = 0;
+
+        for (int y = 0; y < height; y += step) {
+            for (int x = 0; x < width; x += step) {
+                int color = bitmap.getPixel(x, y);
+                redSum += Color.red(color);
+                greenSum += Color.green(color);
+                blueSum += Color.blue(color);
+                count++;
+            }
+        }
+
+        if (count == 0) {
+            return Color.GRAY;
+        }
+
+        int avgRed = (int) (redSum / count);
+        int avgGreen = (int) (greenSum / count);
+        int avgBlue = (int) (blueSum / count);
+
+        return Color.rgb(avgRed, avgGreen, avgBlue);
+    }
+
+
     @Override
     protected void onDraw(Canvas canvas) {
         super.onDraw(canvas);
+        if (skipForBitmap) return;
         Canvas currentCanvas = animationProgress < 1f ? tempCanvas : canvas;
 
         if (!animationFinished) {
@@ -217,54 +388,55 @@
 
     }
 
-    private void calculateColors() {
-        if (!colorsSet) {
-            for (int i = 0; i < imageReceivers.length; i++) {
-                ImageReceiver imageReceiver = imageReceivers[i];
-                if (imageReceiver.getStaticThumb() instanceof BitmapDrawable) {
-                    final Bitmap bitmap = ((BitmapDrawable) imageReceiver.getStaticThumb()).getBitmap();
-                    try {
-                        final int bitmapColor = bitmap.getPixel(bitmap.getWidth() / 2, bitmap.getHeight() - 2);
-                        float[] hsl = new float[3];
-                        ColorUtils.colorToHSL(bitmapColor, hsl);
-                        if (hsl[1] <= .05f || hsl[1] >= .95f || hsl[2] <= .02f || hsl[2] >= .98f) {
-                            hsl[1] = 0;
-                            hsl[2] = Theme.isCurrentThemeDark() ? .38f : .70f;
-                        } else {
-                            hsl[1] = .25f;
-                            hsl[2] = Theme.isCurrentThemeDark() ? .35f : .65f;
-                        }
-                        colors[i] = ColorUtils.HSLToColor(hsl);
-                    } catch (Exception e) {
-                        FileLog.e(e);
-                    }
-                } else if (!colorsSet && !colorSetFromThumb) {
-                    try {
-                        final int color = ColorUtils.blendARGB(((AvatarDrawable) imageReceiver.getStaticThumb()).getColor(), ((AvatarDrawable) imageReceiver.getStaticThumb()).getColor2(), .5f);
-                        float[] hsl = new float[3];
-                        ColorUtils.colorToHSL(color, hsl);
-                        if (hsl[1] <= .05f || hsl[1] >= .95f) {
-                            hsl[2] = Utilities.clamp(hsl[2] - .1f, .6f, .3f);
-                        } else {
-                            hsl[1] = Utilities.clamp(hsl[1] - .06f, .4f, 0);
-                            hsl[2] = Utilities.clamp(hsl[2] - .08f, .5f, .2f);
-                        }
-                        colors[i] = ColorUtils.HSLToColor(hsl);
-                    } catch (Exception e) {
-                        FileLog.e(e);
-                    }
-                    colorSetFromThumb = true;
-                } else {
-                    colors[i] = defaultAvatarColor;
-                }
-            }
-        }
-        colorsSet = true;
-    }
+//    private void calculateColors() {
+//        if (!colorsSet) {
+//            for (int i = 0; i < imageReceivers.length; i++) {
+//                ImageReceiver imageReceiver = imageReceivers[i];
+//                if (imageReceiver.getStaticThumb() instanceof BitmapDrawable) {
+//                    final Bitmap bitmap = ((BitmapDrawable) imageReceiver.getStaticThumb()).getBitmap();
+//                    try {
+//                        final int bitmapColor = bitmap.getPixel(bitmap.getWidth() / 2, bitmap.getHeight() - 2);
+//                        float[] hsl = new float[3];
+//                        ColorUtils.colorToHSL(bitmapColor, hsl);
+//                        if (hsl[1] <= .05f || hsl[1] >= .95f || hsl[2] <= .02f || hsl[2] >= .98f) {
+//                            hsl[1] = 0;
+//                            hsl[2] = Theme.isCurrentThemeDark() ? .38f : .70f;
+//                        } else {
+//                            hsl[1] = .25f;
+//                            hsl[2] = Theme.isCurrentThemeDark() ? .35f : .65f;
+//                        }
+//                        colors[i] = ColorUtils.HSLToColor(hsl);
+//                    } catch (Exception e) {
+//                        FileLog.e(e);
+//                    }
+//                } else if (!colorsSet && !colorSetFromThumb) {
+//                    try {
+//                        final int color = ColorUtils.blendARGB(((AvatarDrawable) imageReceiver.getStaticThumb()).getColor(), ((AvatarDrawable) imageReceiver.getStaticThumb()).getColor2(), .5f);
+//                        float[] hsl = new float[3];
+//                        ColorUtils.colorToHSL(color, hsl);
+//                        if (hsl[1] <= .05f || hsl[1] >= .95f) {
+//                            hsl[2] = Utilities.clamp(hsl[2] - .1f, .6f, .3f);
+//                        } else {
+//                            hsl[1] = Utilities.clamp(hsl[1] - .06f, .4f, 0);
+//                            hsl[2] = Utilities.clamp(hsl[2] - .08f, .5f, .2f);
+//                        }
+//                        colors[i] = ColorUtils.HSLToColor(hsl);
+//                    } catch (Exception e) {
+//                        FileLog.e(e);
+//                    }
+//                    colorSetFromThumb = true;
+//                } else {
+//                    colors[i] = defaultAvatarColor;
+//                }
+//            }
+//        }
+//        colorsSet = true;
+//    }
 
     float offset1 = dpToPx(12f);
     float offset2 = dpToPx(18f);
     float offset3 = dpToPx(6f);
+    RadialGradient gradient1;
 
     private void drawCircle1(Canvas canvas, Canvas canvas1, float x, float y, float size) {
         float newY;
@@ -281,23 +453,23 @@
             float progress = (animationProgress - 0.5f) / 0.4f;
             newY = y - offset1 + progress * offset2;
         } else {
-            float progress = (animationProgress - 0.9f) / 0.1f;
+            float progress = (Math.min(1, animationProgress) - 0.9f) / 0.1f;
             newY = y - offset1 + offset2 - progress * offset3;
         }
 
 
         if (animationProgress <= 0.80f) {
-            RadialGradient gradient = new RadialGradient(
+            gradient1 = new RadialGradient(
                     x, newY, size / 1.2f,
                     new int[]{circleColor, 0x00000000},
                     new float[]{0.5f, 1.0f},
                     Shader.TileMode.CLAMP
             );
-            circlePaint1.setShader(gradient);
+            circlePaint1.setShader(gradient1);
             canvas.drawCircle(x, newY, size, circlePaint1);
             drawAnimatedIcon(canvas, x, newY, size);
         } else {
-            circlePaint2.setAlpha(Math.max(targetIconAlfa, (int) (255 * (1 - alfaProgress))));
+            circlePaint2.setAlpha(Math.max(targetIconAlfa, (int) (255 * (1 - Math.min(alfaProgress, 1)))));
             canvas1.drawCircle(x, newY, circleSize / 2, circlePaint2);
             drawAnimatedIcon(canvas1, x, newY, size);
         }
@@ -314,7 +486,7 @@
         float iconX = circleX - halfIconSize;
         float iconY = circleY - halfIconSize;
 
-        float rotationAngle = calculateRotationAngle(animationProgress);
+        float rotationAngle = calculateRotationAngle((Math.min(1, animationProgress)));
 
         canvas.save();
 
@@ -342,8 +514,10 @@
         }
     }
 
+    RadialGradient gradient2;
+
     private void drawCircle2(Canvas canvas, float x, float y, float size) {
-        float currentAnimationBorder = 0.5f;
+        float currentAnimationBorder = 0.6f;
         float currentAnimationProgress = Math.min(animationProgress / currentAnimationBorder, 1);
 
         float newY, newX, newSize;
@@ -358,58 +532,66 @@
             newSize -= sizeDecrease * additionalProgress;
         }
 
-        RadialGradient gradient = new RadialGradient(
+        gradient2 = new RadialGradient(
                 newX, newY, Math.max(newSize, 0.001f),
                 new int[]{rectColor, 0x00000000},
                 new float[]{0.5f, 1.0f},
                 Shader.TileMode.CLAMP
         );
-        gradientPaint.setShader(gradient);
+        gradientPaint.setShader(gradient2);
 
         canvas.drawCircle(newX, newY, Math.max(newSize, 0.001f), gradientPaint);
     }
 
+    private RectF rect = new RectF();
+    private RectF shadowRect = new RectF();
+
     private void drawRoundedRect(Canvas canvas, float x, float y, float size, Canvas canvas1) {
         float currentAnimationExpandBorder = 0.4f;
-        float currentAnimationBorder = 0.5f;
+        float currentAnimationBorder = 0.6f;
         float currentAnimationProgress = Math.min(animationProgress / currentAnimationBorder, 1);
         float offset = 0;
 
-        float newY, newX, newSize;
-        float xOffset = dpToPx(0);
-        newX = x + (popupX - x) * currentAnimationProgress - xOffset;
+        float newY, newSize;
         newY = y - Math.abs(y - popupY) * currentAnimationProgress;
-        newSize = size + Math.abs(size - popupSize) * currentAnimationProgress;
+        if (animationProgress > currentAnimationProgress) {
+            newSize = size + Math.abs(size - popupSize) * (animationProgress - currentAnimationBorder) / (1 - currentAnimationBorder);
+        } else {
+            newSize = size + Math.abs(size - popupSize) * currentAnimationProgress;
+        }
 
         float rectWidth = newSize;
         if (animationProgress > currentAnimationExpandBorder) {
-            rectWidth = popupSize + (targetWidth - popupSize) * (animationProgress - currentAnimationExpandBorder);
-            offset = dpToPx(40f) * (animationProgress - currentAnimationExpandBorder);
+            float localProgress = (animationProgress - currentAnimationExpandBorder) / (1 - currentAnimationExpandBorder);
+            rectWidth = popupSize + (targetWidth - popupSize) * localProgress;
+            if (dpToPx(4) + popupX + targetWidth / 2 > w) {
+                offset = ((popupX + targetWidth / 2 + dpToPx(4)) - w) * localProgress;
+            }
         }
         float rectHeight = newSize;
         float cornerRadius = popupSize;
 
-        float leftBound = newX - rectWidth / 2 - offset;
-        float rightBound = newX + rectWidth / 2;
+        float leftBound = x - rectWidth / 2 - offset;
+        float rightBound = x + rectWidth / 2 - offset;
 
-        if (leftBound < dpToPx(4)) {
-            float diff = dpToPx(4) - leftBound;
-            leftBound += diff;
-            rightBound += diff;
-        }
-        if (rightBound > w - dpToPx(4)) {
-            float diff = rightBound - (w - dpToPx(4));
-            leftBound -= diff;
-            rightBound -= diff;
-        }
+//        if (leftBound < dpToPx(4)) {
+//            float diff = dpToPx(4) - leftBound;
+//            leftBound += diff;
+//            rightBound += diff;
+//        }
+//        if (rightBound > w - dpToPx(4)) {
+//            float diff = rightBound - (w - dpToPx(4));
+//            leftBound -= diff;
+//            rightBound -= diff;
+//        }
 
-        RectF rect = new RectF(
+        rect.set(
                 leftBound,
                 newY - rectHeight / 2 - dpToPx(4),
                 rightBound,
                 newY + rectHeight / 2 - dpToPx(4)
         );
-        RectF shadowRect = new RectF(
+        shadowRect.set(
                 rect.left + dpToPx(20),
                 rect.top + dpToPx(20),
                 rect.right - dpToPx(20),
@@ -421,37 +603,51 @@
         drawAvatars(canvas, rect, canvas1);
     }
 
-    private final float ANIMATION_BORDER_1 = 0.42f;
-    private final float ANIMATION_BORDER_2 = 0.60f;
-    private final float ANIMATION_BORDER_3 = 0.89f;
-
 
     Path path = new Path();
     PathMeasure pathMeasure;
     float pathLength;
     float[] pos = new float[2];
+    RectF bounds = new RectF();
+    RectF tooltipRect = new RectF();
+    //    int[] colors = new int[5];
+    int[][] colors2 = new int[5][2];
+    float avatarsPadding = dpToPx(8f);
 
     private void drawAvatars(Canvas canvas, RectF rect, Canvas canvas1) {
         int avatarCount = dialogs.size();
-        float padding = dpToPx(8f);
-        float avatarDiameter = rect.height() - 2 * padding;
-        float totalAvatarWidth = avatarCount * avatarDiameter + (avatarCount - 1) * padding;
+        float avatarDiameter = rect.height() - 2 * avatarsPadding;
+        float totalAvatarWidth = avatarCount * avatarDiameter + (avatarCount - 1) * avatarsPadding;
         float startX = rect.left + (rect.width() - totalAvatarWidth) / 2;
         float centerY = rect.centerY();
 
         for (int i = 0; i < avatarCount; i++) {
-            float avatarX = startX + i * (avatarDiameter + padding);
+            float avatarX = startX + i * (avatarDiameter + avatarsPadding);
             float avatarSize = 0f;
 
-            if (animationProgress > ANIMATION_BORDER_3 && (i == 0 || i == 4)) {
-                float progress = (animationProgress - ANIMATION_BORDER_3) / (1.0f - ANIMATION_BORDER_3);
-                avatarSize = avatarDiameter * Math.min(progress, 1);
-            } else if (animationProgress > ANIMATION_BORDER_2 && (i == 1 || i == 3)) {
-                float progress = (animationProgress - ANIMATION_BORDER_2) / (ANIMATION_BORDER_3 - ANIMATION_BORDER_2) * 0.7f;
-                avatarSize = avatarDiameter * Math.min(progress, 1);
-            } else if (animationProgress > ANIMATION_BORDER_1 && i == 2) {
-                float progress = (animationProgress - ANIMATION_BORDER_1) / (ANIMATION_BORDER_2 - ANIMATION_BORDER_1) * 0.3f;
-                avatarSize = avatarDiameter * Math.min(progress, 1);
+            float animationBorder2 = 0.60f;
+            float animationBorder3 = 0.89f;
+            float animationBorder1 = 0.42f;
+            int centerIndex = avatarCount / 2;
+            int leftNeighbor = centerIndex - 1;
+            int rightNeighbor = centerIndex + 1;
+
+
+            if ((i == 0 || i == avatarCount - 1)) {
+                if (animationProgress > animationBorder3) {
+                    float progress = (animationProgress - animationBorder3) / (1.0f - animationBorder3);
+                    avatarSize = avatarDiameter * Math.min(progress, 1);
+                }
+            } else if ((i == leftNeighbor || i == rightNeighbor)) {
+                if (animationProgress > animationBorder2) {
+                    float progress = (animationProgress - animationBorder2) / (animationBorder3 - animationBorder2) * 0.7f;
+                    avatarSize = avatarDiameter * Math.min(progress, 1);
+                }
+            } else if (i == centerIndex) {
+                if (animationProgress > animationBorder1) {
+                    float progress = (animationProgress - animationBorder1) / (animationBorder2 - animationBorder1) * 0.3f;
+                    avatarSize = avatarDiameter * Math.min(progress, 1);
+                }
             }
 
             if (avatarSize > 0) {
@@ -489,12 +685,11 @@
                         alfa = .6f;
                         scaleFactor = 0f;
                     }
-                    RectF bounds;
                     if (collapseAnimationProgress != 0 && finalAvatarIndex == i) {
                         float scale = 10 * (collapseAnimationProgress);
                         imageReceiver.setAlpha(1);
                         pathMeasure.getPosTan(pathLength * collapseAnimationProgress, pos, null);
-                        bounds = new RectF(
+                        bounds.set(
                                 -dpToPx(2) + dpToPx(scale) + pos[0] + avatarDiameter / 2 - avatarSize / 2,
                                 -dpToPx(2) + dpToPx(scale) + pos[1] - avatarSize / 2,
                                 -dpToPx(2) - dpToPx(scale) + pos[0] + avatarDiameter / 2 - avatarSize / 2 + avatarSize,
@@ -502,7 +697,7 @@
                         );
                     } else if (collapseAnimationProgress != 0) {
                         imageReceiver.setAlpha(alfa * (1 - collapseAnimationProgress));
-                        bounds = new RectF(
+                        bounds.set(
                                 -dpToPx(scaleFactor) + avatarX + avatarDiameter / 2 - avatarSize / 2,
                                 -dpToPx(scaleFactor) + centerY - avatarSize / 2,
                                 dpToPx(scaleFactor) + avatarX + avatarDiameter / 2 - avatarSize / 2 + avatarSize,
@@ -510,7 +705,7 @@
                         );
                     } else {
                         imageReceiver.setAlpha(alfa);
-                        bounds = new RectF(
+                        bounds.set(
                                 -dpToPx(scaleFactor) + avatarX + avatarDiameter / 2 - avatarSize / 2,
                                 -dpToPx(scaleFactor) + centerY - avatarSize / 2,
                                 dpToPx(scaleFactor) + avatarX + avatarDiameter / 2 - avatarSize / 2 + avatarSize,
@@ -520,10 +715,10 @@
                     if (avatarRects.size() != dialogs.size()) {
                         avatarRects.add(
                                 new RectF(
-                                        -(padding / 2 + dpToPx(1)) - dpToPx(scaleFactor) + avatarX + avatarDiameter / 2 - avatarSize / 2,
-                                        -padding - dpToPx(scaleFactor) + centerY - avatarSize / 2,
-                                        (padding / 2 + dpToPx(1)) + dpToPx(scaleFactor) + avatarX + avatarDiameter / 2 - avatarSize / 2 + avatarSize,
-                                        padding + dpToPx(scaleFactor) + centerY - avatarSize / 2 + avatarSize
+                                        -(avatarsPadding / 2 + dpToPx(1)) - dpToPx(scaleFactor) + avatarX + avatarDiameter / 2 - avatarSize / 2,
+                                        -avatarsPadding - dpToPx(scaleFactor) + centerY - avatarSize / 2,
+                                        (avatarsPadding / 2 + dpToPx(1)) + dpToPx(scaleFactor) + avatarX + avatarDiameter / 2 - avatarSize / 2 + avatarSize,
+                                        avatarsPadding + dpToPx(scaleFactor) + centerY - avatarSize / 2 + avatarSize
                                 )
                         );
                     }
@@ -531,7 +726,7 @@
                     imageReceiver.draw(canvas);
 
                     if ((highlightedAvatarIndex != -1 && i == highlightedAvatarIndex) || (previousHighlightedAvatarIndex != -1 && i == previousHighlightedAvatarIndex)) {
-                        int color = colors[i];
+//                        int color = colors[i];
                         String name = TextUtils.ellipsize(names[i].replace('\n', ' '), textPaint, dpToPx(82), TextUtils.TruncateAt.END).toString();
                         Rect textBounds = new Rect();
                         textPaint.getTextBounds(name, 0, name.length(), textBounds);
@@ -545,7 +740,7 @@
                         float tooltipHeight = textHeight + 2 * paddingVertical;
 
                         float left = (bounds.left + bounds.right) / 2 - tooltipWidth / 2;
-                        float top = bounds.top - tooltipHeight - dpToPx(9) - padding;
+                        float top = bounds.top - tooltipHeight - dpToPx(9) - avatarsPadding;
                         float right = left + tooltipWidth;
                         float bottom = top + tooltipHeight;
 
@@ -560,15 +755,33 @@
                             right -= diff;
                         }
                         float currentSelectProgress = (i == previousHighlightedAvatarIndex) ? Math.max(previousTooltipProgress - tooltipProgress, 0) : tooltipProgress;
-                        tooltipPaint.setColor(color);
-                        tooltipPaint.setStrokeWidth(dpToPx(1));
-                        tooltipPaint.setAlpha((int) (currentSelectProgress * 255));
-                        textPaint.setAlpha((int) (currentSelectProgress * 255));
-                        canvas1.drawRoundRect(new RectF(left, top, right, bottom), tooltipHeight, tooltipHeight, tooltipPaint);
-                        canvas1.drawText(name, (left + right) / 2, (top + bottom) / 2 + dpToPx(4), textPaint);
+                        if (currentSelectProgress != 0) {
+                            tooltipPaint.setStrokeWidth(dpToPx(1));
+                            tooltipPaint.setAlpha((int) (currentSelectProgress * 255));
+                            textPaint.setAlpha((int) (currentSelectProgress * 255));
+                            tooltipRect.set(left, top, right, bottom);
+
+                            Bitmap capturedBitmap = captureParentView();
+//                            int tooltipPaintColor = getAdjustedColor(capturedBitmap, colors[i]);
+
+                            int[] tooltipPaintColor2 = getAdjusted2Color(capturedBitmap, colors2[i]);
+                            colors2[i] = tooltipPaintColor2;
+                            Shader linearGradient = new LinearGradient(
+                                    tooltipRect.left, tooltipRect.top, tooltipRect.right, tooltipRect.bottom,
+                                    tooltipPaintColor2[0], tooltipPaintColor2[1],
+                                    Shader.TileMode.CLAMP
+                            );
+                            tooltipPaint.setShader(linearGradient);
+//                            colors[i] = tooltipPaintColor;
+//                            tooltipPaint.setColor(tooltipPaintColor);
+
+                            canvas1.drawRoundRect(tooltipRect, tooltipHeight, tooltipHeight, tooltipPaint);
+                            canvas1.drawText(name, (left + right) / 2, (top + bottom) / 2 + dpToPx(4), textPaint);
+                            invalidate();
+                        }
                     }
                 } else {
-                    RectF bounds = new RectF(
+                    bounds.set(
                             avatarX + avatarDiameter / 2 - avatarSize / 2,
                             centerY - avatarSize / 2,
                             avatarX + avatarDiameter / 2 - avatarSize / 2 + avatarSize,
@@ -581,27 +794,27 @@
         }
     }
 
-    private final Executor executor = Executors.newSingleThreadExecutor();
-    private final Handler mainHandler = new Handler(Looper.getMainLooper());
-
-    private void applyThresholdAsync() {
-        executor.execute(() -> {
-            applyThreshold();
-            mainHandler.post(() -> invalidate());
-        });
-    }
+//    private final Executor executor = Executors.newSingleThreadExecutor();
+//    private final Handler mainHandler = new Handler(Looper.getMainLooper());
+//
+//    private void applyThresholdAsync() {
+//        executor.execute(() -> {
+//            applyThreshold();
+//            mainHandler.post(() -> invalidate());
+//        });
+//    }
 
     int bitmapWidth;
     int bitmapHeight;
     int[] pixels;
 
     private void applyThreshold() {
-
         bitmap.getPixels(pixels, 0, bitmapWidth, 0, 0, bitmapWidth, bitmapHeight);
 
         for (int i = 0; i < pixels.length; i++) {
-            int alpha = (pixels[i] >> 24) & 0xff;
-            if (alpha < THRESHOLD) {
+            int pixel = pixels[i];
+            int alpha = pixel & 0xFF000000;
+            if ((alpha >>> 24) < THRESHOLD) {
                 pixels[i] = 0x01000000;
             }
         }
@@ -659,9 +872,9 @@
                             if (AccountInstance.getInstance(currentAccount).getUserConfig().isPremium()
                                     && DialogObject.isUserDialog(dialogs.get(highlightedAvatarIndex).first)
                                     && UserObject.isUserSelf(MessagesController.getInstance(currentAccount).getUser(dialogs.get(highlightedAvatarIndex).first))) {
-                                path.quadTo(0, rectF.top + rectF.height() / 2, dpToPx(20), dpToPx(44));
+                                path.quadTo(0, Math.min((h + rectF.bottom) / 2, h), dpToPx(20), dpToPx(44) + contentPaddingTop);
                             } else {
-                                path.quadTo(0, rectF.top + rectF.height() / 2, dpToPx(20), h - dpToPx(174));
+                                path.quadTo(0, rectF.top / 2, dpToPx(20), h - dpToPx(174));
                             }
                             pathMeasure = new PathMeasure(path, false);
                             pathLength = pathMeasure.getLength();
@@ -702,18 +915,19 @@
     }
 
     private float dpToPx(float dp) {
-        return AndroidUtilities.dp(dp);
+        return AndroidUtilities.dp2(dp);
     }
 
-    public void init(float x, float y, float height, float sideStartY, ArrayList<MessageObject> messages, float callX, float callY, int[] position) {
+    public void init(float x, ArrayList<MessageObject> messages, float finalY) {
         circleX = x + dpToPx(16);
-        circleY = y + sideStartY + dpToPx(17);
-//        circleY = position[1]-sideStartY+dpToPx(11);
+        circleY = finalY;
         popupX = circleX;
         popupY = circleY - dpToPx(56);
         sendingMessageObjects = messages;
 
         fetchDialogs();
+        float avatarCount = dialogs.size();
+        targetWidth = (popupSize - avatarsPadding * 2) * avatarCount + (avatarCount + 1) * avatarsPadding;
         calculateDrawingArea();
         addAvatars();
 
@@ -763,7 +977,7 @@
         for (ImageReceiver imageReceiver : imageReceivers) {
             imageReceiver.onAttachedToWindow();
         }
-        calculateColors();
+//        calculateColors();
         startAnimation();
 //        startFrameCallback();
     }
@@ -792,9 +1006,8 @@
 
     ImageReceiver[] imageReceivers = {new ImageReceiver(this), new ImageReceiver(this), new ImageReceiver(this), new ImageReceiver(this), new ImageReceiver(this)};
     String[] names = new String[5];
-    int[] colors = new int[5];
-    boolean colorsSet = false;
-    boolean colorSetFromThumb = false;
+//    boolean colorsSet = false;
+//    boolean colorSetFromThumb = false;
 
     public void addAvatars() {
         for (int i = 0; i < Math.min(dialogs.size(), 5); i++) {
@@ -940,6 +1153,10 @@
         tooltipAnimator.start();
     }
 
+    protected int getThemedColor(int key) {
+        return Theme.getColor(key, resourcesProvider);
+    }
+
 
 //    private Choreographer choreographer;
 //    private Choreographer.FrameCallback frameCallback;
Index: 28_10_13_43.patch
===================================================================
diff --git a/28_10_13_43.patch b/28_10_13_43.patch
new file mode 100644
--- /dev/null	(revision 515eebbc36fcedfc483dc6284ce905b185157fdd)
+++ b/28_10_13_43.patch	(revision 515eebbc36fcedfc483dc6284ce905b185157fdd)
@@ -0,0 +1,4941 @@
+Index: 27_10_01_01.patch
+IDEA additional info:
+Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
+<+>UTF-8
+===================================================================
+diff --git a/27_10_01_01.patch b/27_10_01_01.patch
+new file mode 100644
+--- /dev/null	(revision e672c7f3737ff39507d246aecc820df247607992)
++++ b/27_10_01_01.patch	(revision e672c7f3737ff39507d246aecc820df247607992)
+@@ -0,0 +1,3958 @@
++Index: TMessagesProj/src/main/java/org/telegram/ui/MetaballViewFINAL.java
++IDEA additional info:
++Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
++<+>UTF-8
++===================================================================
++diff --git a/TMessagesProj/src/main/java/org/telegram/ui/MetaballViewFINAL.java b/TMessagesProj/src/main/java/org/telegram/ui/MetaballViewFINAL.java
++--- a/TMessagesProj/src/main/java/org/telegram/ui/MetaballViewFINAL.java	(revision 5b351aafc28ceaf2d248cf3e02ccf165461b344d)
+++++ b/TMessagesProj/src/main/java/org/telegram/ui/MetaballViewFINAL.java	(revision 12fd7b127ef09e95009c782c9bcea8e7eb326cab)
++@@ -9,45 +9,66 @@
++ import android.graphics.Canvas;
++ import android.graphics.Color;
++ import android.graphics.Paint;
+++import android.graphics.Path;
+++import android.graphics.PathMeasure;
++ import android.graphics.RadialGradient;
+++import android.graphics.Rect;
++ import android.graphics.RectF;
++ import android.graphics.Shader;
+++import android.graphics.drawable.BitmapDrawable;
++ import android.graphics.drawable.Drawable;
+++import android.os.Handler;
+++import android.os.Looper;
+++import android.text.TextPaint;
+++import android.text.TextUtils;
++ import android.util.Log;
+++import android.util.Pair;
++ import android.view.Choreographer;
++ import android.view.MotionEvent;
++ import android.view.View;
++ import android.view.animation.LinearInterpolator;
+++import android.view.animation.OvershootInterpolator;
++ 
++-import androidx.collection.LongSparseArray;
+++import androidx.core.graphics.ColorUtils;
++ 
+++import org.telegram.messenger.AccountInstance;
+++import org.telegram.messenger.AndroidUtilities;
++ import org.telegram.messenger.ChatObject;
++ import org.telegram.messenger.DialogObject;
+++import org.telegram.messenger.FileLog;
++ import org.telegram.messenger.ImageReceiver;
+++import org.telegram.messenger.LocaleController;
++ import org.telegram.messenger.MessageObject;
++ import org.telegram.messenger.MessagesController;
+++import org.telegram.messenger.R;
++ import org.telegram.messenger.SendMessagesHelper;
++ import org.telegram.messenger.UserConfig;
++ import org.telegram.messenger.UserObject;
+++import org.telegram.messenger.Utilities;
++ import org.telegram.tgnet.TLRPC;
+++import org.telegram.ui.ActionBar.Theme;
++ import org.telegram.ui.Components.AlertsCreator;
++ import org.telegram.ui.Components.AvatarDrawable;
++ 
++ import java.util.ArrayList;
++ import java.util.List;
+++import java.util.concurrent.Executor;
+++import java.util.concurrent.Executors;
++ 
++ public class MetaballViewFINAL extends View {
++ 
++     private final ChatActivity chatActivity;
++     private int currentAccount = UserConfig.selectedAccount;
++     private final Drawable drawable;
++-    private Paint circlePaint;
+++    private Paint circlePaint1;
+++    private Paint circlePaint2;
++     private Paint rectPaint;
++     private Paint popupPaint;
++     private Paint gradientPaint;
++     private Paint avatarPaint;
++     private Paint tooltipPaint;
++-    private Paint textPaint;
+++    private TextPaint textPaint;
+++    private int targetIconAlfa;
++ 
++     private Bitmap bitmap;
++     private Canvas tempCanvas;
++@@ -57,31 +78,37 @@
++     private float circleX, circleY, circleSize;
++     private float popupX, popupY, popupSize;
++ 
++-    //    private TextPaint debugTextPaint;
++     private float targetWidth;
++     private int circleColor = 0xFF646464;
++     private int rectColor = 0xFFFFFFFF;
+++    private final int defaultAvatarColor;
++     private Paint shadowPaint;
++     protected ArrayList<MessageObject> sendingMessageObjects;
++ 
++-    public MetaballViewFINAL(Context context, Drawable drawable, ChatActivity chatActivity) {
+++    public MetaballViewFINAL(Context context, Drawable drawable, ChatActivity chatActivity, int defaultAvatarColor) {
++         super(context);
++         this.drawable = drawable;
+++        this.defaultAvatarColor = defaultAvatarColor;
++         this.chatActivity = chatActivity;
++         init();
++     }
++ 
++     private void init() {
++-        choreographer = Choreographer.getInstance();
++-        circlePaint = new Paint(Paint.ANTI_ALIAS_FLAG);
++-        circlePaint.setColor(circleColor);
+++//        choreographer = Choreographer.getInstance();
+++        circleColor = Theme.getThemePaint(Theme.key_paint_chatActionBackground).getColor();
+++        targetIconAlfa = Color.alpha(circleColor);
+++        circleColor = Color.argb(255, Color.red(circleColor), Color.green(circleColor), Color.blue(circleColor));
+++        circlePaint1 = new Paint(Paint.ANTI_ALIAS_FLAG);
+++        circlePaint1.setColor(circleColor);
+++        circlePaint2 = new Paint(Paint.ANTI_ALIAS_FLAG);
+++        circlePaint2.setColor(circleColor);
++         popupPaint = new Paint(Paint.ANTI_ALIAS_FLAG);
++         popupPaint.setColor(rectColor);
++ 
++         shadowPaint = new Paint(Paint.ANTI_ALIAS_FLAG);
++-        shadowPaint.setColor(Color.BLACK); // Цвет тени
+++        shadowPaint.setColor(Color.BLACK);
++         shadowPaint.setStyle(Paint.Style.FILL);
++-        shadowPaint.setMaskFilter(new BlurMaskFilter(dpToPx(4f), BlurMaskFilter.Blur.NORMAL));
+++        shadowPaint.setMaskFilter(new BlurMaskFilter(dpToPx(80f), BlurMaskFilter.Blur.NORMAL));
++ 
++         rectPaint = new Paint(Paint.ANTI_ALIAS_FLAG);
++         rectPaint.setColor(rectColor);
++@@ -96,22 +123,43 @@
++         tooltipPaint.setColor(Color.parseColor("#80000000"));
++         tooltipPaint.setStyle(Paint.Style.FILL);
++ 
++-        textPaint = new Paint(Paint.ANTI_ALIAS_FLAG);
+++        textPaint = new TextPaint(Paint.ANTI_ALIAS_FLAG);
++         textPaint.setColor(Color.WHITE);
++-        textPaint.setTextSize(40);
+++        textPaint.setTextSize(dpToPx(11));
+++        textPaint.setTypeface(AndroidUtilities.bold());
++         textPaint.setTextAlign(Paint.Align.CENTER);
++ 
++-        circleX = dpToPx(200);
++-        circleY = dpToPx(250);
++-        popupX = dpToPx(200);
++-        popupY = dpToPx(200);
+++        setLayerType(LAYER_TYPE_HARDWARE, null);
+++    }
++ 
++-//        debugTextPaint = new TextPaint();
++-//        debugTextPaint.setColor(Color.BLACK);
++-//        debugTextPaint.setAntiAlias(true);
++-//        debugTextPaint.setTextSize(dpToPx(14f));
++-//        debugTextPaint.setTextAlign(Paint.Align.LEFT);
+++    float minY, maxY;
+++    float drawingAreaTop;
+++    float drawingAreaBottom;
+++    float drawingAreaHeight;
+++
+++    private void calculateDrawingArea() {
+++
+++        float circle1UpwardMovement = dpToPx(12f) * 2;
+++        float circle1DownwardMovement = dpToPx(18f) + dpToPx(6f);
+++
+++        float circle1MinY = circleY - circle1UpwardMovement;
+++        float circle1MaxY = circleY + circle1DownwardMovement;
+++
+++        float popupMinY = popupY - dpToPx(0);
+++        float popupMaxY = popupY + popupSize;
+++
+++        minY = Math.min(circle1MinY, popupMinY);
+++        maxY = Math.max(circle1MaxY, popupMaxY);
+++
+++        float padding = dpToPx(1f);
+++        minY -= padding + dpToPx(40f);
+++        maxY += padding;
+++
+++        drawingAreaTop = minY;
+++        drawingAreaBottom = maxY;
+++        drawingAreaHeight = drawingAreaBottom - drawingAreaTop;
++     }
+++
++ 
++     @Override
++     protected void onSizeChanged(int width, int height, int oldWidth, int oldHeight) {
++@@ -121,41 +169,110 @@
++         w = width;
++         h = height;
++ 
++-        // Initialize the bitmap and canvas for off-screen drawing
++-        bitmap = Bitmap.createBitmap(w, h, Bitmap.Config.ARGB_8888);
+++        drawingAreaTop = minY;
+++        drawingAreaBottom = maxY;
+++        drawingAreaHeight = drawingAreaBottom - drawingAreaTop;
+++
+++        bitmap = Bitmap.createBitmap(w, (int) drawingAreaHeight, Bitmap.Config.ARGB_8888);
++         tempCanvas = new Canvas(bitmap);
+++
+++        bitmapWidth = bitmap.getWidth();
+++        bitmapHeight = bitmap.getHeight();
+++        pixels = new int[bitmapWidth * bitmapHeight];
++     }
++ 
++     @Override
++     protected void onDraw(Canvas canvas) {
++         super.onDraw(canvas);
++-        setAlpha(1f - collapseAnimationProgress);
++-        bitmap.eraseColor(0);
+++        Canvas currentCanvas = animationProgress < 1f ? tempCanvas : canvas;
+++
+++        if (!animationFinished) {
+++            bitmap.eraseColor(0);
++ 
+++            tempCanvas.save();
+++            tempCanvas.translate(0, -drawingAreaTop);
+++        }
+++
+++        if (!animationFinished) {
+++            drawCircle1(tempCanvas, canvas, circleX, circleY, circleSize);
+++        }
++         if (animationProgress < 1f) {
++-            drawCircle1(tempCanvas, circleX, circleY, circleSize);
+++            drawCircle2(currentCanvas, circleX, circleY, circleSize);
++         }
++-//        if (animationProgress <= ANIMATION_BORDER_1) {
++-        drawCircle2(tempCanvas, circleX, circleY, circleSize);
++-//        }
++-        drawRoundedRect(tempCanvas, circleX, circleY, circleSize, canvas);
++-        applyThreshold();
+++
+++        if (collapseAnimationProgress > 0) {
+++            int alpha = (int) (255 * (1f - collapseAnimationProgress));
+++            shadowPaint.setAlpha(alpha);
+++            popupPaint.setAlpha(alpha);
+++        }
+++
+++        drawRoundedRect(currentCanvas, circleX, circleY, circleSize, canvas);
+++
+++        if (!animationFinished) {
+++            tempCanvas.restore();
+++
+++            applyThreshold();
+++            canvas.drawBitmap(bitmap, 0, drawingAreaTop, gradientPaint);
+++        }
++ 
++-        canvas.drawBitmap(bitmap, 0, 0, gradientPaint);
+++    }
++ 
++-//        drawDebugInfo(canvas);
+++    private void calculateColors() {
+++        if (!colorsSet) {
+++            for (int i = 0; i < imageReceivers.length; i++) {
+++                ImageReceiver imageReceiver = imageReceivers[i];
+++                if (imageReceiver.getStaticThumb() instanceof BitmapDrawable) {
+++                    final Bitmap bitmap = ((BitmapDrawable) imageReceiver.getStaticThumb()).getBitmap();
+++                    try {
+++                        final int bitmapColor = bitmap.getPixel(bitmap.getWidth() / 2, bitmap.getHeight() - 2);
+++                        float[] hsl = new float[3];
+++                        ColorUtils.colorToHSL(bitmapColor, hsl);
+++                        if (hsl[1] <= .05f || hsl[1] >= .95f || hsl[2] <= .02f || hsl[2] >= .98f) {
+++                            hsl[1] = 0;
+++                            hsl[2] = Theme.isCurrentThemeDark() ? .38f : .70f;
+++                        } else {
+++                            hsl[1] = .25f;
+++                            hsl[2] = Theme.isCurrentThemeDark() ? .35f : .65f;
+++                        }
+++                        colors[i] = ColorUtils.HSLToColor(hsl);
+++                    } catch (Exception e) {
+++                        FileLog.e(e);
+++                    }
+++                } else if (!colorsSet && !colorSetFromThumb) {
+++                    try {
+++                        final int color = ColorUtils.blendARGB(((AvatarDrawable) imageReceiver.getStaticThumb()).getColor(), ((AvatarDrawable) imageReceiver.getStaticThumb()).getColor2(), .5f);
+++                        float[] hsl = new float[3];
+++                        ColorUtils.colorToHSL(color, hsl);
+++                        if (hsl[1] <= .05f || hsl[1] >= .95f) {
+++                            hsl[2] = Utilities.clamp(hsl[2] - .1f, .6f, .3f);
+++                        } else {
+++                            hsl[1] = Utilities.clamp(hsl[1] - .06f, .4f, 0);
+++                            hsl[2] = Utilities.clamp(hsl[2] - .08f, .5f, .2f);
+++                        }
+++                        colors[i] = ColorUtils.HSLToColor(hsl);
+++                    } catch (Exception e) {
+++                        FileLog.e(e);
+++                    }
+++                    colorSetFromThumb = true;
+++                } else {
+++                    colors[i] = defaultAvatarColor;
+++                }
+++            }
+++        }
+++        colorsSet = true;
++     }
++ 
++-    private void drawCircle1(Canvas canvas, float x, float y, float size) {
++-        float offset1 = dpToPx(12f);
++-        float offset2 = dpToPx(18f);
++-        float offset3 = dpToPx(6f);
+++    float offset1 = dpToPx(12f);
+++    float offset2 = dpToPx(18f);
+++    float offset3 = dpToPx(6f);
+++
+++    private void drawCircle1(Canvas canvas, Canvas canvas1, float x, float y, float size) {
++         float newY;
++ 
++         float alfaProgress = 0f;
++ 
++-        if (animationProgress > 0.7f) {
++-            alfaProgress = (animationProgress - 0.7f) / 0.3f;
+++        if (animationProgress > 0.80f) {
+++            alfaProgress = (animationProgress - 0.8f) / 0.2f;
++         }
++ 
++         if (animationProgress <= 0.5f) {
++@@ -168,19 +285,22 @@
++             newY = y - offset1 + offset2 - progress * offset3;
++         }
++ 
++-//        circlePaint.setAlpha((int) (1 - alfaProgress) * 255);
++-//        if (alfaProgress <= 0) {
++-        RadialGradient gradient = new RadialGradient(
++-                x, newY, size / 1.2f,
++-                new int[]{circleColor, 0x00000000},
++-                new float[]{0.5f, 1.0f},
++-                Shader.TileMode.CLAMP
++-        );
++-        circlePaint.setShader(gradient);
++-//        }
++-
++-        canvas.drawCircle(x, newY, size, circlePaint);
++-        drawAnimatedIcon(canvas, x, newY, size);
+++
+++        if (animationProgress <= 0.80f) {
+++            RadialGradient gradient = new RadialGradient(
+++                    x, newY, size / 1.2f,
+++                    new int[]{circleColor, 0x00000000},
+++                    new float[]{0.5f, 1.0f},
+++                    Shader.TileMode.CLAMP
+++            );
+++            circlePaint1.setShader(gradient);
+++            canvas.drawCircle(x, newY, size, circlePaint1);
+++            drawAnimatedIcon(canvas, x, newY, size);
+++        } else {
+++            circlePaint2.setAlpha(Math.max(targetIconAlfa, (int) (255 * (1 - alfaProgress))));
+++            canvas1.drawCircle(x, newY, circleSize / 2, circlePaint2);
+++            drawAnimatedIcon(canvas1, x, newY, size);
+++        }
++     }
++ 
++     private void drawAnimatedIcon(Canvas canvas, float circleX, float circleY, float circleSize) {
++@@ -188,7 +308,7 @@
++             return;
++         }
++ 
++-        float iconSize = dpToPx(24f); // Пример размера иконки
+++        float iconSize = dpToPx(24f);
++         float halfIconSize = iconSize / 2f;
++ 
++         float iconX = circleX - halfIconSize;
++@@ -211,19 +331,19 @@
++ 
++     private float calculateRotationAngle(float progress) {
++         if (progress <= 0.5f) {
++-            float normalizedProgress = progress / 0.5f; // 0.0 - 1.0
+++            float normalizedProgress = progress / 0.5f;
++             return -30f * normalizedProgress;
++         } else if (progress <= 0.9f) {
++-            float normalizedProgress = (progress - 0.5f) / 0.4f; // 0.0 - 1.0
++-            return -30f + 60f * normalizedProgress; // От -30 до +30
+++            float normalizedProgress = (progress - 0.5f) / 0.4f;
+++            return -30f + 60f * normalizedProgress;
++         } else {
++-            float normalizedProgress = (progress - 0.9f) / 0.1f; // 0.0 - 1.0
++-            return 30f - 30f * normalizedProgress; // От +30 до 0
+++            float normalizedProgress = (progress - 0.9f) / 0.1f;
+++            return 30f - 30f * normalizedProgress;
++         }
++     }
++ 
++     private void drawCircle2(Canvas canvas, float x, float y, float size) {
++-        float currentAnimationBorder = 0.5f; // Порог для первой части анимации
+++        float currentAnimationBorder = 0.5f;
++         float currentAnimationProgress = Math.min(animationProgress / currentAnimationBorder, 1);
++ 
++         float newY, newX, newSize;
++@@ -233,15 +353,15 @@
++         newSize = size + Math.abs(size - popupSize) * currentAnimationProgress;
++ 
++         if (animationProgress > 0.4f) {
++-            float additionalProgress = Math.abs((animationProgress - 0.4f)) / 0.6f; // Нормализуем прогресс от 0.5 до 1.0
++-            float sizeDecrease = dpToPx(20f);
++-            newSize -= sizeDecrease * additionalProgress; // Уменьшаем размер на 10dp
+++            float additionalProgress = Math.abs((animationProgress - 0.4f)) / 0.6f;
+++            float sizeDecrease = dpToPx(22f);
+++            newSize -= sizeDecrease * additionalProgress;
++         }
++ 
++         RadialGradient gradient = new RadialGradient(
++                 newX, newY, Math.max(newSize, 0.001f),
++-                new int[]{rectColor, 0x00000000}, // Переход от красного к прозрачному
++-                new float[]{0.5f, 1.0f}, // Сохраняем резкий переход
+++                new int[]{rectColor, 0x00000000},
+++                new float[]{0.5f, 1.0f},
++                 Shader.TileMode.CLAMP
++         );
++         gradientPaint.setShader(gradient);
++@@ -290,25 +410,29 @@
++                 newY + rectHeight / 2 - dpToPx(4)
++         );
++         RectF shadowRect = new RectF(
++-                rect.left,
++-                rect.top + dpToPx(1f),
++-                rect.right,
++-                rect.bottom + dpToPx(1f)
+++                rect.left + dpToPx(20),
+++                rect.top + dpToPx(20),
+++                rect.right - dpToPx(20),
+++                rect.bottom - dpToPx(20)
++         );
++         canvas1.drawRoundRect(shadowRect, cornerRadius, cornerRadius, shadowPaint);
++-
++         canvas.drawRoundRect(rect, cornerRadius, cornerRadius, popupPaint);
++ 
++-        drawAvatars(canvas, rect);
+++        drawAvatars(canvas, rect, canvas1);
++     }
++-
++ 
++     private final float ANIMATION_BORDER_1 = 0.42f;
++     private final float ANIMATION_BORDER_2 = 0.60f;
++     private final float ANIMATION_BORDER_3 = 0.89f;
++ 
++-    private void drawAvatars(Canvas canvas, RectF rect) {
++-        int avatarCount = 5;
+++
+++    Path path = new Path();
+++    PathMeasure pathMeasure;
+++    float pathLength;
+++    float[] pos = new float[2];
+++
+++    private void drawAvatars(Canvas canvas, RectF rect, Canvas canvas1) {
+++        int avatarCount = dialogs.size();
++         float padding = dpToPx(8f);
++         float avatarDiameter = rect.height() - 2 * padding;
++         float totalAvatarWidth = avatarCount * avatarDiameter + (avatarCount - 1) * padding;
++@@ -331,78 +455,149 @@
++             }
++ 
++             if (avatarSize > 0) {
++-                float alfa;
++-                float scaleFactor = 0f;
++-
++                 ImageReceiver imageReceiver = imageReceivers[i];
++-                String name = names[i];
++-                imageReceiver.setRoundRadius((int) dpToPx(500));
+++                imageReceiver.setRoundRadius((int) popupSize);
++                 if (animationProgress >= 1f) {
++-                    if (highlightedAvatarIndex == i || highlightedAvatarIndex == -1) {
++-                        alfa = 1f;
+++                    float alfa;
+++                    float scaleFactor;
+++
+++                    if (highlightedAvatarIndex == -1 && previousHighlightedAvatarIndex != -1) {
+++                        if (i == previousHighlightedAvatarIndex) {
+++                            scaleFactor = 2f * Math.max(previousTooltipProgress - tooltipProgress, 0);
+++                            alfa = .6f + .4f * Math.max(previousTooltipProgress, tooltipProgress);
+++                        } else {
+++                            scaleFactor = 0f;
+++                            alfa = .6f + .4f * tooltipProgress;
+++                        }
+++                    } else if (highlightedAvatarIndex == -1 && finalAvatarIndex == -1) {
++                         scaleFactor = 0f;
++-                        if (highlightedAvatarIndex == i) {
++-                            scaleFactor = 2f;
++-                        }
++-                    } else {
+++                        alfa = 1f;
+++                    } else if ((highlightedAvatarIndex == i) || (i == previousHighlightedAvatarIndex)) {
+++                        if (previousHighlightedAvatarIndex == -1) {
+++                            alfa = 1f;
+++                            scaleFactor = 2f * tooltipProgress;
+++                        } else {
+++                            float currentSelectProgress = (i == previousHighlightedAvatarIndex) ? Math.max(previousTooltipProgress - tooltipProgress, 0) : tooltipProgress;
+++                            alfa = .6f + .4f * currentSelectProgress;
+++                            scaleFactor = 2f * currentSelectProgress;
+++                        }
+++                    } else if (previousHighlightedAvatarIndex == -1) {
+++                        float currentSelectProgress = tooltipProgress;
+++                        alfa = 1f - .4f * currentSelectProgress;
++                         scaleFactor = 0f;
+++                    } else {
++                         alfa = .6f;
+++                        scaleFactor = 0f;
++                     }
++-                    imageReceiver.setAlpha(alfa);
++-                }
++-                if (animationProgress >= 1f) {
++-                    avatarRects.add(
++-                            new RectF(
++-                                    -(padding / 2 + dpToPx(1)) - dpToPx(scaleFactor) + avatarX + avatarDiameter / 2 - avatarSize / 2,
++-                                    -padding - dpToPx(scaleFactor) + centerY - avatarSize / 2,
++-                                    (padding / 2 + dpToPx(1)) + dpToPx(scaleFactor) + avatarX + avatarDiameter / 2 - avatarSize / 2 + avatarSize,
++-                                    padding + dpToPx(scaleFactor) + centerY - avatarSize / 2 + avatarSize
++-                            )
++-                    );
++-                }
++-                RectF bounds = new RectF(
++-                        -dpToPx(scaleFactor) + avatarX + avatarDiameter / 2 - avatarSize / 2,
++-                        -dpToPx(scaleFactor) + centerY - avatarSize / 2,
++-                        dpToPx(scaleFactor) + avatarX + avatarDiameter / 2 - avatarSize / 2 + avatarSize,
++-                        dpToPx(scaleFactor) + centerY - avatarSize / 2 + avatarSize
++-                );
++-                imageReceiver.setImageCoords(
++-                        bounds
++-                );
++-                imageReceiver.draw(canvas);
+++                    RectF bounds;
+++                    if (collapseAnimationProgress != 0 && finalAvatarIndex == i) {
+++                        float scale = 10 * (collapseAnimationProgress);
+++                        imageReceiver.setAlpha(1);
+++                        pathMeasure.getPosTan(pathLength * collapseAnimationProgress, pos, null);
+++                        bounds = new RectF(
+++                                -dpToPx(2) + dpToPx(scale) + pos[0] + avatarDiameter / 2 - avatarSize / 2,
+++                                -dpToPx(2) + dpToPx(scale) + pos[1] - avatarSize / 2,
+++                                -dpToPx(2) - dpToPx(scale) + pos[0] + avatarDiameter / 2 - avatarSize / 2 + avatarSize,
+++                                -dpToPx(2) - dpToPx(scale) + pos[1] - avatarSize / 2 + avatarSize
+++                        );
+++                    } else if (collapseAnimationProgress != 0) {
+++                        imageReceiver.setAlpha(alfa * (1 - collapseAnimationProgress));
+++                        bounds = new RectF(
+++                                -dpToPx(scaleFactor) + avatarX + avatarDiameter / 2 - avatarSize / 2,
+++                                -dpToPx(scaleFactor) + centerY - avatarSize / 2,
+++                                dpToPx(scaleFactor) + avatarX + avatarDiameter / 2 - avatarSize / 2 + avatarSize,
+++                                dpToPx(scaleFactor) + centerY - avatarSize / 2 + avatarSize
+++                        );
+++                    } else {
+++                        imageReceiver.setAlpha(alfa);
+++                        bounds = new RectF(
+++                                -dpToPx(scaleFactor) + avatarX + avatarDiameter / 2 - avatarSize / 2,
+++                                -dpToPx(scaleFactor) + centerY - avatarSize / 2,
+++                                dpToPx(scaleFactor) + avatarX + avatarDiameter / 2 - avatarSize / 2 + avatarSize,
+++                                dpToPx(scaleFactor) + centerY - avatarSize / 2 + avatarSize
+++                        );
+++                    }
+++                    if (avatarRects.size() != dialogs.size()) {
+++                        avatarRects.add(
+++                                new RectF(
+++                                        -(padding / 2 + dpToPx(1)) - dpToPx(scaleFactor) + avatarX + avatarDiameter / 2 - avatarSize / 2,
+++                                        -padding - dpToPx(scaleFactor) + centerY - avatarSize / 2,
+++                                        (padding / 2 + dpToPx(1)) + dpToPx(scaleFactor) + avatarX + avatarDiameter / 2 - avatarSize / 2 + avatarSize,
+++                                        padding + dpToPx(scaleFactor) + centerY - avatarSize / 2 + avatarSize
+++                                )
+++                        );
+++                    }
+++                    imageReceiver.setImageCoords(bounds);
+++                    imageReceiver.draw(canvas);
++ 
++-//                canvas.drawRect(
++-//                        new RectF(
++-//                                -padding / 2 - dpToPx(scaleFactor) + avatarX + avatarDiameter / 2 - avatarSize / 2,
++-//                                -padding / 2 - dpToPx(scaleFactor) + centerY - avatarSize / 2,
++-//                                padding / 2 + dpToPx(scaleFactor) + avatarX + avatarDiameter / 2 - avatarSize / 2 + avatarSize,
++-//                                padding / 2 + dpToPx(scaleFactor) + centerY - avatarSize / 2 + avatarSize
++-//                        ), avatarPaint);
++-//                canvas.drawCircle(avatarX + avatarDiameter / 2, centerY, avatarSize / 2, avatarPaint);
+++                    if ((highlightedAvatarIndex != -1 && i == highlightedAvatarIndex) || (previousHighlightedAvatarIndex != -1 && i == previousHighlightedAvatarIndex)) {
+++                        int color = colors[i];
+++                        String name = TextUtils.ellipsize(names[i].replace('\n', ' '), textPaint, dpToPx(82), TextUtils.TruncateAt.END).toString();
+++                        Rect textBounds = new Rect();
+++                        textPaint.getTextBounds(name, 0, name.length(), textBounds);
+++
+++                        float paddingHorizontal = dpToPx(7f);
+++                        float paddingVertical = dpToPx(5f);
++ 
++-                if (highlightedAvatarIndex != -1 && i == highlightedAvatarIndex) {
++-                    float tooltipWidth = 200;
++-                    float tooltipHeight = 60;
++-                    float left = bounds.left + (bounds.width() - tooltipWidth) / 2;
++-                    float top = bounds.top - tooltipHeight - 10;
++-                    float right = left + tooltipWidth;
++-                    float bottom = top + tooltipHeight;
+++                        float textWidth = textBounds.width();
+++                        float textHeight = textBounds.height();
+++                        float tooltipWidth = textWidth + 2 * paddingHorizontal;
+++                        float tooltipHeight = textHeight + 2 * paddingVertical;
+++
+++                        float left = (bounds.left + bounds.right) / 2 - tooltipWidth / 2;
+++                        float top = bounds.top - tooltipHeight - dpToPx(9) - padding;
+++                        float right = left + tooltipWidth;
+++                        float bottom = top + tooltipHeight;
++ 
++-                    tooltipPaint.setAlpha((int) (tooltipAlpha * 255));
++-                    canvas.drawRoundRect(new RectF(left, top, right, bottom), 20, 20, tooltipPaint);
++-
++-                    textPaint.setAlpha((int) (tooltipAlpha * 255));
++-                    float textX = left + tooltipWidth / 2;
++-                    float textY = top + tooltipHeight / 2 - ((textPaint.descent() + textPaint.ascent()) / 2);
++-                    canvas.drawText(name, textX, textY, textPaint);
+++                        if (left < dpToPx(4)) {
+++                            float diff = dpToPx(4) - left;
+++                            left += diff;
+++                            right += diff;
+++                        }
+++                        if (right > w - dpToPx(4)) {
+++                            float diff = right - (w - dpToPx(4));
+++                            left -= diff;
+++                            right -= diff;
+++                        }
+++                        float currentSelectProgress = (i == previousHighlightedAvatarIndex) ? Math.max(previousTooltipProgress - tooltipProgress, 0) : tooltipProgress;
+++                        tooltipPaint.setColor(color);
+++                        tooltipPaint.setStrokeWidth(dpToPx(1));
+++                        tooltipPaint.setAlpha((int) (currentSelectProgress * 255));
+++                        textPaint.setAlpha((int) (currentSelectProgress * 255));
+++                        canvas1.drawRoundRect(new RectF(left, top, right, bottom), tooltipHeight, tooltipHeight, tooltipPaint);
+++                        canvas1.drawText(name, (left + right) / 2, (top + bottom) / 2 + dpToPx(4), textPaint);
+++                    }
+++                } else {
+++                    RectF bounds = new RectF(
+++                            avatarX + avatarDiameter / 2 - avatarSize / 2,
+++                            centerY - avatarSize / 2,
+++                            avatarX + avatarDiameter / 2 - avatarSize / 2 + avatarSize,
+++                            centerY - avatarSize / 2 + avatarSize
+++                    );
+++                    imageReceiver.setImageCoords(bounds);
+++                    imageReceiver.draw(canvas);
++                 }
++             }
++         }
++     }
+++
+++    private final Executor executor = Executors.newSingleThreadExecutor();
+++    private final Handler mainHandler = new Handler(Looper.getMainLooper());
+++
+++    private void applyThresholdAsync() {
+++        executor.execute(() -> {
+++            applyThreshold();
+++            mainHandler.post(() -> invalidate());
+++        });
+++    }
+++
+++    int bitmapWidth;
+++    int bitmapHeight;
+++    int[] pixels;
++ 
++     private void applyThreshold() {
++-        int[] pixels = new int[w * h];
++-        bitmap.getPixels(pixels, 0, w, 0, 0, w, h);
+++
+++        bitmap.getPixels(pixels, 0, bitmapWidth, 0, 0, bitmapWidth, bitmapHeight);
++ 
++         for (int i = 0; i < pixels.length; i++) {
++             int alpha = (pixels[i] >> 24) & 0xff;
++@@ -411,11 +606,14 @@
++             }
++         }
++ 
++-        bitmap.setPixels(pixels, 0, w, 0, 0, w, h);
+++        bitmap.setPixels(pixels, 0, bitmapWidth, 0, 0, bitmapWidth, bitmapHeight);
++     }
+++
++ 
++     private boolean isTouchActive = true;
++     private int highlightedAvatarIndex = -1;
+++    private int finalAvatarIndex = -1;
+++    private int previousHighlightedAvatarIndex = -1;
++ 
++     @Override
++     public boolean onTouchEvent(MotionEvent event) {
++@@ -429,22 +627,48 @@
++                         int previousHighlightedIndex = highlightedAvatarIndex;
++                         highlightedAvatarIndex = getTouchedAvatarIndex(touchX, touchY - getY());
++                         if (previousHighlightedIndex != highlightedAvatarIndex) {
+++                            previousHighlightedAvatarIndex = previousHighlightedIndex;
++                             animateTooltip();
++                         }
++                     }
++                 }
++                 return true;
++ 
++-            case MotionEvent.ACTION_UP:
++             case MotionEvent.ACTION_CANCEL:
+++                if (isTouchActive) {
+++                    isTouchActive = false;
+++                    if (animationFinished) {
+++                        collapseAnimation();
+++                        highlightedAvatarIndex = -1;
+++                        previousHighlightedAvatarIndex = -1;
+++                    } else {
+++                        reverseAnimation();
+++                    }
+++                    return true;
+++                }
+++                break;
+++            case MotionEvent.ACTION_UP:
++                 if (isTouchActive) {
++                     isTouchActive = false;
++                     if (animationProgress >= 1f) {
++                         if (highlightedAvatarIndex != -1) {
++-                            sendInternal();
+++                            sendInternal(highlightedAvatarIndex);
+++                            RectF rectF = avatarRects.get(highlightedAvatarIndex);
+++                            path.reset();
+++                            path.moveTo(rectF.left + rectF.width() / 2 - dpToPx(20), rectF.top + rectF.height() / 2);
+++                            if (AccountInstance.getInstance(currentAccount).getUserConfig().isPremium()
+++                                    && DialogObject.isUserDialog(dialogs.get(highlightedAvatarIndex).first)
+++                                    && UserObject.isUserSelf(MessagesController.getInstance(currentAccount).getUser(dialogs.get(highlightedAvatarIndex).first))) {
+++                                path.quadTo(0, rectF.top + rectF.height() / 2, dpToPx(20), dpToPx(44));
+++                            } else {
+++                                path.quadTo(0, rectF.top + rectF.height() / 2, dpToPx(20), h - dpToPx(174));
+++                            }
+++                            pathMeasure = new PathMeasure(path, false);
+++                            pathLength = pathMeasure.getLength();
++                         }
++                         collapseAnimation();
++                         highlightedAvatarIndex = -1;
+++                        previousHighlightedAvatarIndex = -1;
++                     } else {
++                         reverseAnimation();
++                     }
++@@ -460,7 +684,7 @@
++     private int getTouchedAvatarIndex(float x, float y) {
++         for (int i = 0; i < avatarRects.size(); i++) {
++             RectF rect = avatarRects.get(i);
++-            if (rect.contains(x, y)) {
+++            if (rect.left <= x && x <= rect.right && rect.top - dpToPx(80) <= y && y <= rect.bottom + dpToPx(80)) {
++                 return i;
++             }
++         }
++@@ -468,63 +692,42 @@
++     }
++ 
++     private float animationProgress = 0f;
+++    private boolean animationFinished = false;
++     private float collapseAnimationProgress = 0f;
++-    private float tooltipAlpha = 0f;
++-    private float tooltipTargetAlpha = 0f;
+++    private float tooltipProgress = 0f;
+++    private float previousTooltipProgress = 0f;
++ 
++     private boolean isPointInsideCircle(float x, float y, float centerX, float centerY, float radius) {
++         return Math.hypot(x - centerX, y - centerY) <= radius;
++     }
++ 
++     private float dpToPx(float dp) {
++-        return dp * getResources().getDisplayMetrics().density;
+++        return AndroidUtilities.dp(dp);
++     }
++ 
++-//    private void drawDebugInfo(Canvas canvas) {
++-//        // Позиция текста на экране (левый верхний угол)
++-//        float x = dpToPx(10f); // Отступ от левого края
++-//        float y = dpToPx(20f); // Отступ от верхнего края
++-//
++-//        // Формирование строки с информацией о прогрессе
++-//        String debugText = String.format("Progress: %.2f", animationProgress);
++-//
++-//        // Разбиваем текст на строки (если используем переносы строк)
++-//        String[] lines = debugText.split("\n");
++-//
++-//        // Отрисовываем каждую строку текста
++-//        for (String line : lines) {
++-//            canvas.drawText(line, x, y, debugTextPaint);
++-//            y += debugTextPaint.getTextSize() + dpToPx(4f); // Переходим на следующую строку с отступом
++-//        }
++-//    }
++-
++-    public void init(float x, float y, float height, float sideStartY, ArrayList<MessageObject> messages) {
+++    public void init(float x, float y, float height, float sideStartY, ArrayList<MessageObject> messages, float callX, float callY, int[] position) {
++         circleX = x + dpToPx(16);
++         circleY = y + sideStartY + dpToPx(17);
+++//        circleY = position[1]-sideStartY+dpToPx(11);
++         popupX = circleX;
++         popupY = circleY - dpToPx(56);
++         sendingMessageObjects = messages;
++ 
++         fetchDialogs();
+++        calculateDrawingArea();
++         addAvatars();
++ 
++     }
++ 
++-    private ArrayList<TLRPC.Dialog> dialogs = new ArrayList<>();
++-    private LongSparseArray<TLRPC.Dialog> dialogsMap = new LongSparseArray<>();
++-    private LongSparseArray<TLRPC.Dialog> selectedDialogs = new LongSparseArray<>();
+++    private ArrayList<Pair<Long, TLRPC.Dialog>> dialogs = new ArrayList<>();
++ 
++     public void fetchDialogs() {
++         dialogs.clear();
++-        dialogsMap.clear();
++-        selectedDialogs.clear();
++         long selfUserId = UserConfig.getInstance(currentAccount).clientUserId;
++         if (!MessagesController.getInstance(currentAccount).dialogsForward.isEmpty()) {
++             TLRPC.Dialog dialog = MessagesController.getInstance(currentAccount).dialogsForward.get(0);
++-            dialogs.add(dialog);
++-            dialogsMap.put(dialog.id, dialog);
+++            dialogs.add(new Pair<>(dialog.id, dialog));
++         }
++-        ArrayList<TLRPC.Dialog> archivedDialogs = new ArrayList<>();
++         ArrayList<TLRPC.Dialog> allDialogs = MessagesController.getInstance(currentAccount).getAllDialogs();
++         for (int a = 0; a < allDialogs.size(); a++) {
++             TLRPC.Dialog dialog = allDialogs.get(a);
++@@ -536,43 +739,33 @@
++             }
++             if (!DialogObject.isEncryptedDialog(dialog.id)) {
++                 if (DialogObject.isUserDialog(dialog.id)) {
++-                    if (dialog.folder_id == 1) {
++-                        archivedDialogs.add(dialog);
++-                    } else {
++-                        dialogs.add(dialog);
++-                    }
++-                    dialogsMap.put(dialog.id, dialog);
+++                    dialogs.add(new Pair<>(dialog.id, dialog));
++                 } else {
++                     TLRPC.Chat chat = MessagesController.getInstance(currentAccount).getChat(-dialog.id);
++                     if (!(chat == null || ChatObject.isNotInChat(chat) || chat.gigagroup && !ChatObject.hasAdminRights(chat) || ChatObject.isChannel(chat) && !chat.creator && (chat.admin_rights == null || !chat.admin_rights.post_messages) && !chat.megagroup)) {
++-                        if (dialog.folder_id == 1) {
++-                            archivedDialogs.add(dialog);
++-                        } else {
++-                            dialogs.add(dialog);
++-                        }
++-                        dialogsMap.put(dialog.id, dialog);
+++                        dialogs.add(new Pair<>(dialog.id, dialog));
++                     }
++                 }
++             }
++         }
++-        dialogs.addAll(archivedDialogs);
++         try {
++-            List<TLRPC.Dialog> sublist = new ArrayList<>(dialogs.subList(0, Math.min(5, dialogs.size())));
+++            List<Pair<Long, TLRPC.Dialog>> sublist = new ArrayList<>(dialogs.subList(0, Math.min(5, dialogs.size())));
++             dialogs.clear();
++             dialogs.addAll(sublist);
++         } catch (Exception e) {
++-            //
+++            FileLog.e(e);
++         }
++     }
++ 
++     @Override
++     protected void onAttachedToWindow() {
++         super.onAttachedToWindow();
++-        startAnimation();
++         for (ImageReceiver imageReceiver : imageReceivers) {
++             imageReceiver.onAttachedToWindow();
++         }
++-        startFrameCallback();
+++        calculateColors();
+++        startAnimation();
+++//        startFrameCallback();
++     }
++ 
++     @Override
++@@ -581,24 +774,35 @@
++         for (ImageReceiver imageReceiver : imageReceivers) {
++             imageReceiver.onDetachedFromWindow();
++         }
++-        stopFrameCallback();
+++//        stopFrameCallback();
+++        if (animator != null) {
+++            animator.cancel();
+++        }
+++        if (collapseAnimator != null) {
+++            collapseAnimator.cancel();
+++        }
+++        if (tooltipAnimator != null) {
+++            tooltipAnimator.cancel();
+++        }
+++
+++        animator = null;
+++        collapseAnimator = null;
+++        tooltipAnimator = null;
++     }
++ 
++     ImageReceiver[] imageReceivers = {new ImageReceiver(this), new ImageReceiver(this), new ImageReceiver(this), new ImageReceiver(this), new ImageReceiver(this)};
++     String[] names = new String[5];
+++    int[] colors = new int[5];
+++    boolean colorsSet = false;
+++    boolean colorSetFromThumb = false;
++ 
++     public void addAvatars() {
++         for (int i = 0; i < Math.min(dialogs.size(), 5); i++) {
++-            AvatarDrawable avatarDrawable = new AvatarDrawable() {
++-                @Override
++-                public void invalidateSelf() {
++-                    super.invalidateSelf();
++-                }
++-            };
+++            AvatarDrawable avatarDrawable = new AvatarDrawable();
++             ImageReceiver imageReceiver = imageReceivers[i];
++             imageReceiver.setInvalidateAll(true);
++             imageReceiver.setCrossfadeDuration(0);
++-            TLRPC.Dialog dialog = dialogs.get(i);
+++            TLRPC.Dialog dialog = dialogs.get(i).second;
++             long dialogId = dialog.id;
++             if (DialogObject.isUserDialog(dialogId)) {
++                 TLRPC.User user = MessagesController.getInstance(currentAccount).getUser(dialogId);
++@@ -606,11 +810,14 @@
++                 names[i] = UserObject.getFirstName(user);
++                 if (UserObject.isReplyUser(user)) {
++                     avatarDrawable.setAvatarType(AvatarDrawable.AVATAR_TYPE_REPLIES);
+++                    imageReceiver.setForUserOrChat(user, avatarDrawable);
++                 } else if (UserObject.isUserSelf(user)) {
++                     avatarDrawable.setAvatarType(AvatarDrawable.AVATAR_TYPE_SAVED);
++-                }
++-
++-                imageReceiver.setForUserOrChat(user, avatarDrawable);
+++                    names[i] = LocaleController.getString(R.string.SavedMessages);
+++                    imageReceiver.setImage(null, null, null, null, avatarDrawable, 0, null, user, 0);
+++                } else {
+++                    imageReceiver.setForUserOrChat(user, avatarDrawable);
+++                }
++             } else {
++                 TLRPC.Chat chat = MessagesController.getInstance(currentAccount).getChat(-dialogId);
++                 avatarDrawable.setInfo(currentAccount, chat);
++@@ -620,17 +827,18 @@
++         }
++     }
++ 
++-    protected void sendInternal() {
++-        if (highlightedAvatarIndex != -1) {
+++    protected void sendInternal(int index) {
+++        if (index != -1) {
+++            finalAvatarIndex = index;
++             boolean withSound = true;
++-            long key = dialogsMap.keyAt(highlightedAvatarIndex);
+++            long key = dialogs.get(index).first;
++             if (AlertsCreator.checkSlowMode(getContext(), currentAccount, key, false)) {
++                 return;
++             }
++             if (sendingMessageObjects != null) {
++                 int result = SendMessagesHelper.getInstance(currentAccount).sendMessage(sendingMessageObjects, key, true, false, withSound, 0, null);
++                 AlertsCreator.showSendMediaAlert(result, chatActivity, null);
++-                onSend(dialogsMap.get(key), sendingMessageObjects.size(), null);
+++                onSend(dialogs.get(index).second, sendingMessageObjects.size(), null);
++             }
++         }
++     }
++@@ -652,12 +860,10 @@
++     private ValueAnimator collapseAnimator;
++     private ValueAnimator tooltipAnimator;
++ 
++-    private final long durationFactor = 5;
++-
++     public void startAnimation() {
++         animator = ValueAnimator.ofFloat(0f, 1f);
++-        animator.setDuration(600 * durationFactor);
++-        animator.setInterpolator(new LinearInterpolator());
+++        animator.setDuration(500);
+++        animator.setInterpolator(new OvershootInterpolator(1.01f));
++ 
++         animator.addUpdateListener(animation -> {
++             animationProgress = (float) animation.getAnimatedValue();
++@@ -668,6 +874,7 @@
++             @Override
++             public void onAnimationEnd(Animator animation) {
++                 animationProgress = 1f;
+++                animationFinished = true;
++                 onAnimationFinished();
++                 postInvalidateOnAnimation();
++             }
++@@ -678,9 +885,8 @@
++ 
++     private void collapseAnimation() {
++         collapseAnimator = ValueAnimator.ofFloat(collapseAnimationProgress, 1f);
++-        collapseAnimator.setDuration(200 * durationFactor);
+++        collapseAnimator.setDuration(300);
++         collapseAnimator.setInterpolator(new LinearInterpolator());
++-
++         collapseAnimator.addUpdateListener(animation -> {
++             collapseAnimationProgress = (float) animation.getAnimatedValue();
++             postInvalidateOnAnimation();
++@@ -691,6 +897,7 @@
++             public void onAnimationEnd(Animator animation) {
++                 collapseAnimationProgress = 1f;
++                 highlightedAvatarIndex = -1;
+++                previousHighlightedAvatarIndex = -1;
++                 postInvalidateOnAnimation();
++                 onCollapseAnimationFinished();
++             }
++@@ -701,7 +908,7 @@
++ 
++     private void reverseAnimation() {
++         animator = ValueAnimator.ofFloat(animationProgress, 0f);
++-        animator.setDuration(200 * durationFactor);
+++        animator.setDuration(150);
++         animator.setInterpolator(new LinearInterpolator());
++ 
++         animator.addUpdateListener(animation -> {
++@@ -723,61 +930,51 @@
++     }
++ 
++     private void animateTooltip() {
++-        if (tooltipAnimator != null && tooltipAnimator.isRunning()) {
++-            tooltipAnimator.cancel();
++-        }
++-
++-        if (highlightedAvatarIndex != -1) {
++-            tooltipTargetAlpha = 1f;
++-        } else {
++-            tooltipTargetAlpha = 0f;
++-        }
++-
++-        tooltipAnimator = ValueAnimator.ofFloat(tooltipAlpha, tooltipTargetAlpha);
++-        tooltipAnimator.setDuration(200 * durationFactor);
+++        previousTooltipProgress = tooltipProgress;
+++        tooltipAnimator = ValueAnimator.ofFloat(0, 1);
+++        tooltipAnimator.setDuration(150);
++         tooltipAnimator.addUpdateListener(animation -> {
++-            tooltipAlpha = (float) animation.getAnimatedValue();
+++            tooltipProgress = (float) animation.getAnimatedValue();
++             postInvalidateOnAnimation();
++         });
++         tooltipAnimator.start();
++     }
++ 
++ 
++-    private Choreographer choreographer;
++-    private Choreographer.FrameCallback frameCallback;
++-
++-    private int frameCount = 0;
++-    private long lastTime = 0L;
+++//    private Choreographer choreographer;
+++//    private Choreographer.FrameCallback frameCallback;
++ 
++-    private void startFrameCallback() {
++-        frameCallback = new Choreographer.FrameCallback() {
++-            @Override
++-            public void doFrame(long frameTimeNanos) {
++-                if (lastTime == 0L) {
++-                    lastTime = frameTimeNanos;
++-                }
++-                frameCount++;
++-
++-                long delta = frameTimeNanos - lastTime;
++-                if (delta >= 1_000_000_000L) { // 1 секунда в наносекундах
++-                    double fps = frameCount * 1_000_000_000.0 / delta;
++-                    Log.d("Performance", "FPS: " + fps);
++-                    frameCount = 0;
++-                    lastTime = frameTimeNanos;
++-                }
++-
++-                // Регистрируем следующий фрейм
++-                choreographer.postFrameCallback(this);
++-            }
++-        };
++-        choreographer.postFrameCallback(frameCallback);
++-    }
++-
++-    private void stopFrameCallback() {
++-        if (frameCallback != null) {
++-            choreographer.removeFrameCallback(frameCallback);
++-            frameCallback = null;
++-        }
++-    }
++-}
++-
+++//    private int frameCount = 0;
+++//    private long lastTime = 0L;
+++//
+++//    private void startFrameCallback() {
+++//        frameCallback = new Choreographer.FrameCallback() {
+++//            @Override
+++//            public void doFrame(long frameTimeNanos) {
+++//                if (lastTime == 0L) {
+++//                    lastTime = frameTimeNanos;
+++//                }
+++//                frameCount++;
+++//
+++//                long delta = frameTimeNanos - lastTime;
+++//                if (delta >= 1_000_000_000L) {
+++//                    double fps = frameCount * 1_000_000_000.0 / delta;
+++//                    Log.d("Performance", "FPS: " + fps);
+++//                    frameCount = 0;
+++//                    lastTime = frameTimeNanos;
+++//                }
+++//
+++//
+++//                choreographer.postFrameCallback(this);
+++//            }
+++//        };
+++//        choreographer.postFrameCallback(frameCallback);
+++//    }
+++//
+++//    private void stopFrameCallback() {
+++//        if (frameCallback != null) {
+++//            choreographer.removeFrameCallback(frameCallback);
+++//            frameCallback = null;
+++//        }
+++//    }
+++}
++\ No newline at end of file
++Index: TMessagesProj/src/main/java/org/telegram/ui/ChatActivity.java
++IDEA additional info:
++Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
++<+>UTF-8
++===================================================================
++diff --git a/TMessagesProj/src/main/java/org/telegram/ui/ChatActivity.java b/TMessagesProj/src/main/java/org/telegram/ui/ChatActivity.java
++--- a/TMessagesProj/src/main/java/org/telegram/ui/ChatActivity.java	(revision c6c7c30b280bf4928cfaabcfb8db3a0c00d6cf5e)
+++++ b/TMessagesProj/src/main/java/org/telegram/ui/ChatActivity.java	(revision 12fd7b127ef09e95009c782c9bcea8e7eb326cab)
++@@ -36243,7 +36243,11 @@
++                 if (popupView != null) {
++                     contentView.removeView(popupView);
++                 }
++-                popupView = new MetaballViewFINAL(getContext(), getThemedDrawable(Theme.key_drawable_shareIcon), ChatActivity.this) {
+++                if (getParentActivity() instanceof LaunchActivity) {
+++                    ((LaunchActivity)getParentActivity()).drawerLayoutContainer.setAllowOpenDrawerBySwipe(false);
+++                }
+++                int defaultColor = Theme.blendOver(cell.getThemedColor(Theme.key_chat_inBubble), Theme.multAlpha(cell.getThemedColor(Theme.key_windowBackgroundWhiteGrayText), .85f));
+++                popupView = new MetaballViewFINAL(getContext(), getThemedDrawable(Theme.key_drawable_shareIcon), ChatActivity.this, defaultColor) {
++                     @Override
++                     protected void onSend(TLRPC.Dialog did, int count, TLRPC.TL_forumTopic topic) {
++                         createUndoView();
++@@ -36265,6 +36269,10 @@
++                     protected void onCollapseAnimationFinished() {
++                         contentView.removeView(popupView);
++                         popupView = null;
+++
+++                        if (getParentActivity() instanceof LaunchActivity) {
+++                            ((LaunchActivity)getParentActivity()).drawerLayoutContainer.setAllowOpenDrawerBySwipe(true);
+++                        }
++                     }
++                 };
++                 ArrayList<MessageObject> arrayList = null;
++@@ -36279,7 +36287,16 @@
++                     arrayList = new ArrayList<>();
++                     arrayList.add(messageObject);
++                 }
++-                popupView.init(cell.sideStartX, cell.getY(), cell.getHeight(), cell.sideStartY, arrayList);
+++                int[] position = new int[2];
+++                cell.getLocationOnScreen(position);
+++                int[] position2 = new int[2];
+++//                cell.getTransitionParams().ignoreAlpha = true;
+++//                cell.setAlpha(0.0f);
+++//                cell.setTimeAlpha(0.0f);
+++                cell.getLocationOnScreen(position2);
+++                Rect rect = new Rect();
+++                cell.getGlobalVisibleRect(rect);
+++                popupView.init(cell.sideStartX, cell.getY(), cell.getHeight(), cell.sideStartY, arrayList, x, y, position);
++                 contentView.addView(popupView);
++                 cell.showSideButton1240 = true;
++             } else {
++Index: 25_10_22_09.patch
++IDEA additional info:
++Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
++<+>UTF-8
++===================================================================
++diff --git a/25_10_22_09.patch b/25_10_22_09.patch
++new file mode 100644
++--- /dev/null	(revision 405a062031f2eaccb7ef3fd3ee8cdbe588e28581)
+++++ b/25_10_22_09.patch	(revision 405a062031f2eaccb7ef3fd3ee8cdbe588e28581)
++@@ -0,0 +1,1952 @@
+++Index: TMessagesProj/src/main/java/org/telegram/ui/Components/FragmentContextView.java
+++IDEA additional info:
+++Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
+++<+>UTF-8
+++===================================================================
+++diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Components/FragmentContextView.java b/TMessagesProj/src/main/java/org/telegram/ui/Components/FragmentContextView.java
+++--- a/TMessagesProj/src/main/java/org/telegram/ui/Components/FragmentContextView.java	(revision 4fbb29b41c7cb4ebaa4d7e38d927d7a4dad8c5bc)
++++++ b/TMessagesProj/src/main/java/org/telegram/ui/Components/FragmentContextView.java	(revision 428164c193d20737d82612eb41af602cec0d6891)
+++@@ -16,6 +16,7 @@
+++ import android.content.Context;
+++ import android.content.DialogInterface;
+++ import android.content.Intent;
++++import android.content.SharedPreferences;
+++ import android.graphics.Canvas;
+++ import android.graphics.Color;
+++ import android.graphics.LinearGradient;
+++@@ -81,6 +82,7 @@
+++ import org.telegram.ui.GroupCallActivity;
+++ import org.telegram.ui.LaunchActivity;
+++ import org.telegram.ui.LocationActivity;
++++import org.telegram.ui.Stories.recorder.HintView2;
+++ 
+++ import java.lang.annotation.Retention;
+++ import java.lang.annotation.RetentionPolicy;
+++@@ -172,7 +174,9 @@
+++             int currentTime = fragment.getConnectionsManager().getCurrentTime();
+++             int diff = call.call.schedule_date - currentTime;
+++             String str;
+++-            if (diff >= 24 * 60 * 60) {
++++            if (!call.call.schedule_start_subscribed && !ChatObject.canManageCalls(chatActivity.getCurrentChat())) {
++++                str = LocaleController.getString(R.string.VoipChatNotify);
++++            } else if (diff >= 24 * 60 * 60) {
+++                 str = LocaleController.formatPluralString("Days", Math.round(diff / (24 * 60 * 60.0f)));
+++             } else {
+++                 str = AndroidUtilities.formatFullDuration(call.call.schedule_date - currentTime);
+++@@ -184,6 +188,7 @@
+++         }
+++     };
+++ 
++++    private HintView2 reminderHintView;
+++     private final int account = UserConfig.selectedAccount;
+++ 
+++     private boolean isLocation;
+++@@ -736,7 +741,31 @@
+++                 if (call == null) {
+++                     return;
+++                 }
+++-                VoIPHelper.startCall(fragment.getMessagesController().getChat(call.chatId), null, null, false, call.call != null && !call.call.rtmp_stream, fragment.getParentActivity(), fragment, fragment.getAccountInstance());
++++                if (!call.call.schedule_start_subscribed && !ChatObject.canManageCalls(chatActivity.getCurrentChat())) {
++++                    TLRPC.TL_phone_toggleGroupCallStartSubscription req = new TLRPC.TL_phone_toggleGroupCallStartSubscription();
++++                    req.call = call.getInputGroupCall();
++++                    call.call.schedule_start_subscribed = !call.call.schedule_start_subscribed;
++++                    req.subscribed = call.call.schedule_start_subscribed;
++++                    AccountInstance accountInstance = AccountInstance.getInstance(account);
++++                    accountInstance.getConnectionsManager().sendRequest(req, (response, error) -> {
++++                        if (response != null) {
++++                            accountInstance.getMessagesController().processUpdates((TLRPC.Updates) response, false);
++++                        }
++++                    });
++++                    String text;
++++                    if (!TextUtils.isEmpty(call.call.title)) {
++++                        text = call.call.title;
++++                    } else if (call.call.rtmp_stream) {
++++                        text = LocaleController.getString(R.string.VoipChannelVoiceChat);
++++                    } else if (ChatObject.isChannelOrGiga(chatActivity.getCurrentChat())) {
++++                        text = LocaleController.getString(R.string.VoipChannelVoiceChat);
++++                    } else {
++++                        text = LocaleController.getString(R.string.VoipGroupVoiceChat);
++++                    }
++++                    showReminderBulletin(LocaleController.formatString(R.string.VoipChatNotifyHint, text.toLowerCase()));
++++                } else {
++++                    VoIPHelper.startCall(fragment.getMessagesController().getChat(call.chatId), null, null, false, call.call != null && !call.call.rtmp_stream, fragment.getParentActivity(), fragment, fragment.getAccountInstance());
++++                }
+++             } else if (currentStyle == STYLE_IMPORTING_MESSAGES) {
+++                 SendMessagesHelper.ImportingHistory importingHistory = fragment.getSendMessagesHelper().getImportingHistory(((ChatActivity) fragment).getDialogId());
+++                 if (importingHistory == null) {
+++@@ -2438,4 +2467,8 @@
+++     private int getThemedColor(int key) {
+++         return Theme.getColor(key, resourcesProvider);
+++     }
++++
++++    private void showReminderBulletin(String text) {
++++        BulletinFactory.of(fragment).createSimpleBulletin(R.raw.silent_unmute, text).show();
++++    }
+++ }
+++Index: TMessagesProj/src/main/res/values/strings.xml
+++IDEA additional info:
+++Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
+++<+>UTF-8
+++===================================================================
+++diff --git a/TMessagesProj/src/main/res/values/strings.xml b/TMessagesProj/src/main/res/values/strings.xml
+++--- a/TMessagesProj/src/main/res/values/strings.xml	(revision 4fbb29b41c7cb4ebaa4d7e38d927d7a4dad8c5bc)
++++++ b/TMessagesProj/src/main/res/values/strings.xml	(revision 36b54fb5d4043a8b09c07fc986eba1e68a0f4a1f)
+++@@ -3041,6 +3041,7 @@
+++     <string name="OpenFile">OPEN FILE</string>
+++     <string name="ShowInChat">Show in chat</string>
+++     <string name="StopDownload">Stop downloading</string>
++++    <string name="Cast">Cast</string>
+++     <string name="SaveToGallery">Save to gallery</string>
+++     <string name="Of">%1$d of %2$d</string>
+++     <string name="TaggedMessages_one">%1$d message</string>
+++@@ -4036,6 +4037,7 @@
+++     <string name="StartVoipChatPermission">Manage Live Streams</string>
+++     <string name="VoipChatJoin">Join</string>
+++     <string name="VoipChatNotify">Notify me</string>
++++    <string name="VoipChatNotifyHint">You will be notified when the %s starts</string>
+++     <string name="MembersTalking_one">%1$s member talking</string>
+++     <string name="MembersTalking_other">%1$s members talking</string>
+++     <string name="Speaking">speaking</string>
+++Index: TMessagesProj/build.gradle
+++IDEA additional info:
+++Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
+++<+>UTF-8
+++===================================================================
+++diff --git a/TMessagesProj/build.gradle b/TMessagesProj/build.gradle
+++--- a/TMessagesProj/build.gradle	(revision cfc2e67ff72f1977751c13468162144efb393cbb)
++++++ b/TMessagesProj/build.gradle	(revision 36b54fb5d4043a8b09c07fc986eba1e68a0f4a1f)
+++@@ -47,6 +47,9 @@
+++     implementation 'com.google.guava:guava:31.1-android'
+++     implementation 'com.google.android.play:integrity:1.3.0'
+++     implementation 'com.google.android.gms:play-services-safetynet:18.0.1'
++++    implementation 'androidx.media3:media3-cast:1.4.1'
++++    implementation 'androidx.media3:media3-common:1.4.1'
++++    implementation 'org.nanohttpd:nanohttpd:2.3.1'
+++ 
+++     implementation 'com.google.android.gms:play-services-mlkit-subject-segmentation:16.0.0-beta1'
+++     implementation 'com.google.android.gms:play-services-mlkit-image-labeling:16.0.8'
+++Index: TMessagesProj/src/main/AndroidManifest.xml
+++IDEA additional info:
+++Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
+++<+>UTF-8
+++===================================================================
+++diff --git a/TMessagesProj/src/main/AndroidManifest.xml b/TMessagesProj/src/main/AndroidManifest.xml
+++--- a/TMessagesProj/src/main/AndroidManifest.xml	(revision cfc2e67ff72f1977751c13468162144efb393cbb)
++++++ b/TMessagesProj/src/main/AndroidManifest.xml	(revision 36b54fb5d4043a8b09c07fc986eba1e68a0f4a1f)
+++@@ -674,6 +674,9 @@
+++ 
+++         <meta-data android:name="android.max_aspect" android:value="2.5" />
+++ 
++++        <meta-data android:name="com.google.android.gms.cast.framework.OPTIONS_PROVIDER_CLASS_NAME"
++++            android:value="androidx.media3.cast.DefaultCastOptionsProvider"/>
++++
+++     </application>
+++ 
+++ </manifest>
+++Index: TMessagesProj/src/main/java/org/telegram/messenger/ApplicationLoader.java
+++IDEA additional info:
+++Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
+++<+>UTF-8
+++===================================================================
+++diff --git a/TMessagesProj/src/main/java/org/telegram/messenger/ApplicationLoader.java b/TMessagesProj/src/main/java/org/telegram/messenger/ApplicationLoader.java
+++--- a/TMessagesProj/src/main/java/org/telegram/messenger/ApplicationLoader.java	(revision cfc2e67ff72f1977751c13468162144efb393cbb)
++++++ b/TMessagesProj/src/main/java/org/telegram/messenger/ApplicationLoader.java	(revision 36b54fb5d4043a8b09c07fc986eba1e68a0f4a1f)
+++@@ -319,6 +319,7 @@
+++ 
+++         LauncherIconController.tryFixLauncherIconIfNeeded();
+++         ProxyRotationController.init();
++++        ChromeCastController.getInstance().init(this);
+++     }
+++ 
+++     public static void startPushService() {
+++Index: TMessagesProj/src/main/java/org/telegram/messenger/ChromeCastController.java
+++IDEA additional info:
+++Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
+++<+>UTF-8
+++===================================================================
+++diff --git a/TMessagesProj/src/main/java/org/telegram/messenger/ChromeCastController.java b/TMessagesProj/src/main/java/org/telegram/messenger/ChromeCastController.java
+++new file mode 100644
+++--- /dev/null	(revision 36b54fb5d4043a8b09c07fc986eba1e68a0f4a1f)
++++++ b/TMessagesProj/src/main/java/org/telegram/messenger/ChromeCastController.java	(revision 36b54fb5d4043a8b09c07fc986eba1e68a0f4a1f)
+++@@ -0,0 +1,143 @@
++++package org.telegram.messenger;
++++
++++import android.app.Application;
++++import android.net.Uri;
++++
++++import androidx.annotation.NonNull;
++++import androidx.annotation.Nullable;
++++import androidx.media3.cast.CastPlayer;
++++import androidx.media3.cast.SessionAvailabilityListener;
++++import androidx.media3.common.C;
++++import androidx.media3.common.MediaItem;
++++import androidx.media3.common.Player;
++++import androidx.media3.common.util.UnstableApi;
++++
++++import com.google.android.gms.cast.framework.CastContext;
++++import com.google.android.gms.common.ConnectionResult;
++++import com.google.android.gms.common.GoogleApiAvailability;
++++
++++import java.io.IOException;
++++import java.net.InetAddress;
++++import java.net.NetworkInterface;
++++import java.util.ArrayList;
++++import java.util.Collections;
++++import java.util.List;
++++
++++@UnstableApi
++++public class ChromeCastController implements Player.Listener, SessionAvailabilityListener {
++++
++++    private static ChromeCastController instance;
++++    private CastContext castContext;
++++    public boolean isGooglePlayServicesAvailable;
++++    private CastPlayer castPlayer;
++++    private final ArrayList<MediaItem> mediaQueue = new ArrayList<>();
++++    private LocalFileHttpServer httpServer;
++++    private Application application;
++++    int port = 8080;
++++    @Nullable
++++    private VideoPlayerPausePlay listener;
++++
++++    private ChromeCastController() {
++++    }
++++
++++    public static ChromeCastController getInstance() {
++++        if (instance == null) {
++++            instance = new ChromeCastController();
++++        }
++++        return instance;
++++    }
++++
++++    public void init(Application application) {
++++        isGooglePlayServicesAvailable = GoogleApiAvailability.getInstance().isGooglePlayServicesAvailable(application) == ConnectionResult.SUCCESS;
++++        if (isGooglePlayServicesAvailable) {
++++            this.application = application;
++++            castContext = CastContext.getSharedInstance(application);
++++            castPlayer = new CastPlayer(castContext);
++++            castPlayer.addListener(this);
++++            castPlayer.setSessionAvailabilityListener(this);
++++        }
++++    }
++++
++++    public void addVideoPlayerListener(VideoPlayerPausePlay listener) {
++++        this.listener = listener;
++++    }
++++
++++    @Override
++++    public void onCastSessionAvailable() {
++++        if (httpServer != null) {
++++            httpServer.stop();
++++        }
++++        httpServer = new LocalFileHttpServer(port, application);
++++        try {
++++            httpServer.start();
++++        } catch (IOException e) {
++++            //
++++        }
++++        play();
++++    }
++++
++++    private void play() {
++++        castPlayer.setMediaItems(mediaQueue, C.INDEX_UNSET, C.TIME_UNSET);
++++        castPlayer.setPlayWhenReady(true);
++++        castPlayer.prepare();
++++        if (listener != null) {
++++            AndroidUtilities.runOnUIThread(() -> {
++++                listener.pause();
++++            }, 3000);
++++        }
++++    }
++++
++++    @Override
++++    public void onCastSessionUnavailable() {
++++        castPlayer.stop();
++++        castPlayer.clearMediaItems();
++++        if (listener != null) listener.play();
++++    }
++++
++++    public void setItem(Uri uri, String type) {
++++        MediaItem item = getMediaItem(uri, type);
++++        mediaQueue.clear();
++++        castPlayer.clearMediaItems();
++++        mediaQueue.add(item);
++++        castPlayer.addMediaItem(item);
++++        if (castPlayer.isCastSessionAvailable()) {
++++            play();
++++        }
++++    }
++++
++++    private @NonNull MediaItem getMediaItem(Uri uri, String type) {
++++        return new MediaItem.Builder().setUri("http://" + getDeviceIpAddress() + ":" + port + "/" + uri.toString())
++++                .setMimeType(type)
++++                .build();
++++    }
++++
++++
++++    private static String getDeviceIpAddress() {
++++        try {
++++            List<NetworkInterface> interfaces = Collections.list(NetworkInterface.getNetworkInterfaces());
++++            for (NetworkInterface networkInterface : interfaces) {
++++                List<InetAddress> addresses = Collections.list(networkInterface.getInetAddresses());
++++                for (InetAddress inetAddress : addresses) {
++++                    if (!inetAddress.isLoopbackAddress() && inetAddress.isSiteLocalAddress()) {
++++                        return inetAddress.getHostAddress();
++++                    }
++++                }
++++            }
++++        } catch (Exception e) {
++++            //
++++        }
++++        return null;
++++    }
++++
++++    public void release() {
++++        mediaQueue.clear();
++++        castPlayer.setSessionAvailabilityListener(null);
++++        castPlayer.release();
++++        listener = null;
++++    }
++++
++++    public interface VideoPlayerPausePlay {
++++        void pause();
++++        void play();
++++    }
++++}
+++Index: TMessagesProj/src/main/java/org/telegram/messenger/LocalFileHttpServer.java
+++IDEA additional info:
+++Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
+++<+>UTF-8
+++===================================================================
+++diff --git a/TMessagesProj/src/main/java/org/telegram/messenger/LocalFileHttpServer.java b/TMessagesProj/src/main/java/org/telegram/messenger/LocalFileHttpServer.java
+++new file mode 100644
+++--- /dev/null	(revision 36b54fb5d4043a8b09c07fc986eba1e68a0f4a1f)
++++++ b/TMessagesProj/src/main/java/org/telegram/messenger/LocalFileHttpServer.java	(revision 36b54fb5d4043a8b09c07fc986eba1e68a0f4a1f)
+++@@ -0,0 +1,33 @@
++++package org.telegram.messenger;
++++
++++import android.app.Application;
++++import android.net.Uri;
++++import android.os.ParcelFileDescriptor;
++++
++++import java.io.FileInputStream;
++++import java.io.IOException;
++++
++++import fi.iki.elonen.NanoHTTPD;
++++
++++public class LocalFileHttpServer extends NanoHTTPD {
++++
++++    private final Application application;
++++
++++    public LocalFileHttpServer(int port, Application application) {
++++        super(port);
++++        this.application = application;
++++    }
++++
++++    @Override
++++    public Response serve(IHTTPSession session) {
++++        try {
++++            String uri = session.getUri();
++++            Uri fileUri = Uri.parse( uri.substring(1));
++++            ParcelFileDescriptor parcelFileDescriptor = application.getContentResolver().openFileDescriptor(fileUri, "r");
++++            FileInputStream fis = new FileInputStream(parcelFileDescriptor.getFileDescriptor());
++++            return newChunkedResponse(Response.Status.OK, "video/mp4", fis);
++++        } catch (IOException e) {
++++            return newFixedLengthResponse(Response.Status.NOT_FOUND, "text/plain", "File not found");
++++        }
++++    }
++++}
+++\ No newline at end of file
+++Index: TMessagesProj/src/main/java/org/telegram/ui/Components/VideoPlayer.java
+++IDEA additional info:
+++Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
+++<+>UTF-8
+++===================================================================
+++diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Components/VideoPlayer.java b/TMessagesProj/src/main/java/org/telegram/ui/Components/VideoPlayer.java
+++--- a/TMessagesProj/src/main/java/org/telegram/ui/Components/VideoPlayer.java	(revision cfc2e67ff72f1977751c13468162144efb393cbb)
++++++ b/TMessagesProj/src/main/java/org/telegram/ui/Components/VideoPlayer.java	(revision 36b54fb5d4043a8b09c07fc986eba1e68a0f4a1f)
+++@@ -33,6 +33,8 @@
+++ 
+++ import androidx.annotation.NonNull;
+++ import androidx.annotation.Nullable;
++++import androidx.annotation.OptIn;
++++import androidx.media3.common.util.UnstableApi;
+++ 
+++ import com.google.android.exoplayer2.C;
+++ import com.google.android.exoplayer2.DefaultLoadControl;
+++@@ -74,6 +76,7 @@
+++ 
+++ import org.telegram.messenger.AndroidUtilities;
+++ import org.telegram.messenger.ApplicationLoader;
++++import org.telegram.messenger.ChromeCastController;
+++ import org.telegram.messenger.DispatchQueue;
+++ import org.telegram.messenger.FileLoader;
+++ import org.telegram.messenger.FileLog;
+++@@ -95,7 +98,6 @@
+++ import java.nio.ByteOrder;
+++ import java.util.ArrayList;
+++ import java.util.Arrays;
+++-import java.util.HashSet;
+++ import java.util.List;
+++ 
+++ @SuppressLint("NewApi")
+++@@ -316,8 +318,9 @@
+++         audioPlayer.prepare();
+++     }
+++ 
+++-    private MediaSource mediaSourceFromUri(Uri uri, String type) {
++++    @OptIn(markerClass = UnstableApi.class) private MediaSource mediaSourceFromUri(Uri uri, String type) {
+++         MediaItem mediaItem = new MediaItem.Builder().setUri(uri).build();
++++        ChromeCastController.getInstance().setItem(uri, type);
+++         switch (type) {
+++             case "dash":
+++                 if (dashMediaSourceFactory == null) {
+++Index: TMessagesProj/src/main/java/org/telegram/ui/LaunchActivity.java
+++IDEA additional info:
+++Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
+++<+>UTF-8
+++===================================================================
+++diff --git a/TMessagesProj/src/main/java/org/telegram/ui/LaunchActivity.java b/TMessagesProj/src/main/java/org/telegram/ui/LaunchActivity.java
+++--- a/TMessagesProj/src/main/java/org/telegram/ui/LaunchActivity.java	(revision cfc2e67ff72f1977751c13468162144efb393cbb)
++++++ b/TMessagesProj/src/main/java/org/telegram/ui/LaunchActivity.java	(revision 36b54fb5d4043a8b09c07fc986eba1e68a0f4a1f)
+++@@ -78,6 +78,7 @@
+++ import androidx.recyclerview.widget.LinearLayoutManager;
+++ import androidx.recyclerview.widget.RecyclerView;
+++ 
++++import com.google.android.gms.cast.framework.CastContext;
+++ import com.google.android.gms.common.api.Status;
+++ import com.google.common.primitives.Longs;
+++ import com.google.firebase.appindexing.Action;
+++Index: TMessagesProj/src/main/java/org/telegram/ui/PhotoViewer.java
+++IDEA additional info:
+++Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
+++<+>UTF-8
+++===================================================================
+++diff --git a/TMessagesProj/src/main/java/org/telegram/ui/PhotoViewer.java b/TMessagesProj/src/main/java/org/telegram/ui/PhotoViewer.java
+++--- a/TMessagesProj/src/main/java/org/telegram/ui/PhotoViewer.java	(revision cfc2e67ff72f1977751c13468162144efb393cbb)
++++++ b/TMessagesProj/src/main/java/org/telegram/ui/PhotoViewer.java	(revision 36b54fb5d4043a8b09c07fc986eba1e68a0f4a1f)
+++@@ -121,6 +121,7 @@
+++ import androidx.annotation.Keep;
+++ import androidx.annotation.NonNull;
+++ import androidx.annotation.Nullable;
++++import androidx.annotation.OptIn;
+++ import androidx.collection.ArrayMap;
+++ import androidx.collection.LongSparseArray;
+++ import androidx.core.content.ContextCompat;
+++@@ -133,6 +134,7 @@
+++ import androidx.dynamicanimation.animation.FloatValueHolder;
+++ import androidx.dynamicanimation.animation.SpringAnimation;
+++ import androidx.dynamicanimation.animation.SpringForce;
++++import androidx.mediarouter.app.MediaRouteButton;
+++ import androidx.recyclerview.widget.DefaultItemAnimator;
+++ import androidx.recyclerview.widget.LinearLayoutManager;
+++ import androidx.recyclerview.widget.LinearSmoothScrollerEnd;
+++@@ -142,6 +144,7 @@
+++ import com.google.android.exoplayer2.ExoPlayer;
+++ import com.google.android.exoplayer2.analytics.AnalyticsListener;
+++ import com.google.android.exoplayer2.ui.AspectRatioFrameLayout;
++++import com.google.android.gms.cast.framework.CastButtonFactory;
+++ import com.google.android.gms.vision.Frame;
+++ import com.google.android.gms.vision.face.Face;
+++ import com.google.android.gms.vision.face.FaceDetector;
+++@@ -155,6 +158,7 @@
+++ import org.telegram.messenger.BringAppForegroundService;
+++ import org.telegram.messenger.BuildVars;
+++ import org.telegram.messenger.ChatObject;
++++import org.telegram.messenger.ChromeCastController;
+++ import org.telegram.messenger.DialogObject;
+++ import org.telegram.messenger.DownloadController;
+++ import org.telegram.messenger.Emoji;
+++@@ -239,8 +243,8 @@
+++ import org.telegram.ui.Components.Paint.Views.LPhotoPaintView;
+++ import org.telegram.ui.Components.Paint.Views.MaskPaintView;
+++ import org.telegram.ui.Components.Paint.Views.StickerCutOutBtn;
+++-import org.telegram.ui.Components.Paint.Views.StickerMakerView;
+++ import org.telegram.ui.Components.Paint.Views.StickerMakerBackgroundView;
++++import org.telegram.ui.Components.Paint.Views.StickerMakerView;
+++ import org.telegram.ui.Components.PaintingOverlay;
+++ import org.telegram.ui.Components.PhotoCropView;
+++ import org.telegram.ui.Components.PhotoFilterView;
+++@@ -296,6 +300,7 @@
+++ 
+++ @SuppressLint("WrongConstant")
+++ @SuppressWarnings("unchecked")
++++@OptIn(markerClass = androidx.media3.common.util.UnstableApi.class)
+++ public class PhotoViewer implements NotificationCenter.NotificationCenterDelegate, GestureDetector2.OnGestureListener, GestureDetector2.OnDoubleTapListener {
+++     private final static float ZOOM_SCALE = 0.1f;
+++     private final static int MARK_DEFERRED_IMAGE_LOADING = 1;
+++@@ -8444,6 +8449,7 @@
+++                 view.setScaleY(1f);
+++             }
+++         }
++++        ChromeCastController.getInstance().release();
+++     }
+++ 
+++     private void onUserLeaveHint() {
+++@@ -9775,6 +9781,28 @@
+++             flashView.setAlpha(0.0f);
+++             aspectRatioFrameLayout.addView(flashView, LayoutHelper.createFrame(LayoutHelper.MATCH_PARENT, LayoutHelper.MATCH_PARENT, Gravity.CENTER));
+++         }
++++
++++        if (ChromeCastController.getInstance().isGooglePlayServicesAvailable) {
++++            try {
++++                MediaRouteButton castButton = new MediaRouteButton(parentActivity);
++++                castButton.setBackgroundColor(Color.YELLOW);
++++                CastButtonFactory.setUpMediaRouteButton(activityContext.getApplicationContext(), castButton);
++++                aspectRatioFrameLayout.addView(castButton, LayoutHelper.createFrame(LayoutHelper.WRAP_CONTENT, LayoutHelper.WRAP_CONTENT, Gravity.TOP | Gravity.RIGHT));
++++                ChromeCastController.getInstance().addVideoPlayerListener(new ChromeCastController.VideoPlayerPausePlay() {
++++                    @Override
++++                    public void pause() {
++++                        pauseVideoOrWeb();
++++                    }
++++
++++                    @Override
++++                    public void play() {
++++                        playVideoOrWeb();
++++                    }
++++                });
++++            } catch (Exception exception) {
++++
++++            }
++++        }
+++     }
+++ 
+++     private void releasePlayer(boolean onClose) {
+++Index: TMessagesProj/src/main/java/org/telegram/ui/Cells/ChatMessageCell.java
+++IDEA additional info:
+++Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
+++<+>UTF-8
+++===================================================================
+++diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Cells/ChatMessageCell.java b/TMessagesProj/src/main/java/org/telegram/ui/Cells/ChatMessageCell.java
+++--- a/TMessagesProj/src/main/java/org/telegram/ui/Cells/ChatMessageCell.java	(revision 428164c193d20737d82612eb41af602cec0d6891)
++++++ b/TMessagesProj/src/main/java/org/telegram/ui/Cells/ChatMessageCell.java	(revision 4dd25c6d55abac9dedb0b31d1d70e9c456e044c9)
+++@@ -191,6 +191,7 @@
+++ import org.telegram.ui.Components.spoilers.SpoilerEffect;
+++ import org.telegram.ui.Components.spoilers.SpoilerEffect2;
+++ import org.telegram.ui.GradientClip;
++++import org.telegram.ui.MetaballDrawable;
+++ import org.telegram.ui.PhotoViewer;
+++ import org.telegram.ui.PinchToZoomHelper;
+++ import org.telegram.ui.SecretMediaViewer;
+++@@ -224,6 +225,7 @@
+++     public boolean shouldCheckVisibleOnScreen;
+++     public float parentBoundsTop;
+++     public int parentBoundsBottom;
++++    private MetaballDrawable popup;
+++ 
+++     public ExpiredStoryView expiredStoryView;
+++     private boolean skipFrameUpdate;
+++@@ -1263,6 +1265,7 @@
+++     public boolean isRepliesChat;
+++     public boolean isPinnedChat;
+++     private boolean isPressed;
++++    private boolean isPopupPressed;
+++     private boolean forwardName;
+++     private boolean isHighlighted;
+++     private boolean isHighlightedAnimated;
+++@@ -1372,17 +1375,19 @@
+++     private boolean drawTopic;
+++     private MessageTopicButton topicButton;
+++ 
+++-    private int drawSideButton;
++++    public int drawSideButton;
+++     private boolean sideButtonVisible;
+++     private int drawSideButton2;
+++     private boolean sideButtonPressed;
++++    public boolean showSideButton1240;
++++    private boolean sideButtonLongPressed;
+++     private int pressedSideButton;
+++     private Path sideButtonPath1, sideButtonPath2;
+++     private float[] sideButtonPathCorners1, sideButtonPathCorners2;
+++     private static final int SIDE_BUTTON_SPONSORED_CLOSE = 4;
+++     private static final int SIDE_BUTTON_SPONSORED_MORE = 5;
+++-    private float sideStartX;
+++-    private float sideStartY;
++++    public float sideStartX;
++++    public float sideStartY;
+++ 
+++     private StaticLayout nameLayout;
+++     private int nameLayoutWidth;
+++@@ -3887,6 +3892,10 @@
+++ 
+++     @Override
+++     public boolean onTouchEvent(MotionEvent event) {
++++//        if (checkPopupEvent(event)) {
++++//            return true;
++++//        }
++++
+++         if (currentMessageObject == null || delegate != null && !delegate.canPerformActions() || animationRunning) {
+++             if (currentMessageObject != null && currentMessageObject.preview) {
+++                 return checkTextSelection(event);
+++@@ -4417,6 +4426,46 @@
+++         return pinchToZoomHelper.checkPinchToZoom(ev, this, photoImage, null, null, currentMessageObject, mediaSpoilerEffect2 == null ? 0 : mediaSpoilerEffect2.getAttachIndex(this));
+++     }
+++ 
++++//    Runnable cancelLongPressRunnable;
++++
++++//    private boolean checkPopupEvent(MotionEvent event) {
++++////        if (sideButtonPressed) {
++++//            //  && (event.getAction() != MotionEvent.ACTION_UP || event.getAction() != MotionEvent.ACTION_CANCEL)
++++////            cancelCheckLongPress();
++++////            sideButtonLongPressed = true;
++++////            cancelLongPress();
++++////            if (cancelLongPressRunnable == null) {
++++////                cancelLongPressRunnable = () -> {
++++////                    cancelCheckLongPress();
++++////                    sideButtonLongPressed = true;
++++////                };
++++////                postDelayed(cancelLongPressRunnable, ViewConfiguration.getLongPressTimeout() - ViewConfiguration.getTapTimeout() - 50);
++++////            }
++++////        } else {
++++////            removeCallbacks(cancelLongPressRunnable);
++++////            cancelLongPressRunnable = null;
++++////        }
++++//        if (sideButtonLongPressed && popup == null) {
++++//            popup = new MetaballDrawable();
++++//            final int scx = (int) (sideStartX - AndroidUtilities.dp(200)), scy = (int) (sideStartY - AndroidUtilities.dp(200));
++++//            final int width = popup.getIntrinsicWidth() > 0 ? popup.getIntrinsicWidth() : AndroidUtilities.dp(200);
++++//            final int height = popup.getIntrinsicHeight() > 0 ? popup.getIntrinsicHeight() : AndroidUtilities.dp(200);
++++//
++++//            final int shw = width / 2;
++++//            final int shh = height / 2;
++++//
++++//            popup.setBounds(scx - shw, scy - shh, scx + shw, scy + shh);
++++//            setDrawableBounds(popup, sideStartX + AndroidUtilities.dp(4), sideStartY + AndroidUtilities.dp(4));
++++//        }
++++//        if (popup != null) {
++++//            boolean result = popup.onTouch(event);
++++//            if (!result) popup = null;
++++//            isPopupPressed = result;
++++//            return result;
++++//        }
++++//        return false;
++++//    }
++++
+++     private boolean checkTextSelection(MotionEvent event) {
+++         if (delegate == null) return false;
+++         TextSelectionHelper.ChatListTextSelectionHelper textSelectionHelper = delegate.getTextSelectionHelper();
+++@@ -18309,7 +18358,7 @@
+++     }
+++ 
+++     private void drawSideButton(Canvas canvas) {
+++-        if (drawSideButton != 0) {
++++        if (drawSideButton != 0 && !showSideButton1240) {
+++             if (currentPosition != null && currentMessagesGroup != null && currentMessagesGroup.isDocuments && !currentPosition.last) {
+++                 return;
+++             }
+++@@ -24344,7 +24393,7 @@
+++                     changed = true;
+++                 }
+++             }
+++-            
++++
+++             if (mediaOffsetY != lastMediaOffsetY) {
+++                 animateFromMediaOffsetY = lastMediaOffsetY;
+++                 animateMediaOffsetY = true;
+++Index: TMessagesProj/src/main/java/org/telegram/ui/ChatActivity.java
+++IDEA additional info:
+++Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
+++<+>UTF-8
+++===================================================================
+++diff --git a/TMessagesProj/src/main/java/org/telegram/ui/ChatActivity.java b/TMessagesProj/src/main/java/org/telegram/ui/ChatActivity.java
+++--- a/TMessagesProj/src/main/java/org/telegram/ui/ChatActivity.java	(revision 428164c193d20737d82612eb41af602cec0d6891)
++++++ b/TMessagesProj/src/main/java/org/telegram/ui/ChatActivity.java	(revision 6a6412936ea08e51fa4b6f8ed657e0142be0fe75)
+++@@ -76,7 +76,6 @@
+++ import android.text.style.ForegroundColorSpan;
+++ import android.text.style.ImageSpan;
+++ import android.text.style.URLSpan;
+++-import android.util.Log;
+++ import android.util.Pair;
+++ import android.util.Property;
+++ import android.util.SparseArray;
+++@@ -265,7 +264,6 @@
+++ import java.io.FileWriter;
+++ import java.io.InputStream;
+++ import java.io.InputStreamReader;
+++-import java.net.IDN;
+++ import java.net.URLDecoder;
+++ import java.util.ArrayList;
+++ import java.util.Arrays;
+++@@ -368,6 +366,7 @@
+++     private QuickRepliesEmptyView quickRepliesEmptyView;
+++     private BusinessLinksEmptyView businessLinksEmptyView;
+++     public ChatActivityFragmentView contentView;
++++    public MetaballViewFINAL popupView;
+++     private ChatBigEmptyView bigEmptyView;
+++     private ArrayList<View> actionModeViews = new ArrayList<>();
+++     private ChatAvatarContainer avatarContainer;
+++@@ -4430,6 +4429,11 @@
+++             }
+++ 
+++             private void processTouchEvent(MotionEvent e) {
++++                if (popupView != null) {
++++                    if (popupView.onTouchEvent(e)) {
++++                        return;
++++                    }
++++                }
+++                 if (e != null) {
+++                     wasManualScroll = true;
+++                 }
+++@@ -5421,6 +5425,7 @@
+++                         canvas.save();
+++                         canvas.translate(cell.getX(), cell.getY());
+++                         cell.drawOutboundsContent(canvas);
++++
+++                         canvas.restore();
+++                     } else if (actionCell != null) {
+++                         canvas.save();
+++@@ -16090,6 +16095,10 @@
+++ 
+++         @Override
+++         public boolean dispatchTouchEvent(MotionEvent ev) {
++++            if (popupView != null && (ev.getAction() == MotionEvent.ACTION_MOVE || ev.getAction() == MotionEvent.ACTION_CANCEL)) {
++++                popupView.onTouchEvent(ev);
++++                return true;
++++            }
+++             float expandY;
+++             if (AndroidUtilities.isInMultiwindow || isInBubbleMode()) {
+++                 expandY = chatActivityEnterView.getEmojiView() != null ? chatActivityEnterView.getEmojiView().getY() : chatActivityEnterView.getY();
+++@@ -36230,8 +36239,54 @@
+++ 
+++         @Override
+++         public void didLongPress(ChatMessageCell cell, float x, float y) {
+++-            createMenu(cell, false, false, x, y, false);
+++-            startMultiselect(chatListView.getChildAdapterPosition(cell));
++++            if (cell.drawSideButton == 1 && x >= cell.sideStartX) {
++++                if (popupView != null) {
++++                    contentView.removeView(popupView);
++++                }
++++                int defaultColor = Theme.blendOver(cell.getThemedColor(Theme.key_chat_inBubble), Theme.multAlpha(cell.getThemedColor(Theme.key_windowBackgroundWhiteGrayText), .85f));
++++                popupView = new MetaballViewFINAL(getContext(), getThemedDrawable(Theme.key_drawable_shareIcon), ChatActivity.this, defaultColor) {
++++                    @Override
++++                    protected void onSend(TLRPC.Dialog did, int count, TLRPC.TL_forumTopic topic) {
++++                        createUndoView();
++++                        if (undoView == null) {
++++                            return;
++++                        }
++++                        if (did.id != getUserConfig().getClientUserId() || !BulletinFactory.of(ChatActivity.this).showForwardedBulletinWithTag(did.id, count)) {
++++                            undoView.showWithAction(did.id, UndoView.ACTION_FWD_MESSAGES, count, topic, null, null);
++++                        }
++++                    }
++++
++++                    @Override
++++                    protected void onAnimationFinished() {
++++                        cell.showSideButton1240 = false;
++++                        cell.invalidateOutbounds();
++++                    }
++++
++++                    @Override
++++                    protected void onCollapseAnimationFinished() {
++++                        contentView.removeView(popupView);
++++                        popupView = null;
++++                    }
++++                };
++++                ArrayList<MessageObject> arrayList = null;
++++                MessageObject messageObject = cell.getMessageObject();
++++                if (messageObject.getGroupId() != 0) {
++++                    MessageObject.GroupedMessages groupedMessages = groupedMessagesMap.get(messageObject.getGroupId());
++++                    if (groupedMessages != null) {
++++                        arrayList = groupedMessages.messages;
++++                    }
++++                }
++++                if (arrayList == null) {
++++                    arrayList = new ArrayList<>();
++++                    arrayList.add(messageObject);
++++                }
++++                popupView.init(cell.sideStartX, cell.getY(), cell.getHeight(), cell.sideStartY, arrayList);
++++                contentView.addView(popupView);
++++                cell.showSideButton1240 = true;
++++            } else {
++++                createMenu(cell, false, false, x, y, false);
++++                startMultiselect(chatListView.getChildAdapterPosition(cell));
++++            }
+++         }
+++ 
+++         @Override
+++Index: TMessagesProj/src/main/java/org/telegram/ui/MetaballDrawable.java
+++IDEA additional info:
+++Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
+++<+>UTF-8
+++===================================================================
+++diff --git a/TMessagesProj/src/main/java/org/telegram/ui/MetaballDrawable.java b/TMessagesProj/src/main/java/org/telegram/ui/MetaballDrawable.java
+++new file mode 100644
+++--- /dev/null	(revision e1d4a34f5eb5af248ba9f6c702f6612841941cde)
++++++ b/TMessagesProj/src/main/java/org/telegram/ui/MetaballDrawable.java	(revision e1d4a34f5eb5af248ba9f6c702f6612841941cde)
+++@@ -0,0 +1,309 @@
++++package org.telegram.ui;
++++
++++import android.animation.ValueAnimator;
++++import android.graphics.Bitmap;
++++import android.graphics.Canvas;
++++import android.graphics.Color;
++++import android.graphics.ColorFilter;
++++import android.graphics.Paint;
++++import android.graphics.PixelFormat;
++++import android.graphics.RadialGradient;
++++import android.graphics.Rect;
++++import android.graphics.RectF;
++++import android.graphics.Shader;
++++import android.graphics.drawable.Drawable;
++++import android.text.TextPaint;
++++import android.view.MotionEvent;
++++
++++import org.telegram.messenger.AndroidUtilities;
++++
++++public class MetaballDrawable extends Drawable {
++++
++++    private Paint circlePaint;
++++    private Paint rectPaint;
++++    private Paint popupPaint;
++++    private Paint gradientPaint;
++++    private Bitmap bitmap;
++++    private Canvas tempCanvas;
++++    private int w, h;
++++    private final int THRESHOLD = 210;
++++
++++    private float circleX, circleY, circleSize;
++++    private float popupX, popupY, popupSize;
++++
++++    private TextPaint debugTextPaint;
++++
++++    public MetaballDrawable() {
++++        init();
++++    }
++++
++++    private void init() {
++++        // Initialize parameters
++++        circlePaint = new Paint(Paint.ANTI_ALIAS_FLAG);
++++        circlePaint.setColor(0xFF00FF00);
++++        popupPaint = new Paint(Paint.ANTI_ALIAS_FLAG);
++++        popupPaint.setColor(Color.RED);
++++        rectPaint = new Paint(Paint.ANTI_ALIAS_FLAG);
++++        rectPaint.setColor(0xFFFF0000);
++++        gradientPaint = new Paint(Paint.ANTI_ALIAS_FLAG);
++++        circleSize = dpToPx(20f);
++++        popupSize = dpToPx(40f);
++++        circleX = dpToPx(120);
++++        circleY = dpToPx(80);
++++        popupX = circleX;
++++        popupY = circleY - dpToPx(50);
++++
++++        // Bitmap and canvas setup will be done later in onBoundsChange()
++++        debugTextPaint = new TextPaint();
++++        debugTextPaint.setColor(Color.YELLOW); // Цвет текста, можно изменить
++++        debugTextPaint.setAntiAlias(true);
++++        debugTextPaint.setTextSize(dpToPx(14f)); // Размер текста, можно изменить
++++        debugTextPaint.setTextAlign(Paint.Align.LEFT); // Выравнивание текста
++++    }
++++
++++    @Override
++++    public int getIntrinsicWidth() {
++++        return (int) dpToPx(200);
++++    }
++++
++++    @Override
++++    public int getIntrinsicHeight() {
++++        return (int) dpToPx(100);
++++    }
++++
++++    @Override
++++    protected void onBoundsChange(Rect bounds) {
++++        super.onBoundsChange(bounds);
++++
++++        // Get drawable dimensions
++++        w = bounds.width();
++++        h = bounds.height();
++++
++++        // Initialize the bitmap and canvas for off-screen drawing
++++        if (w > 0 && h > 0) {
++++            bitmap = Bitmap.createBitmap(w, h, Bitmap.Config.ARGB_8888);
++++            tempCanvas = new Canvas(bitmap);
++++        }
++++    }
++++
++++    @Override
++++    public void draw(Canvas canvas) {
++++        animationProgress += 0.01f;
++++        if (animationProgress >= 1f) {
++++            animationProgress = 0.01f;
++++        }
++++        // Clear the temporary canvas
++++//        canvas.drawColor(Color.WHITE);
++++
++++        bitmap.eraseColor(0);
++++
++++        // Draw the static circle with radial gradient
++++        drawCircle1(tempCanvas, circleX, circleY, circleSize);
++++        drawCircle2(tempCanvas, circleX, circleY, circleSize);
++++        drawRoundedRect(tempCanvas, circleX, circleY, circleSize);
++++
++++        // Manipulate pixels to simulate the thresholding effect
++++        applyThreshold();
++++
++++        // Draw the bitmap (containing the metaballs) onto the main canvas
++++        canvas.drawBitmap(bitmap, 0, 0, gradientPaint);
++++
++++//        drawDebugInfo(canvas);
++++        invalidateSelf();
++++    }
++++
++++    private void drawCircle1(Canvas canvas, float x, float y, float size) {
++++        // Draw circle with radial gradient
++++        float offset1 = dpToPx(20f);
++++        float offset2 = dpToPx(28f);
++++        float offset3 = dpToPx(8f);
++++        float newY;
++++
++++        if (animationProgress <= 0.5f) {
++++            // Первые 50% анимации - подъем на 20dp
++++            newY = y - animationProgress * 2 * offset1;
++++        } else if (animationProgress <= 0.9f) {
++++            // Следующие 40% анимации - опускание на 28dp
++++            float progress = (animationProgress - 0.5f) / 0.4f; // Нормализация прогресса от 0.5 до 0.9
++++            newY = y - offset1 + progress * offset2;
++++        } else {
++++            // Последние 10% анимации - подъем на 8dp
++++            float progress = (animationProgress - 0.9f) / 0.1f; // Нормализация прогресса от 0.9 до 1.0
++++            newY = y - offset1 + offset2 - progress * offset3;
++++        }
++++
++++        // Создаем градиент для круга
++++        RadialGradient gradient = new RadialGradient(
++++                x, newY, size / 1.2f,
++++                new int[]{0xFF00FF00, 0x00000000},
++++                new float[]{0.5f, 1.0f}, // Make the transition sharper
++++                Shader.TileMode.CLAMP
++++        );
++++        circlePaint.setShader(gradient);
++++
++++        // Рисуем круг
++++        canvas.drawCircle(x, newY, size, circlePaint);
++++    }
++++
++++    public void setCircleCenter(float x, float y) {
++++        circleX = x;
++++        circleY = y - dpToPx(25);
++++        popupX = circleX;
++++        popupY = circleY - dpToPx(50);
++++        invalidateSelf();
++++    }
++++
++++    private void drawCircle2(Canvas canvas, float x, float y, float size) {
++++        float currentAnimationBorder = 0.5f; // Порог для первой части анимации
++++        float currentAnimationProgress = Math.min(animationProgress / currentAnimationBorder, 1);
++++
++++        float newY, newX, newSize;
++++        float xOffset = dpToPx(0);
++++        newX = x - xOffset;
++++        newY = y - Math.abs(y - popupY) * currentAnimationProgress;
++++        newSize = size + Math.abs(size - popupSize) * currentAnimationProgress;
++++
++++        // После 50% анимации уменьшаем размер круга на 10dp
++++        if (animationProgress > 0.4f) {
++++            float additionalProgress = Math.abs((animationProgress - 0.4f)) / 0.6f; // Нормализуем прогресс от 0.5 до 1.0
++++            float sizeDecrease = dpToPx(40f);
++++            newSize -= sizeDecrease * additionalProgress; // Уменьшаем размер на 10dp
++++        }
++++
++++        // Создаем градиент для круга
++++        RadialGradient gradient = new RadialGradient(
++++                newX, newY, Math.max(newSize, 0.001f),
++++                new int[]{0xFFFF0000, 0x00000000}, // Переход от красного к прозрачному
++++                new float[]{0.5f, 1.0f}, // Сохраняем резкий переход
++++                Shader.TileMode.CLAMP
++++        );
++++        gradientPaint.setShader(gradient);
++++
++++        // Рисуем круг
++++        canvas.drawCircle(newX, newY, Math.max(newSize, 0.001f), gradientPaint);
++++    }
++++
++++    private void drawRoundedRect(Canvas canvas, float x, float y, float size) {
++++        float targetWidth = popupSize * 6;
++++        float currentAnimationExpandBorder = 0.4f; // Replace with your actual animation progress
++++        float currentAnimationBorder = 0.5f; // Replace with your actual animation progress
++++        float currentAnimationProgress = Math.min(animationProgress / currentAnimationBorder, 1);
++++        float offset = 0;
++++
++++        float newY, newX, newSize;
++++        float xOffset = dpToPx(0);
++++        newX = x - xOffset;
++++        newY = y - Math.abs(y - popupY) * currentAnimationProgress;
++++        newSize = size + Math.abs(size - popupSize) * currentAnimationProgress;
++++
++++        float rectWidth = newSize;
++++        // Draw rounded rectangle with radial gradient
++++        if (animationProgress > currentAnimationExpandBorder) {
++++            rectWidth = popupSize + (targetWidth - popupSize) * (animationProgress - currentAnimationExpandBorder);
++++            offset = dpToPx(40f) * (animationProgress - currentAnimationExpandBorder);
++++        }
++++        float rectHeight = newSize;
++++        float cornerRadius = dpToPx(500f);
++++
++++        // Define the rectangle bounds
++++        RectF rect = new RectF(
++++                newX - rectWidth / 2 - offset,
++++                newY - rectHeight / 2 - dpToPx(4),
++++                newX + rectWidth / 2 - offset,
++++                newY + rectHeight / 2 - dpToPx(4)
++++        );
++++
++++        // Draw the rounded rectangle
++++        canvas.drawRoundRect(rect, cornerRadius, cornerRadius, popupPaint);
++++    }
++++
++++    private void applyThreshold() {
++++        int[] pixels = new int[w * h];
++++        bitmap.getPixels(pixels, 0, w, 0, 0, w, h);
++++
++++        for (int i = 0; i < pixels.length; i++) {
++++            int alpha = (pixels[i] >> 24) & 0xff; // Extract alpha channel
++++            if (alpha < THRESHOLD) {
++++                pixels[i] = 0x01000000; // Apply threshold effect
++++            }
++++        }
++++
++++        // Update bitmap with modified pixels
++++        bitmap.setPixels(pixels, 0, w, 0, 0, w, h);
++++    }
++++
++++    private float animationProgress = 0f;
++++    private ValueAnimator animator;
++++
++++//    public void startAnimation() {
++++//        animator = ValueAnimator.ofFloat(0f, 1f);
++++//        animator.setDuration(700); // Adjust as needed
++++//        animator.setInterpolator(new LinearInterpolator());
++++//
++++//        animator.addUpdateListener(animation -> {
++++//            animationProgress = (float) animation.getAnimatedValue();
++++//            invalidateSelf();
++++//        });
++++//
++++//        animator.addListener(new AnimatorListenerAdapter() {
++++//            @Override
++++//            public void onAnimationEnd(Animator animation) {
++++//                animationProgress = 1f;
++++//                invalidateSelf();
++++//            }
++++//        });
++++//
++++//        animator.start();
++++//    }
++++
++++    private float dpToPx(float dp) {
++++        return AndroidUtilities.dp(dp);
++++    }
++++
++++    private void drawDebugInfo(Canvas canvas) {
++++        // Позиция текста на экране (левый верхний угол)
++++        float x = dpToPx(10f); // Отступ от левого края
++++        float y = dpToPx(70f); // Отступ от верхнего края
++++
++++        // Формирование строки с информацией о прогрессе
++++        String debugText = String.format("%.2f", animationProgress);
++++
++++        // Разбиваем текст на строки (если используем переносы строк)
++++        String[] lines = debugText.split("\n");
++++
++++        // Отрисовываем каждую строку текста
++++        for (String line : lines) {
++++            canvas.drawText(line, x, y, debugTextPaint);
++++            y += debugTextPaint.getTextSize() + dpToPx(4f); // Переходим на следующую строку с отступом
++++        }
++++    }
++++
++++    @Override
++++    public void setAlpha(int alpha) {
++++        // Set the alpha for the drawable
++++    }
++++
++++    @Override
++++    public void setColorFilter(ColorFilter colorFilter) {
++++        // Set the color filter for the drawable
++++    }
++++
++++    @Override
++++    public int getOpacity() {
++++        return PixelFormat.TRANSLUCENT;
++++    }
++++
++++    public boolean onTouch(MotionEvent event) {
++++        switch (event.getAction()) {
++++            case MotionEvent.ACTION_DOWN:
++++                return true;
++++            case MotionEvent.ACTION_MOVE:
++++                return true;
++++            case MotionEvent.ACTION_UP:
++++                return false;
++++            case MotionEvent.ACTION_CANCEL:
++++                return false; // !лайфках, телега сама посылает cancel если сработает long;
++++        }
++++        return false;
++++    }
++++}
+++Index: TMessagesProj/src/main/java/org/telegram/ui/MetaballViewFINAL.java
+++IDEA additional info:
+++Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
+++<+>UTF-8
+++===================================================================
+++diff --git a/TMessagesProj/src/main/java/org/telegram/ui/MetaballViewFINAL.java b/TMessagesProj/src/main/java/org/telegram/ui/MetaballViewFINAL.java
+++new file mode 100644
+++--- /dev/null	(revision 874d55edbe2a2f018623a8cad64f8961783398d8)
++++++ b/TMessagesProj/src/main/java/org/telegram/ui/MetaballViewFINAL.java	(revision 874d55edbe2a2f018623a8cad64f8961783398d8)
+++@@ -0,0 +1,858 @@
++++package org.telegram.ui;
++++
++++import android.animation.Animator;
++++import android.animation.AnimatorListenerAdapter;
++++import android.animation.ValueAnimator;
++++import android.content.Context;
++++import android.graphics.Bitmap;
++++import android.graphics.BlurMaskFilter;
++++import android.graphics.Canvas;
++++import android.graphics.Color;
++++import android.graphics.Paint;
++++import android.graphics.RadialGradient;
++++import android.graphics.Rect;
++++import android.graphics.RectF;
++++import android.graphics.Shader;
++++import android.graphics.drawable.BitmapDrawable;
++++import android.graphics.drawable.Drawable;
++++import android.text.TextPaint;
++++import android.text.TextUtils;
++++import android.util.Log;
++++import android.util.Pair;
++++import android.view.Choreographer;
++++import android.view.MotionEvent;
++++import android.view.View;
++++import android.view.animation.LinearInterpolator;
++++
++++import androidx.collection.LongSparseArray;
++++import androidx.core.graphics.ColorUtils;
++++
++++import org.telegram.messenger.AndroidUtilities;
++++import org.telegram.messenger.ChatObject;
++++import org.telegram.messenger.DialogObject;
++++import org.telegram.messenger.FileLog;
++++import org.telegram.messenger.ImageReceiver;
++++import org.telegram.messenger.LocaleController;
++++import org.telegram.messenger.MessageObject;
++++import org.telegram.messenger.MessagesController;
++++import org.telegram.messenger.R;
++++import org.telegram.messenger.SendMessagesHelper;
++++import org.telegram.messenger.UserConfig;
++++import org.telegram.messenger.UserObject;
++++import org.telegram.messenger.Utilities;
++++import org.telegram.tgnet.TLRPC;
++++import org.telegram.ui.ActionBar.Theme;
++++import org.telegram.ui.Components.AlertsCreator;
++++import org.telegram.ui.Components.AvatarDrawable;
++++import org.telegram.ui.Components.StaticLayoutEx;
++++
++++import java.util.ArrayList;
++++import java.util.List;
++++
++++public class MetaballViewFINAL extends View {
++++
++++    private final ChatActivity chatActivity;
++++    private int currentAccount = UserConfig.selectedAccount;
++++    private final Drawable drawable;
++++    private Paint circlePaint;
++++    private Paint rectPaint;
++++    private Paint popupPaint;
++++    private Paint gradientPaint;
++++    private Paint avatarPaint;
++++    private Paint tooltipPaint;
++++    private TextPaint textPaint;
++++
++++    private Bitmap bitmap;
++++    private Canvas tempCanvas;
++++    private int w, h;
++++    private final int THRESHOLD = 210;
++++
++++    private float circleX, circleY, circleSize;
++++    private float popupX, popupY, popupSize;
++++
++++    private float targetWidth;
++++    private int circleColor = 0xFF646464;
++++    private int rectColor = 0xFFFFFFFF;
++++    private final int defaultAvatarColor;
++++    private Paint shadowPaint;
++++    protected ArrayList<MessageObject> sendingMessageObjects;
++++
++++    public MetaballViewFINAL(Context context, Drawable drawable, ChatActivity chatActivity, int defaultAvatarColor) {
++++        super(context);
++++        this.drawable = drawable;
++++        this.defaultAvatarColor = defaultAvatarColor;
++++        this.chatActivity = chatActivity;
++++        init();
++++    }
++++
++++    private void init() {
++++        choreographer = Choreographer.getInstance();
++++        circlePaint = new Paint(Paint.ANTI_ALIAS_FLAG);
++++        circlePaint.setColor(circleColor);
++++        popupPaint = new Paint(Paint.ANTI_ALIAS_FLAG);
++++        popupPaint.setColor(rectColor);
++++
++++        shadowPaint = new Paint(Paint.ANTI_ALIAS_FLAG);
++++        shadowPaint.setColor(Color.BLACK);
++++        shadowPaint.setStyle(Paint.Style.FILL);
++++        shadowPaint.setMaskFilter(new BlurMaskFilter(dpToPx(4f), BlurMaskFilter.Blur.NORMAL));
++++
++++        rectPaint = new Paint(Paint.ANTI_ALIAS_FLAG);
++++        rectPaint.setColor(rectColor);
++++        gradientPaint = new Paint(Paint.ANTI_ALIAS_FLAG);
++++        avatarPaint = new Paint(Paint.ANTI_ALIAS_FLAG);
++++        avatarPaint.setColor(Color.BLUE);
++++        circleSize = dpToPx(32f);
++++        popupSize = dpToPx(58f);
++++        targetWidth = popupSize * 6;
++++
++++        tooltipPaint = new Paint(Paint.ANTI_ALIAS_FLAG);
++++        tooltipPaint.setColor(Color.parseColor("#80000000"));
++++        tooltipPaint.setStyle(Paint.Style.FILL);
++++
++++        textPaint = new TextPaint(Paint.ANTI_ALIAS_FLAG);
++++        textPaint.setColor(Color.WHITE);
++++        textPaint.setTextSize(dpToPx(11));
++++        textPaint.setTypeface(AndroidUtilities.bold());
++++        textPaint.setTextAlign(Paint.Align.CENTER);
++++    }
++++
++++    float minY, maxY;
++++    float drawingAreaTop;
++++    float drawingAreaBottom;
++++    float drawingAreaHeight;
++++
++++    private void calculateDrawingArea() {
++++
++++        float circle1UpwardMovement = dpToPx(12f) * 2;
++++        float circle1DownwardMovement = dpToPx(18f) + dpToPx(6f);
++++
++++        float circle1MinY = circleY - circle1UpwardMovement;
++++        float circle1MaxY = circleY + circle1DownwardMovement;
++++
++++        float popupMinY = popupY - dpToPx(0);
++++        float popupMaxY = popupY + popupSize;
++++
++++        minY = Math.min(circle1MinY, popupMinY);
++++        maxY = Math.max(circle1MaxY, popupMaxY);
++++
++++        float padding = dpToPx(1f);
++++        minY -= padding + dpToPx(40f);
++++        maxY += padding;
++++
++++        drawingAreaTop = minY;
++++        drawingAreaBottom = maxY;
++++        drawingAreaHeight = drawingAreaBottom - drawingAreaTop;
++++    }
++++
++++
++++    @Override
++++    protected void onSizeChanged(int width, int height, int oldWidth, int oldHeight) {
++++        super.onSizeChanged(width, height, oldWidth, oldHeight);
++++
++++        // Get view dimensions
++++        w = width;
++++        h = height;
++++
++++        drawingAreaTop = minY;
++++        drawingAreaBottom = maxY;
++++        drawingAreaHeight = drawingAreaBottom - drawingAreaTop;
++++
++++        bitmap = Bitmap.createBitmap(w, (int) drawingAreaHeight, Bitmap.Config.ARGB_8888);
++++        tempCanvas = new Canvas(bitmap);
++++    }
++++
++++    @Override
++++    protected void onDraw(Canvas canvas) {
++++        super.onDraw(canvas);
++++        calculateColors();
++++        setAlpha(1f - collapseAnimationProgress);
++++        bitmap.eraseColor(0);
++++
++++        tempCanvas.save();
++++        tempCanvas.translate(0, -drawingAreaTop);
++++
++++        if (animationProgress < 1f) {
++++            drawCircle1(tempCanvas, circleX, circleY, circleSize);
++++        }
++++//        if (animationProgress <= ANIMATION_BORDER_1) {
++++        drawCircle2(tempCanvas, circleX, circleY, circleSize);
++++//        }
++++        drawRoundedRect(tempCanvas, circleX, circleY, circleSize, canvas);
++++
++++        tempCanvas.restore();
++++
++++        applyThreshold();
++++
++++        canvas.drawBitmap(bitmap, 0, drawingAreaTop, gradientPaint);
++++
++++    }
++++
++++    private void calculateColors() {
++++        if (!colorsSet) {
++++            for (int i = 0; i < imageReceivers.length; i++) {
++++                ImageReceiver imageReceiver = imageReceivers[i];
++++                if (imageReceiver.getStaticThumb() instanceof BitmapDrawable) {
++++                    final Bitmap bitmap = ((BitmapDrawable) imageReceiver.getStaticThumb()).getBitmap();
++++                    try {
++++                        final int bitmapColor = bitmap.getPixel(bitmap.getWidth() / 2, bitmap.getHeight() - 2);
++++                        float[] hsl = new float[3];
++++                        ColorUtils.colorToHSL(bitmapColor, hsl);
++++                        if (hsl[1] <= .05f || hsl[1] >= .95f || hsl[2] <= .02f || hsl[2] >= .98f) {
++++                            hsl[1] = 0;
++++                            hsl[2] = Theme.isCurrentThemeDark() ? .38f : .70f;
++++                        } else {
++++                            hsl[1] = .25f;
++++                            hsl[2] = Theme.isCurrentThemeDark() ? .35f : .65f;
++++                        }
++++                        colors[i] = ColorUtils.HSLToColor(hsl);
++++                    } catch (Exception e) {
++++                        FileLog.e(e);
++++                    }
++++                } else if (!colorsSet && !colorSetFromThumb) {
++++                    try {
++++                        final int color = ColorUtils.blendARGB(((AvatarDrawable) imageReceiver.getStaticThumb()).getColor(), ((AvatarDrawable) imageReceiver.getStaticThumb()).getColor2(), .5f);
++++                        float[] hsl = new float[3];
++++                        ColorUtils.colorToHSL(color, hsl);
++++                        if (hsl[1] <= .05f || hsl[1] >= .95f) {
++++                            hsl[2] = Utilities.clamp(hsl[2] - .1f, .6f, .3f);
++++                        } else {
++++                            hsl[1] = Utilities.clamp(hsl[1] - .06f, .4f, 0);
++++                            hsl[2] = Utilities.clamp(hsl[2] - .08f, .5f, .2f);
++++                        }
++++                        colors[i] = ColorUtils.HSLToColor(hsl);
++++                    } catch (Exception e) {
++++                        FileLog.e(e);
++++                    }
++++                    colorSetFromThumb = true;
++++                } else {
++++                    colors[i] = defaultAvatarColor;
++++                }
++++            }
++++        }
++++        colorsSet = true;
++++    }
++++
++++    private void drawCircle1(Canvas canvas, float x, float y, float size) {
++++        float offset1 = dpToPx(12f);
++++        float offset2 = dpToPx(18f);
++++        float offset3 = dpToPx(6f);
++++        float newY;
++++
++++        float alfaProgress = 0f;
++++
++++        if (animationProgress > 0.7f) {
++++            alfaProgress = (animationProgress - 0.7f) / 0.3f;
++++        }
++++
++++        if (animationProgress <= 0.5f) {
++++            newY = y - animationProgress * 2 * offset1;
++++        } else if (animationProgress <= 0.9f) {
++++            float progress = (animationProgress - 0.5f) / 0.4f;
++++            newY = y - offset1 + progress * offset2;
++++        } else {
++++            float progress = (animationProgress - 0.9f) / 0.1f;
++++            newY = y - offset1 + offset2 - progress * offset3;
++++        }
++++
++++//        circlePaint.setAlpha((int) (1 - alfaProgress) * 255);
++++//        if (alfaProgress <= 0) {
++++        RadialGradient gradient = new RadialGradient(
++++                x, newY, size / 1.2f,
++++                new int[]{circleColor, 0x00000000},
++++                new float[]{0.5f, 1.0f},
++++                Shader.TileMode.CLAMP
++++        );
++++        circlePaint.setShader(gradient);
++++//        }
++++
++++        canvas.drawCircle(x, newY, size, circlePaint);
++++        drawAnimatedIcon(canvas, x, newY, size);
++++    }
++++
++++    private void drawAnimatedIcon(Canvas canvas, float circleX, float circleY, float circleSize) {
++++        if (drawable == null) {
++++            return;
++++        }
++++
++++        float iconSize = dpToPx(24f);
++++        float halfIconSize = iconSize / 2f;
++++
++++        float iconX = circleX - halfIconSize;
++++        float iconY = circleY - halfIconSize;
++++
++++        float rotationAngle = calculateRotationAngle(animationProgress);
++++
++++        canvas.save();
++++
++++        canvas.translate(circleX, circleY);
++++        canvas.rotate(rotationAngle);
++++        canvas.translate(-circleX, -circleY);
++++
++++        drawable.setBounds((int) iconX, (int) iconY, (int) (iconX + iconSize), (int) (iconY + iconSize));
++++
++++        drawable.draw(canvas);
++++
++++        canvas.restore();
++++    }
++++
++++    private float calculateRotationAngle(float progress) {
++++        if (progress <= 0.5f) {
++++            float normalizedProgress = progress / 0.5f;
++++            return -30f * normalizedProgress;
++++        } else if (progress <= 0.9f) {
++++            float normalizedProgress = (progress - 0.5f) / 0.4f;
++++            return -30f + 60f * normalizedProgress;
++++        } else {
++++            float normalizedProgress = (progress - 0.9f) / 0.1f;
++++            return 30f - 30f * normalizedProgress;
++++        }
++++    }
++++
++++    private void drawCircle2(Canvas canvas, float x, float y, float size) {
++++        float currentAnimationBorder = 0.5f;
++++        float currentAnimationProgress = Math.min(animationProgress / currentAnimationBorder, 1);
++++
++++        float newY, newX, newSize;
++++        float xOffset = dpToPx(0);
++++        newX = x + (popupX - x) * currentAnimationProgress - xOffset;
++++        newY = y - Math.abs(y - popupY) * currentAnimationProgress;
++++        newSize = size + Math.abs(size - popupSize) * currentAnimationProgress;
++++
++++        if (animationProgress > 0.4f) {
++++            float additionalProgress = Math.abs((animationProgress - 0.4f)) / 0.6f;
++++            float sizeDecrease = dpToPx(20f);
++++            newSize -= sizeDecrease * additionalProgress;
++++        }
++++
++++        RadialGradient gradient = new RadialGradient(
++++                newX, newY, Math.max(newSize, 0.001f),
++++                new int[]{rectColor, 0x00000000},
++++                new float[]{0.5f, 1.0f},
++++                Shader.TileMode.CLAMP
++++        );
++++        gradientPaint.setShader(gradient);
++++
++++        canvas.drawCircle(newX, newY, Math.max(newSize, 0.001f), gradientPaint);
++++    }
++++
++++    private void drawRoundedRect(Canvas canvas, float x, float y, float size, Canvas canvas1) {
++++        float currentAnimationExpandBorder = 0.4f;
++++        float currentAnimationBorder = 0.5f;
++++        float currentAnimationProgress = Math.min(animationProgress / currentAnimationBorder, 1);
++++        float offset = 0;
++++
++++        float newY, newX, newSize;
++++        float xOffset = dpToPx(0);
++++        newX = x + (popupX - x) * currentAnimationProgress - xOffset;
++++        newY = y - Math.abs(y - popupY) * currentAnimationProgress;
++++        newSize = size + Math.abs(size - popupSize) * currentAnimationProgress;
++++
++++        float rectWidth = newSize;
++++        if (animationProgress > currentAnimationExpandBorder) {
++++            rectWidth = popupSize + (targetWidth - popupSize) * (animationProgress - currentAnimationExpandBorder);
++++            offset = dpToPx(40f) * (animationProgress - currentAnimationExpandBorder);
++++        }
++++        float rectHeight = newSize;
++++        float cornerRadius = popupSize;
++++
++++        float leftBound = newX - rectWidth / 2 - offset;
++++        float rightBound = newX + rectWidth / 2;
++++
++++        if (leftBound < dpToPx(4)) {
++++            float diff = dpToPx(4) - leftBound;
++++            leftBound += diff;
++++            rightBound += diff;
++++        }
++++        if (rightBound > w - dpToPx(4)) {
++++            float diff = rightBound - (w - dpToPx(4));
++++            leftBound -= diff;
++++            rightBound -= diff;
++++        }
++++
++++        RectF rect = new RectF(
++++                leftBound,
++++                newY - rectHeight / 2 - dpToPx(4),
++++                rightBound,
++++                newY + rectHeight / 2 - dpToPx(4)
++++        );
++++        RectF shadowRect = new RectF(
++++                rect.left,
++++                rect.top + dpToPx(1f),
++++                rect.right,
++++                rect.bottom + dpToPx(1f)
++++        );
++++        canvas1.drawRoundRect(shadowRect, cornerRadius, cornerRadius, shadowPaint);
++++
++++        canvas.drawRoundRect(rect, cornerRadius, cornerRadius, popupPaint);
++++
++++        drawAvatars(canvas, rect, canvas1);
++++    }
++++
++++
++++    private final float ANIMATION_BORDER_1 = 0.42f;
++++    private final float ANIMATION_BORDER_2 = 0.60f;
++++    private final float ANIMATION_BORDER_3 = 0.89f;
++++
++++    private void drawAvatars(Canvas canvas, RectF rect, Canvas canvas1) {
++++        int avatarCount = 5;
++++        float padding = dpToPx(8f);
++++        float avatarDiameter = rect.height() - 2 * padding;
++++        float totalAvatarWidth = avatarCount * avatarDiameter + (avatarCount - 1) * padding;
++++        float startX = rect.left + (rect.width() - totalAvatarWidth) / 2;
++++        float centerY = rect.centerY();
++++
++++        for (int i = 0; i < avatarCount; i++) {
++++            float avatarX = startX + i * (avatarDiameter + padding);
++++            float avatarSize = 0f;
++++
++++            if (animationProgress > ANIMATION_BORDER_3 && (i == 0 || i == 4)) {
++++                float progress = (animationProgress - ANIMATION_BORDER_3) / (1.0f - ANIMATION_BORDER_3);
++++                avatarSize = avatarDiameter * Math.min(progress, 1);
++++            } else if (animationProgress > ANIMATION_BORDER_2 && (i == 1 || i == 3)) {
++++                float progress = (animationProgress - ANIMATION_BORDER_2) / (ANIMATION_BORDER_3 - ANIMATION_BORDER_2) * 0.7f;
++++                avatarSize = avatarDiameter * Math.min(progress, 1);
++++            } else if (animationProgress > ANIMATION_BORDER_1 && i == 2) {
++++                float progress = (animationProgress - ANIMATION_BORDER_1) / (ANIMATION_BORDER_2 - ANIMATION_BORDER_1) * 0.3f;
++++                avatarSize = avatarDiameter * Math.min(progress, 1);
++++            }
++++
++++            if (avatarSize > 0) {
++++
++++                ImageReceiver imageReceiver = imageReceivers[i];
++++                imageReceiver.setRoundRadius((int) popupSize);
++++                if (animationProgress >= 1f) {
++++                    float alfa;
++++                    float scaleFactor;
++++
++++                    if (highlightedAvatarIndex == -1 ) {
++++                        scaleFactor = 0f;
++++                        alfa = 1f;
++++                    } else if ((highlightedAvatarIndex == i) || (i == previousHighlightedAvatarIndex)) {
++++                        float currentSelectProgress = (i == previousHighlightedAvatarIndex) ? Math.max(previousTooltipProgress - tooltipProgress, 0) : tooltipProgress;
++++                        alfa = .6f + .4f * currentSelectProgress;
++++                        scaleFactor = 2f * currentSelectProgress;
++++                    } else if (previousHighlightedAvatarIndex == -1) {
++++                        float currentSelectProgress = tooltipProgress;
++++                        alfa = 1f - .4f * currentSelectProgress;
++++                        scaleFactor = 0f;
++++                    } else {
++++                        alfa = .6f;
++++                        scaleFactor = 0f;
++++                    }
++++                    imageReceiver.setAlpha(alfa);
++++                    RectF bounds = new RectF(
++++                            -dpToPx(scaleFactor) + avatarX + avatarDiameter / 2 - avatarSize / 2,
++++                            -dpToPx(scaleFactor) + centerY - avatarSize / 2,
++++                            dpToPx(scaleFactor) + avatarX + avatarDiameter / 2 - avatarSize / 2 + avatarSize,
++++                            dpToPx(scaleFactor) + centerY - avatarSize / 2 + avatarSize
++++                    );
++++                    avatarRects.add(
++++                            new RectF(
++++                                    -(padding / 2 + dpToPx(1)) - dpToPx(scaleFactor) + avatarX + avatarDiameter / 2 - avatarSize / 2,
++++                                    -padding - dpToPx(scaleFactor) + centerY - avatarSize / 2,
++++                                    (padding / 2 + dpToPx(1)) + dpToPx(scaleFactor) + avatarX + avatarDiameter / 2 - avatarSize / 2 + avatarSize,
++++                                    padding + dpToPx(scaleFactor) + centerY - avatarSize / 2 + avatarSize
++++                            )
++++                    );
++++                    imageReceiver.setImageCoords(bounds);
++++                    imageReceiver.draw(canvas);
++++
++++                    if ((highlightedAvatarIndex != -1 && i == highlightedAvatarIndex) || (previousHighlightedAvatarIndex != -1 && i == previousHighlightedAvatarIndex)) {
++++                        int color = colors[i];
++++                        String name = TextUtils.ellipsize(names[i].replace('\n', ' '), textPaint, dpToPx(82), TextUtils.TruncateAt.END).toString();
++++                        Rect textBounds = new Rect();
++++                        textPaint.getTextBounds(name, 0, name.length(), textBounds);
++++
++++                        float paddingHorizontal = dpToPx(7f);
++++                        float paddingVertical = dpToPx(5f);
++++
++++                        float textWidth = textBounds.width();
++++                        float textHeight = textBounds.height();
++++                        float tooltipWidth = textWidth + 2 * paddingHorizontal;
++++                        float tooltipHeight = textHeight + 2 * paddingVertical;
++++
++++                        float left = (bounds.left + bounds.right) / 2 - tooltipWidth / 2;
++++                        float top = bounds.top - tooltipHeight - dpToPx(9) - padding;
++++                        float right = left + tooltipWidth;
++++                        float bottom = top + tooltipHeight;
++++
++++                        if (left < dpToPx(4)) {
++++                            float diff = dpToPx(4) - left;
++++                            left += diff;
++++                            right += diff;
++++                        }
++++                        if (right > w - dpToPx(4)) {
++++                            float diff = right - (w - dpToPx(4));
++++                            left -= diff;
++++                            right -= diff;
++++                        }
++++                        float currentSelectProgress = (i == previousHighlightedAvatarIndex) ? Math.max(previousTooltipProgress - tooltipProgress, 0) : tooltipProgress;
++++                        tooltipPaint.setColor(color);
++++                        tooltipPaint.setStrokeWidth(dpToPx(1));
++++                        tooltipPaint.setAlpha((int) (currentSelectProgress * 255));
++++                        textPaint.setAlpha((int) (currentSelectProgress * 255));
++++                        canvas1.drawRoundRect(new RectF(left, top, right, bottom), tooltipHeight, tooltipHeight, tooltipPaint);
++++                        canvas1.drawText(name, (left + right) / 2, (top + bottom) / 2 + dpToPx(4), textPaint);
++++                    }
++++                } else {
++++                    RectF bounds = new RectF(
++++                            avatarX + avatarDiameter / 2 - avatarSize / 2,
++++                            centerY - avatarSize / 2,
++++                            avatarX + avatarDiameter / 2 - avatarSize / 2 + avatarSize,
++++                            centerY - avatarSize / 2 + avatarSize
++++                    );
++++                    imageReceiver.setImageCoords(bounds);
++++                    imageReceiver.draw(canvas);
++++                }
++++            }
++++        }
++++    }
++++
++++
++++    private void applyThreshold() {
++++        int bitmapWidth = bitmap.getWidth();
++++        int bitmapHeight = bitmap.getHeight();
++++        int[] pixels = new int[bitmapWidth * bitmapHeight];
++++        bitmap.getPixels(pixels, 0, bitmapWidth, 0, 0, bitmapWidth, bitmapHeight);
++++
++++        for (int i = 0; i < pixels.length; i++) {
++++            int alpha = (pixels[i] >> 24) & 0xff;
++++            if (alpha < THRESHOLD) {
++++                pixels[i] = 0x01000000;
++++            }
++++        }
++++
++++        bitmap.setPixels(pixels, 0, bitmapWidth, 0, 0, bitmapWidth, bitmapHeight);
++++    }
++++
++++
++++    private boolean isTouchActive = true;
++++    private int highlightedAvatarIndex = -1;
++++    private int previousHighlightedAvatarIndex = -1;
++++
++++    @Override
++++    public boolean onTouchEvent(MotionEvent event) {
++++        float touchX = event.getX();
++++        float touchY = event.getY();
++++
++++        switch (event.getAction()) {
++++            case MotionEvent.ACTION_MOVE:
++++                if (isTouchActive) {
++++                    if (animationProgress >= 1f) {
++++                        int previousHighlightedIndex = highlightedAvatarIndex;
++++                        highlightedAvatarIndex = getTouchedAvatarIndex(touchX, touchY - getY());
++++                        if (previousHighlightedIndex != highlightedAvatarIndex) {
++++                            previousHighlightedAvatarIndex = previousHighlightedIndex;
++++                            animateTooltip();
++++                        }
++++                    }
++++                }
++++                return true;
++++
++++            case MotionEvent.ACTION_UP:
++++            case MotionEvent.ACTION_CANCEL:
++++                if (isTouchActive) {
++++                    isTouchActive = false;
++++                    if (animationProgress >= 1f) {
++++                        if (highlightedAvatarIndex != -1) {
++++                            sendInternal();
++++                        }
++++                        collapseAnimation();
++++                        highlightedAvatarIndex = -1;
++++                        previousHighlightedAvatarIndex = -1;
++++                    } else {
++++                        reverseAnimation();
++++                    }
++++                    return true;
++++                }
++++                break;
++++        }
++++        return false;
++++    }
++++
++++    private List<RectF> avatarRects = new ArrayList<>();
++++
++++    private int getTouchedAvatarIndex(float x, float y) {
++++        for (int i = 0; i < avatarRects.size(); i++) {
++++            RectF rect = avatarRects.get(i);
++++            if (rect.contains(x, y)) {
++++                return i;
++++            }
++++        }
++++        return -1;
++++    }
++++
++++    private float animationProgress = 0f;
++++    private float collapseAnimationProgress = 0f;
++++    private float tooltipProgress = 0f;
++++    private float previousTooltipProgress = 0f;
++++
++++    private boolean isPointInsideCircle(float x, float y, float centerX, float centerY, float radius) {
++++        return Math.hypot(x - centerX, y - centerY) <= radius;
++++    }
++++
++++    private float dpToPx(float dp) {
++++        return AndroidUtilities.dp(dp);
++++    }
++++
++++    public void init(float x, float y, float height, float sideStartY, ArrayList<MessageObject> messages) {
++++        circleX = x + dpToPx(16);
++++        circleY = y + sideStartY + dpToPx(17);
++++        popupX = circleX;
++++        popupY = circleY - dpToPx(56);
++++        sendingMessageObjects = messages;
++++
++++        fetchDialogs();
++++        calculateDrawingArea();
++++        addAvatars();
++++
++++    }
++++
++++    private ArrayList<Pair<Long, TLRPC.Dialog>> dialogs = new ArrayList<>();
++++
++++    public void fetchDialogs() {
++++        dialogs.clear();
++++        long selfUserId = UserConfig.getInstance(currentAccount).clientUserId;
++++        if (!MessagesController.getInstance(currentAccount).dialogsForward.isEmpty()) {
++++            TLRPC.Dialog dialog = MessagesController.getInstance(currentAccount).dialogsForward.get(0);
++++            dialogs.add(new Pair<>(dialog.id, dialog));
++++        }
++++        ArrayList<TLRPC.Dialog> allDialogs = MessagesController.getInstance(currentAccount).getAllDialogs();
++++        for (int a = 0; a < allDialogs.size(); a++) {
++++            TLRPC.Dialog dialog = allDialogs.get(a);
++++            if (!(dialog instanceof TLRPC.TL_dialog)) {
++++                continue;
++++            }
++++            if (dialog.id == selfUserId) {
++++                continue;
++++            }
++++            if (!DialogObject.isEncryptedDialog(dialog.id)) {
++++                if (DialogObject.isUserDialog(dialog.id)) {
++++                    dialogs.add(new Pair<>(dialog.id, dialog));
++++                } else {
++++                    TLRPC.Chat chat = MessagesController.getInstance(currentAccount).getChat(-dialog.id);
++++                    if (!(chat == null || ChatObject.isNotInChat(chat) || chat.gigagroup && !ChatObject.hasAdminRights(chat) || ChatObject.isChannel(chat) && !chat.creator && (chat.admin_rights == null || !chat.admin_rights.post_messages) && !chat.megagroup)) {
++++                        dialogs.add(new Pair<>(dialog.id, dialog));
++++                    }
++++                }
++++            }
++++        }
++++        try {
++++            List<Pair<Long, TLRPC.Dialog>> sublist = new ArrayList<>(dialogs.subList(0, Math.min(5, dialogs.size())));
++++            dialogs.clear();
++++            dialogs.addAll(sublist);
++++        } catch (Exception e) {
++++            //
++++        }
++++    }
++++
++++    @Override
++++    protected void onAttachedToWindow() {
++++        super.onAttachedToWindow();
++++        startAnimation();
++++        for (ImageReceiver imageReceiver : imageReceivers) {
++++            imageReceiver.onAttachedToWindow();
++++        }
++++        startFrameCallback();
++++    }
++++
++++    @Override
++++    protected void onDetachedFromWindow() {
++++        super.onDetachedFromWindow();
++++        for (ImageReceiver imageReceiver : imageReceivers) {
++++            imageReceiver.onDetachedFromWindow();
++++        }
++++        stopFrameCallback();
++++    }
++++
++++    ImageReceiver[] imageReceivers = {new ImageReceiver(this), new ImageReceiver(this), new ImageReceiver(this), new ImageReceiver(this), new ImageReceiver(this)};
++++    String[] names = new String[5];
++++    int[] colors = new int[5];
++++    boolean colorsSet = false;
++++    boolean colorSetFromThumb = false;
++++
++++    public void addAvatars() {
++++        for (int i = 0; i < Math.min(dialogs.size(), 5); i++) {
++++            AvatarDrawable avatarDrawable = new AvatarDrawable() {
++++                @Override
++++                public void invalidateSelf() {
++++                    super.invalidateSelf();
++++                }
++++            };
++++            ImageReceiver imageReceiver = imageReceivers[i];
++++            imageReceiver.setInvalidateAll(true);
++++            imageReceiver.setCrossfadeDuration(0);
++++            TLRPC.Dialog dialog = dialogs.get(i).second;
++++            long dialogId = dialog.id;
++++            if (DialogObject.isUserDialog(dialogId)) {
++++                TLRPC.User user = MessagesController.getInstance(currentAccount).getUser(dialogId);
++++                avatarDrawable.setInfo(currentAccount, user);
++++                names[i] = UserObject.getFirstName(user);
++++                if (UserObject.isReplyUser(user)) {
++++                    avatarDrawable.setAvatarType(AvatarDrawable.AVATAR_TYPE_REPLIES);
++++                } else if (UserObject.isUserSelf(user)) {
++++                    avatarDrawable.setAvatarType(AvatarDrawable.AVATAR_TYPE_SAVED);
++++                    names[i] = LocaleController.getString(R.string.SavedMessages);
++++                }
++++
++++                imageReceiver.setForUserOrChat(user, avatarDrawable);
++++            } else {
++++                TLRPC.Chat chat = MessagesController.getInstance(currentAccount).getChat(-dialogId);
++++                avatarDrawable.setInfo(currentAccount, chat);
++++                names[i] = chat.title;
++++                imageReceiver.setForUserOrChat(chat, avatarDrawable);
++++            }
++++        }
++++    }
++++
++++    protected void sendInternal() {
++++        if (highlightedAvatarIndex != -1) {
++++            boolean withSound = true;
++++            long key = dialogs.get(highlightedAvatarIndex).first;
++++            if (AlertsCreator.checkSlowMode(getContext(), currentAccount, key, false)) {
++++                return;
++++            }
++++            if (sendingMessageObjects != null) {
++++                int result = SendMessagesHelper.getInstance(currentAccount).sendMessage(sendingMessageObjects, key, true, false, withSound, 0, null);
++++                AlertsCreator.showSendMediaAlert(result, chatActivity, null);
++++                onSend(dialogs.get(highlightedAvatarIndex).second, sendingMessageObjects.size(), null);
++++            }
++++        }
++++    }
++++
++++    protected void onSend(TLRPC.Dialog did, int count, TLRPC.TL_forumTopic topic) {
++++
++++    }
++++
++++    protected void onAnimationFinished() {
++++
++++    }
++++
++++    protected void onCollapseAnimationFinished() {
++++
++++    }
++++
++++
++++    private ValueAnimator animator;
++++    private ValueAnimator collapseAnimator;
++++    private ValueAnimator tooltipAnimator;
++++
++++    public void startAnimation() {
++++        animator = ValueAnimator.ofFloat(0f, 1f);
++++        animator.setDuration(600);
++++        animator.setInterpolator(new LinearInterpolator());
++++
++++        animator.addUpdateListener(animation -> {
++++            animationProgress = (float) animation.getAnimatedValue();
++++            postInvalidateOnAnimation();
++++        });
++++
++++        animator.addListener(new AnimatorListenerAdapter() {
++++            @Override
++++            public void onAnimationEnd(Animator animation) {
++++                animationProgress = 1f;
++++                onAnimationFinished();
++++                postInvalidateOnAnimation();
++++            }
++++        });
++++
++++        animator.start();
++++    }
++++
++++    private void collapseAnimation() {
++++        collapseAnimator = ValueAnimator.ofFloat(collapseAnimationProgress, 1f);
++++        collapseAnimator.setDuration(200);
++++        collapseAnimator.setInterpolator(new LinearInterpolator());
++++
++++        collapseAnimator.addUpdateListener(animation -> {
++++            collapseAnimationProgress = (float) animation.getAnimatedValue();
++++            postInvalidateOnAnimation();
++++        });
++++
++++        collapseAnimator.addListener(new AnimatorListenerAdapter() {
++++            @Override
++++            public void onAnimationEnd(Animator animation) {
++++                collapseAnimationProgress = 1f;
++++                highlightedAvatarIndex = -1;
++++                previousHighlightedAvatarIndex = -1;
++++                postInvalidateOnAnimation();
++++                onCollapseAnimationFinished();
++++            }
++++        });
++++
++++        collapseAnimator.start();
++++    }
++++
++++    private void reverseAnimation() {
++++        animator = ValueAnimator.ofFloat(animationProgress, 0f);
++++        animator.setDuration(200);
++++        animator.setInterpolator(new LinearInterpolator());
++++
++++        animator.addUpdateListener(animation -> {
++++            animationProgress = (float) animation.getAnimatedValue();
++++            postInvalidateOnAnimation();
++++        });
++++
++++        animator.addListener(new AnimatorListenerAdapter() {
++++            @Override
++++            public void onAnimationEnd(Animator animation) {
++++                animationProgress = 0f;
++++                onAnimationFinished();
++++                onCollapseAnimationFinished();
++++                postInvalidateOnAnimation();
++++            }
++++        });
++++
++++        animator.start();
++++    }
++++
++++    private void animateTooltip() {
++++        previousTooltipProgress = tooltipProgress;
++++        tooltipAnimator = ValueAnimator.ofFloat(0, 1);
++++        tooltipAnimator.setDuration(200);
++++        tooltipAnimator.addUpdateListener(animation -> {
++++            tooltipProgress = (float) animation.getAnimatedValue();
++++            postInvalidateOnAnimation();
++++        });
++++        tooltipAnimator.start();
++++    }
++++
++++
++++    private Choreographer choreographer;
++++    private Choreographer.FrameCallback frameCallback;
++++
++++    private int frameCount = 0;
++++    private long lastTime = 0L;
++++
++++    private void startFrameCallback() {
++++        frameCallback = new Choreographer.FrameCallback() {
++++            @Override
++++            public void doFrame(long frameTimeNanos) {
++++                if (lastTime == 0L) {
++++                    lastTime = frameTimeNanos;
++++                }
++++                frameCount++;
++++
++++                long delta = frameTimeNanos - lastTime;
++++                if (delta >= 1_000_000_000L) {
++++                    double fps = frameCount * 1_000_000_000.0 / delta;
++++                    Log.d("Performance", "FPS: " + fps);
++++                    frameCount = 0;
++++                    lastTime = frameTimeNanos;
++++                }
++++
++++
++++                choreographer.postFrameCallback(this);
++++            }
++++        };
++++        choreographer.postFrameCallback(frameCallback);
++++    }
++++
++++    private void stopFrameCallback() {
++++        if (frameCallback != null) {
++++            choreographer.removeFrameCallback(frameCallback);
++++            frameCallback = null;
++++        }
++++    }
++++}
+++\ No newline at end of file
++Index: TMessagesProj/src/main/java/org/telegram/ui/Components/AudioPlayerAlert.java
++IDEA additional info:
++Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
++<+>UTF-8
++===================================================================
++diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Components/AudioPlayerAlert.java b/TMessagesProj/src/main/java/org/telegram/ui/Components/AudioPlayerAlert.java
++--- a/TMessagesProj/src/main/java/org/telegram/ui/Components/AudioPlayerAlert.java	(revision 874d55edbe2a2f018623a8cad64f8961783398d8)
+++++ b/TMessagesProj/src/main/java/org/telegram/ui/Components/AudioPlayerAlert.java	(revision 7abb478476b551212e133e734e0ce882a5fba200)
++@@ -17,6 +17,7 @@
++ import android.content.Context;
++ import android.content.Intent;
++ import android.content.pm.PackageManager;
+++import android.content.res.TypedArray;
++ import android.graphics.Bitmap;
++ import android.graphics.Canvas;
++ import android.graphics.Color;
++@@ -29,6 +30,7 @@
++ import android.graphics.RectF;
++ import android.graphics.Shader;
++ import android.graphics.drawable.BitmapDrawable;
+++import android.graphics.drawable.ColorDrawable;
++ import android.graphics.drawable.Drawable;
++ import android.net.Uri;
++ import android.os.Build;
++@@ -49,19 +51,26 @@
++ import android.widget.TextView;
++ 
++ import androidx.annotation.NonNull;
+++import androidx.appcompat.view.ContextThemeWrapper;
+++import androidx.core.content.ContextCompat;
++ import androidx.core.content.FileProvider;
++ import androidx.core.graphics.ColorUtils;
+++import androidx.core.graphics.drawable.DrawableCompat;
++ import androidx.dynamicanimation.animation.FloatValueHolder;
++ import androidx.dynamicanimation.animation.SpringAnimation;
++ import androidx.dynamicanimation.animation.SpringForce;
+++import androidx.media3.common.util.UnstableApi;
+++import androidx.mediarouter.app.MediaRouteButton;
++ import androidx.recyclerview.widget.LinearLayoutManager;
++ import androidx.recyclerview.widget.RecyclerView;
++ 
++ import com.google.android.exoplayer2.C;
+++import com.google.android.gms.cast.framework.CastButtonFactory;
++ 
++ import org.telegram.messenger.AndroidUtilities;
++ import org.telegram.messenger.ApplicationLoader;
++ import org.telegram.messenger.BuildVars;
+++import org.telegram.messenger.ChromeCastController;
++ import org.telegram.messenger.ContactsController;
++ import org.telegram.messenger.DialogObject;
++ import org.telegram.messenger.DownloadController;
++@@ -106,7 +115,7 @@
++ import java.util.ArrayList;
++ import java.util.List;
++ 
++-public class AudioPlayerAlert extends BottomSheet implements NotificationCenter.NotificationCenterDelegate, DownloadController.FileDownloadProgressListener {
+++@UnstableApi public class AudioPlayerAlert extends BottomSheet implements NotificationCenter.NotificationCenterDelegate, DownloadController.FileDownloadProgressListener {
++ 
++     private ActionBar actionBar;
++     private View actionBarShadow;
++@@ -1177,6 +1186,7 @@
++         listView.setOnItemClickListener((view, position) -> {
++             if (view instanceof AudioPlayerCell) {
++                 ((AudioPlayerCell) view).didPressedButton();
+++                setChromeCastUri();
++             }
++         });
++         listView.setOnScrollListener(new RecyclerView.OnScrollListener() {
++@@ -1254,6 +1264,47 @@
++         updateTitle(false);
++         updateRepeatButton();
++         updateEmptyView();
+++
+++        if (ChromeCastController.getInstance().isGooglePlayServicesAvailable) {
+++            try {
+++                boolean isDark = ColorUtils.calculateLuminance(getThemedColor(Theme.key_windowBackgroundWhite)) <= 0.5f;
+++                MediaRouteButton castButton = new MediaRouteButton(parentActivity);
+++                CastButtonFactory.setUpMediaRouteButton(parentActivity.getApplicationContext(), castButton);
+++                int tintColor = isDark ? Color.WHITE : Color.BLACK;
+++                ContextThemeWrapper castContext = new ContextThemeWrapper(context, androidx.mediarouter.R.style.Theme_MediaRouter);
+++                TypedArray attrs = castContext.obtainStyledAttributes(null, androidx.mediarouter.R.styleable.MediaRouteButton, androidx.mediarouter.R.attr.mediaRouteButtonStyle, 0);
+++                Drawable drawable = attrs.getDrawable(androidx.mediarouter.R.styleable.MediaRouteButton_externalRouteEnabledDrawable);
+++                attrs.recycle();
+++                DrawableCompat.setTint(drawable, tintColor);
+++                drawable.setState(castButton.getDrawableState());
+++                castButton.setRemoteIndicatorDrawable(drawable);
+++                playerLayout.addView(castButton, LayoutHelper.createFrame(LayoutHelper.WRAP_CONTENT, LayoutHelper.WRAP_CONTENT, Gravity.TOP | Gravity.RIGHT, 0, 10, 0, 0));
+++                ChromeCastController.getInstance().addVideoPlayerListener(new ChromeCastController.VideoPlayerPausePlay() {
+++                    @Override
+++                    public void pause() {
+++                        if (MediaController.getInstance().isDownloadingCurrentMessage()) {
+++                            return;
+++                        }
+++                        if (!MediaController.getInstance().isMessagePaused()) {
+++                            MediaController.getInstance().pauseMessage(MediaController.getInstance().getPlayingMessageObject());
+++                        }
+++                    }
+++
+++                    @Override
+++                    public void play() {
+++                        if (MediaController.getInstance().isDownloadingCurrentMessage()) {
+++                            return;
+++                        }
+++                        if (MediaController.getInstance().isMessagePaused()) {
+++                            MediaController.getInstance().playMessage(MediaController.getInstance().getPlayingMessageObject());
+++                        }
+++                    }
+++                });
+++            } catch (Exception exception) {
+++                FileLog.e(exception);
+++            }
+++        }
+++        setChromeCastUri();
++     }
++ 
++     @Override
++@@ -1841,6 +1892,7 @@
++         NotificationCenter.getInstance(currentAccount).removeObserver(this, NotificationCenter.moreMusicDidLoad);
++         NotificationCenter.getGlobalInstance().removeObserver(this, NotificationCenter.messagePlayingSpeedChanged);
++         DownloadController.getInstance(currentAccount).removeLoadingFileObserver(this);
+++        ChromeCastController.getInstance().release();
++     }
++ 
++     @Override
++@@ -2691,4 +2743,62 @@
++ 
++         protected abstract TextView createTextView();
++     }
+++
+++    private void setChromeCastUri() {
+++        final MessageObject messageObject = MediaController.getInstance().getPlayingMessageObject();
+++//        String fileName = FileLoader.getDocumentFileName(messageObject.getDocument());
+++//        File f = null;
+++//        if (TextUtils.isEmpty(fileName)) {
+++//            fileName = messageObject.getFileName();
+++//        }
+++//        String path = messageObject.messageOwner.attachPath;
+++//        if (path != null && path.length() > 0) {
+++//            File temp = new File(path);
+++//            if (!temp.exists()) {
+++//                path = null;
+++//            }
+++//        }
+++//        if (path == null || path.length() == 0) {
+++//            path = FileLoader.getInstance(currentAccount).getPathToMessage(messageObject.messageOwner).toString();
+++//        }
+++//        MediaController.saveFile(path, parentActivity, 3, fileName, messageObject.getDocument() != null ? messageObject.getDocument().mime_type : "", uri -> BulletinFactory.of((FrameLayout) containerView, resourcesProvider).createDownloadBulletin(BulletinFactory.FileType.AUDIO).show());
+++
+++        try {
+++            File f = null;
+++            boolean isVideo = false;
+++
+++            if (messageObject != null) {
+++                        /*if (currentMessageObject.messageOwner.media instanceof TLRPC.TL_messageMediaWebPage) {
+++                            AndroidUtilities.openUrl(parentActivity, currentMessageObject.messageOwner.media.webpage.url);
+++                            return;
+++                        }*/
+++                if (!TextUtils.isEmpty(messageObject.messageOwner.attachPath)) {
+++                    f = new File(messageObject.messageOwner.attachPath);
+++                    if (!f.exists()) {
+++                        f = null;
+++                    }
+++                }
+++                if (f == null) {
+++                    f = FileLoader.getInstance(currentAccount).getPathToMessage(messageObject.messageOwner);
+++                }
+++            }
+++            if (f != null && !f.exists()) {
+++                f = new File(FileLoader.getDirectory(FileLoader.MEDIA_DIR_CACHE), f.getName());
+++            }
+++
+++            if (f != null && f.exists()) {
+++                String type;
+++                Uri uri;
+++                if (messageObject != null) {
+++                    type = messageObject.getMimeType();
+++                } else {
+++                    type = "other";
+++                }
+++                uri = Uri.fromFile(f);
+++                ChromeCastController.getInstance().setItem(uri,type);
+++            }
+++        } catch (Exception e) {
+++            FileLog.e(e);
+++        }
+++    }
++ }
++\ No newline at end of file
++Index: TMessagesProj/src/main/java/org/telegram/ui/Cells/AudioPlayerCell.java
++IDEA additional info:
++Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
++<+>UTF-8
++===================================================================
++diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Cells/AudioPlayerCell.java b/TMessagesProj/src/main/java/org/telegram/ui/Cells/AudioPlayerCell.java
++--- a/TMessagesProj/src/main/java/org/telegram/ui/Cells/AudioPlayerCell.java	(revision 405a062031f2eaccb7ef3fd3ee8cdbe588e28581)
+++++ b/TMessagesProj/src/main/java/org/telegram/ui/Cells/AudioPlayerCell.java	(revision f22de77006a92331923792135613b9653590acde)
++@@ -21,6 +21,7 @@
++ import android.view.accessibility.AccessibilityNodeInfo;
++ 
++ import org.telegram.messenger.AndroidUtilities;
+++import org.telegram.messenger.ChromeCastController;
++ import org.telegram.messenger.DownloadController;
++ import org.telegram.messenger.FileLoader;
++ import org.telegram.messenger.FileLog;
++Index: TMessagesProj/src/main/java/org/telegram/ui/PhotoViewer.java
++IDEA additional info:
++Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
++<+>UTF-8
++===================================================================
++diff --git a/TMessagesProj/src/main/java/org/telegram/ui/PhotoViewer.java b/TMessagesProj/src/main/java/org/telegram/ui/PhotoViewer.java
++--- a/TMessagesProj/src/main/java/org/telegram/ui/PhotoViewer.java	(revision 3f9ab845e0dcd6f1e2c3e8203eda7d10a9ef9414)
+++++ b/TMessagesProj/src/main/java/org/telegram/ui/PhotoViewer.java	(revision 7abb478476b551212e133e734e0ce882a5fba200)
++@@ -9,6 +9,7 @@
++ package org.telegram.ui;
++ 
++ import static org.telegram.messenger.AndroidUtilities.dp;
+++import static org.telegram.messenger.AndroidUtilities.getActivity;
++ import static org.telegram.messenger.AndroidUtilities.lerp;
++ import static org.telegram.messenger.LocaleController.getString;
++ 
++@@ -30,6 +31,7 @@
++ import android.content.pm.ActivityInfo;
++ import android.content.pm.PackageManager;
++ import android.content.res.Configuration;
+++import android.content.res.TypedArray;
++ import android.graphics.Bitmap;
++ import android.graphics.BitmapFactory;
++ import android.graphics.Canvas;
++@@ -127,6 +129,7 @@
++ import androidx.core.content.ContextCompat;
++ import androidx.core.content.FileProvider;
++ import androidx.core.graphics.ColorUtils;
+++import androidx.core.graphics.drawable.DrawableCompat;
++ import androidx.core.view.ViewCompat;
++ import androidx.core.view.WindowInsetsCompat;
++ import androidx.core.widget.NestedScrollView;
++@@ -357,10 +360,11 @@
++         private FrameLayout titleLayout;
++         SimpleTextView[] titleTextView;
++         AnimatedTextView subtitleTextView;
+++        MediaRouteButton castButton;
++ 
++-        public PhotoViewerActionBarContainer(Context context) {
+++        public PhotoViewerActionBarContainer(Context context, MediaRouteButton castButton) {
++             super(context);
++-
+++            this.castButton = castButton;
++             container = new FrameLayout(context);
++             container.setPadding(dp((AndroidUtilities.isTablet() ? 80 : 72) - 16), 0, 0, 0);
++             addView(container, LayoutHelper.createFrame(LayoutHelper.MATCH_PARENT, LayoutHelper.MATCH_PARENT, Gravity.FILL));
++@@ -396,6 +400,9 @@
++             subtitleTextView.setTextColor(0xffffffff);
++             subtitleTextView.setEllipsizeByGradient(true);
++             container.addView(subtitleTextView, LayoutHelper.createFrame(LayoutHelper.MATCH_PARENT, 20, Gravity.LEFT | Gravity.TOP, 16, 0, 0, 0));
+++            if (castButton != null) {
+++                container.addView(castButton, LayoutHelper.createFrame(24, 24, Gravity.END | Gravity.CENTER_VERTICAL, 0, 0, 80, 0));
+++            }
++         }
++ 
++         public void setTextShadows(boolean applyShadows) {
++@@ -549,9 +556,13 @@
++                 rightPaddingAnimator = ValueAnimator.ofFloat(this.rightPadding, rightPadding);
++                 rightPaddingAnimator.addUpdateListener(anm -> {
++                     this.rightPadding = (float) anm.getAnimatedValue();
++-                    titleTextView[0].setRightPadding((int) rightPadding);
++-                    titleTextView[1].setRightPadding((int) rightPadding);
++-                    subtitleTextView.setRightPadding(rightPadding);
+++                    int extraPadding = dp(24);
+++
+++                    titleTextView[0].setRightPadding((int) rightPadding + extraPadding);
+++                    subtitleTextView.setRightPadding(rightPadding + extraPadding);
+++                    FrameLayout.LayoutParams layoutParams = (FrameLayout.LayoutParams) castButton.getLayoutParams();
+++                    layoutParams.setMarginEnd((int)rightPadding);
+++                    castButton.setLayoutParams(layoutParams);
++                 });
++                 rightPaddingAnimator.addListener(new AnimatorListenerAdapter() {
++                     @Override
++@@ -564,8 +575,12 @@
++                 rightPaddingAnimator.start();
++             } else {
++                 this.rightPadding = rightPadding;
++-                titleTextView[0].setRightPadding((int) rightPadding);
++-                subtitleTextView.setRightPadding(rightPadding);
+++                int extraPadding = dp(24);
+++                titleTextView[0].setRightPadding((int) rightPadding + extraPadding);
+++                subtitleTextView.setRightPadding(rightPadding + extraPadding);
+++                FrameLayout.LayoutParams layoutParams = (FrameLayout.LayoutParams) castButton.getLayoutParams();
+++                layoutParams.setMarginEnd((int)rightPadding);
+++                castButton.setLayoutParams(layoutParams);
++             }
++         }
++ 
++@@ -820,6 +835,7 @@
++     private ActionBarMenuItem sendItem;
++     private ActionBarMenuItem editItem;
++     private ActionBarMenuItem pipItem;
+++    MediaRouteButton castButton = null;
++     private ActionBarMenuItem masksItem;
++     private LinearLayout itemsLayout;
++     private ChooseQualityLayout.QualityIcon qualityIcon;
++@@ -4736,7 +4752,35 @@
++         actionBar.setItemsBackgroundColor(Theme.ACTION_BAR_WHITE_SELECTOR_COLOR, false);
++         actionBar.setItemsColor(Color.WHITE, false);
++         actionBar.setBackButtonImage(R.drawable.ic_ab_back);
++-        actionBarContainer = new PhotoViewerActionBarContainer(activity);
+++        if (ChromeCastController.getInstance().isGooglePlayServicesAvailable) {
+++            try {
+++                castButton = new MediaRouteButton(parentActivity);
+++                CastButtonFactory.setUpMediaRouteButton(parentActivity.getApplicationContext(), castButton);
+++                int tintColor = Color.WHITE;
+++                ContextThemeWrapper castContext = new ContextThemeWrapper(parentActivity, androidx.mediarouter.R.style.Theme_MediaRouter);
+++                TypedArray attrs = castContext.obtainStyledAttributes(null, androidx.mediarouter.R.styleable.MediaRouteButton, androidx.mediarouter.R.attr.mediaRouteButtonStyle, 0);
+++                Drawable drawable = attrs.getDrawable(androidx.mediarouter.R.styleable.MediaRouteButton_externalRouteEnabledDrawable);
+++                attrs.recycle();
+++                DrawableCompat.setTint(drawable, tintColor);
+++                drawable.setState(castButton.getDrawableState());
+++                castButton.setRemoteIndicatorDrawable(drawable);
+++                ChromeCastController.getInstance().addVideoPlayerListener(new ChromeCastController.VideoPlayerPausePlay() {
+++                    @Override
+++                    public void pause() {
+++                        pauseVideoOrWeb();
+++                    }
+++
+++                    @Override
+++                    public void play() {
+++                        playVideoOrWeb();
+++                    }
+++                });
+++            } catch (Exception exception) {
+++
+++            }
+++        }
+++        actionBarContainer = new PhotoViewerActionBarContainer(activity, castButton);
+++
++         actionBar.addView(actionBarContainer, LayoutHelper.createFrame(LayoutHelper.MATCH_PARENT, LayoutHelper.MATCH_PARENT, Gravity.FILL));
++         containerView.addView(actionBar, LayoutHelper.createFrame(LayoutHelper.MATCH_PARENT, LayoutHelper.WRAP_CONTENT));
++ 
++@@ -9781,28 +9825,6 @@
++             flashView.setAlpha(0.0f);
++             aspectRatioFrameLayout.addView(flashView, LayoutHelper.createFrame(LayoutHelper.MATCH_PARENT, LayoutHelper.MATCH_PARENT, Gravity.CENTER));
++         }
++-
++-        if (ChromeCastController.getInstance().isGooglePlayServicesAvailable) {
++-            try {
++-                MediaRouteButton castButton = new MediaRouteButton(parentActivity);
++-                castButton.setBackgroundColor(Color.YELLOW);
++-                CastButtonFactory.setUpMediaRouteButton(activityContext.getApplicationContext(), castButton);
++-                aspectRatioFrameLayout.addView(castButton, LayoutHelper.createFrame(LayoutHelper.WRAP_CONTENT, LayoutHelper.WRAP_CONTENT, Gravity.TOP | Gravity.RIGHT));
++-                ChromeCastController.getInstance().addVideoPlayerListener(new ChromeCastController.VideoPlayerPausePlay() {
++-                    @Override
++-                    public void pause() {
++-                        pauseVideoOrWeb();
++-                    }
++-
++-                    @Override
++-                    public void play() {
++-                        playVideoOrWeb();
++-                    }
++-                });
++-            } catch (Exception exception) {
++-
++-            }
++-        }
++     }
++ 
++     private void releasePlayer(boolean onClose) {
++@@ -14492,6 +14514,7 @@
++             }
++         }
++         detectFaces();
+++        setChromeCastUri();
++     }
++ 
++     private void resetIndexForDeferredImageLoading() {
++@@ -21190,4 +21213,53 @@
++             }
++         });
++     }
+++
+++    private void setChromeCastUri() {
+++        try {
+++            File f = null;
+++            boolean isVideo = false;
+++
+++            if (currentMessageObject != null) {
+++                isVideo = currentMessageObject.isVideo();
+++                        /*if (currentMessageObject.messageOwner.media instanceof TLRPC.TL_messageMediaWebPage) {
+++                            AndroidUtilities.openUrl(parentActivity, currentMessageObject.messageOwner.media.webpage.url);
+++                            return;
+++                        }*/
+++                if (!TextUtils.isEmpty(currentMessageObject.messageOwner.attachPath)) {
+++                    f = new File(currentMessageObject.messageOwner.attachPath);
+++                    if (!f.exists()) {
+++                        f = null;
+++                    }
+++                }
+++                if (f == null) {
+++                    f = FileLoader.getInstance(currentAccount).getPathToMessage(currentMessageObject.messageOwner);
+++                }
+++            } else if (currentFileLocationVideo != null) {
+++                f = FileLoader.getInstance(currentAccount).getPathToAttach(getFileLocation(currentFileLocationVideo), getFileLocationExt(currentFileLocationVideo), avatarsDialogId != 0 || isEvent);
+++            } else if (pageBlocksAdapter != null) {
+++                f = pageBlocksAdapter.getFile(currentIndex);
+++            }
+++            if (f != null && !f.exists()) {
+++                f = new File(FileLoader.getDirectory(FileLoader.MEDIA_DIR_CACHE), f.getName());
+++            }
+++
+++            if (f != null && f.exists()) {
+++                String type;
+++                Uri uri;
+++                if (isVideo) {
+++                    type = "video/mp4";
+++                } else {
+++                    if (currentMessageObject != null) {
+++                        type = currentMessageObject.getMimeType();
+++                    } else {
+++                        type = "image/jpeg";
+++                    }
+++                }
+++                uri = Uri.fromFile(f);
+++                ChromeCastController.getInstance().setItem(uri, type);
+++            }
+++        } catch (Exception e) {
+++            FileLog.e(e);
+++        }
+++    }
++ }
++Index: TMessagesProj/src/main/java/org/telegram/ui/Components/FragmentContextView.java
++IDEA additional info:
++Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
++<+>UTF-8
++===================================================================
++diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Components/FragmentContextView.java b/TMessagesProj/src/main/java/org/telegram/ui/Components/FragmentContextView.java
++--- a/TMessagesProj/src/main/java/org/telegram/ui/Components/FragmentContextView.java	(revision 9a9af1d971e905e7b4ed63a244ad1dc2d9fc84c4)
+++++ b/TMessagesProj/src/main/java/org/telegram/ui/Components/FragmentContextView.java	(revision 0bd977fdbdf619307d8f52b8ef7998bd12fbb738)
++@@ -762,6 +762,7 @@
++                     } else {
++                         text = LocaleController.getString(R.string.VoipGroupVoiceChat);
++                     }
+++                    frameLayout.invalidate();
++                     showReminderBulletin(LocaleController.formatString(R.string.VoipChatNotifyHint, text.toLowerCase()));
++                 } else {
++                     VoIPHelper.startCall(fragment.getMessagesController().getChat(call.chatId), null, null, false, call.call != null && !call.call.rtmp_stream, fragment.getParentActivity(), fragment, fragment.getAccountInstance());
++Index: TMessagesProj/src/main/java/org/telegram/messenger/ChromeCastController.java
++IDEA additional info:
++Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
++<+>UTF-8
++===================================================================
++diff --git a/TMessagesProj/src/main/java/org/telegram/messenger/ChromeCastController.java b/TMessagesProj/src/main/java/org/telegram/messenger/ChromeCastController.java
++--- a/TMessagesProj/src/main/java/org/telegram/messenger/ChromeCastController.java	(revision 0bd977fdbdf619307d8f52b8ef7998bd12fbb738)
+++++ b/TMessagesProj/src/main/java/org/telegram/messenger/ChromeCastController.java	(revision 7abb478476b551212e133e734e0ce882a5fba200)
++@@ -26,7 +26,6 @@
++ @UnstableApi
++ public class ChromeCastController implements Player.Listener, SessionAvailabilityListener {
++ 
++-    private static ChromeCastController instance;
++     private CastContext castContext;
++     public boolean isGooglePlayServicesAvailable;
++     private CastPlayer castPlayer;
++@@ -40,11 +39,12 @@
++     private ChromeCastController() {
++     }
++ 
+++    public static class SingletonHolder {
+++        public static final ChromeCastController HOLDER_INSTANCE = new ChromeCastController();
+++    }
+++
++     public static ChromeCastController getInstance() {
++-        if (instance == null) {
++-            instance = new ChromeCastController();
++-        }
++-        return instance;
+++        return SingletonHolder.HOLDER_INSTANCE;
++     }
++ 
++     public void init(Application application) {
++@@ -82,7 +82,9 @@
++         castPlayer.prepare();
++         if (listener != null) {
++             AndroidUtilities.runOnUIThread(() -> {
++-                listener.pause();
+++                if (listener != null) {
+++                    listener.pause();
+++                }
++             }, 3000);
++         }
++     }
++@@ -130,10 +132,11 @@
++     }
++ 
++     public void release() {
++-        mediaQueue.clear();
++-        castPlayer.setSessionAvailabilityListener(null);
++-        castPlayer.release();
+++//        mediaQueue.clear();
+++//        castPlayer.setSessionAvailabilityListener(null);
+++//        castPlayer.release();
++         listener = null;
+++        castPlayer.stop();
++     }
++ 
++     public interface VideoPlayerPausePlay {
++Index: TMessagesProj/src/main/java/org/telegram/ui/Components/VideoPlayer.java
++IDEA additional info:
++Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
++<+>UTF-8
++===================================================================
++diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Components/VideoPlayer.java b/TMessagesProj/src/main/java/org/telegram/ui/Components/VideoPlayer.java
++--- a/TMessagesProj/src/main/java/org/telegram/ui/Components/VideoPlayer.java	(revision 0bd977fdbdf619307d8f52b8ef7998bd12fbb738)
+++++ b/TMessagesProj/src/main/java/org/telegram/ui/Components/VideoPlayer.java	(revision 7abb478476b551212e133e734e0ce882a5fba200)
++@@ -318,9 +318,8 @@
++         audioPlayer.prepare();
++     }
++ 
++-    @OptIn(markerClass = UnstableApi.class) private MediaSource mediaSourceFromUri(Uri uri, String type) {
+++    private MediaSource mediaSourceFromUri(Uri uri, String type) {
++         MediaItem mediaItem = new MediaItem.Builder().setUri(uri).build();
++-        ChromeCastController.getInstance().setItem(uri, type);
++         switch (type) {
++             case "dash":
++                 if (dashMediaSourceFactory == null) {
++Index: TMessagesProj/src/main/java/org/telegram/ui/Cells/ChatMessageCell.java
++IDEA additional info:
++Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
++<+>UTF-8
++===================================================================
++diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Cells/ChatMessageCell.java b/TMessagesProj/src/main/java/org/telegram/ui/Cells/ChatMessageCell.java
++--- a/TMessagesProj/src/main/java/org/telegram/ui/Cells/ChatMessageCell.java	(revision 7abb478476b551212e133e734e0ce882a5fba200)
+++++ b/TMessagesProj/src/main/java/org/telegram/ui/Cells/ChatMessageCell.java	(revision 12fd7b127ef09e95009c782c9bcea8e7eb326cab)
++@@ -191,7 +191,6 @@
++ import org.telegram.ui.Components.spoilers.SpoilerEffect;
++ import org.telegram.ui.Components.spoilers.SpoilerEffect2;
++ import org.telegram.ui.GradientClip;
++-import org.telegram.ui.MetaballDrawable;
++ import org.telegram.ui.PhotoViewer;
++ import org.telegram.ui.PinchToZoomHelper;
++ import org.telegram.ui.SecretMediaViewer;
++@@ -225,7 +224,6 @@
++     public boolean shouldCheckVisibleOnScreen;
++     public float parentBoundsTop;
++     public int parentBoundsBottom;
++-    private MetaballDrawable popup;
++ 
++     public ExpiredStoryView expiredStoryView;
++     private boolean skipFrameUpdate;
++Index: TMessagesProj/src/main/java/org/telegram/ui/MetaballDrawable.java
++===================================================================
++diff --git a/TMessagesProj/src/main/java/org/telegram/ui/MetaballDrawable.java b/TMessagesProj/src/main/java/org/telegram/ui/MetaballDrawable.java
++deleted file mode 100644
++--- a/TMessagesProj/src/main/java/org/telegram/ui/MetaballDrawable.java	(revision 7abb478476b551212e133e734e0ce882a5fba200)
+++++ /dev/null	(revision 7abb478476b551212e133e734e0ce882a5fba200)
++@@ -1,309 +0,0 @@
++-package org.telegram.ui;
++-
++-import android.animation.ValueAnimator;
++-import android.graphics.Bitmap;
++-import android.graphics.Canvas;
++-import android.graphics.Color;
++-import android.graphics.ColorFilter;
++-import android.graphics.Paint;
++-import android.graphics.PixelFormat;
++-import android.graphics.RadialGradient;
++-import android.graphics.Rect;
++-import android.graphics.RectF;
++-import android.graphics.Shader;
++-import android.graphics.drawable.Drawable;
++-import android.text.TextPaint;
++-import android.view.MotionEvent;
++-
++-import org.telegram.messenger.AndroidUtilities;
++-
++-public class MetaballDrawable extends Drawable {
++-
++-    private Paint circlePaint;
++-    private Paint rectPaint;
++-    private Paint popupPaint;
++-    private Paint gradientPaint;
++-    private Bitmap bitmap;
++-    private Canvas tempCanvas;
++-    private int w, h;
++-    private final int THRESHOLD = 210;
++-
++-    private float circleX, circleY, circleSize;
++-    private float popupX, popupY, popupSize;
++-
++-    private TextPaint debugTextPaint;
++-
++-    public MetaballDrawable() {
++-        init();
++-    }
++-
++-    private void init() {
++-        // Initialize parameters
++-        circlePaint = new Paint(Paint.ANTI_ALIAS_FLAG);
++-        circlePaint.setColor(0xFF00FF00);
++-        popupPaint = new Paint(Paint.ANTI_ALIAS_FLAG);
++-        popupPaint.setColor(Color.RED);
++-        rectPaint = new Paint(Paint.ANTI_ALIAS_FLAG);
++-        rectPaint.setColor(0xFFFF0000);
++-        gradientPaint = new Paint(Paint.ANTI_ALIAS_FLAG);
++-        circleSize = dpToPx(20f);
++-        popupSize = dpToPx(40f);
++-        circleX = dpToPx(120);
++-        circleY = dpToPx(80);
++-        popupX = circleX;
++-        popupY = circleY - dpToPx(50);
++-
++-        // Bitmap and canvas setup will be done later in onBoundsChange()
++-        debugTextPaint = new TextPaint();
++-        debugTextPaint.setColor(Color.YELLOW); // Цвет текста, можно изменить
++-        debugTextPaint.setAntiAlias(true);
++-        debugTextPaint.setTextSize(dpToPx(14f)); // Размер текста, можно изменить
++-        debugTextPaint.setTextAlign(Paint.Align.LEFT); // Выравнивание текста
++-    }
++-
++-    @Override
++-    public int getIntrinsicWidth() {
++-        return (int) dpToPx(200);
++-    }
++-
++-    @Override
++-    public int getIntrinsicHeight() {
++-        return (int) dpToPx(100);
++-    }
++-
++-    @Override
++-    protected void onBoundsChange(Rect bounds) {
++-        super.onBoundsChange(bounds);
++-
++-        // Get drawable dimensions
++-        w = bounds.width();
++-        h = bounds.height();
++-
++-        // Initialize the bitmap and canvas for off-screen drawing
++-        if (w > 0 && h > 0) {
++-            bitmap = Bitmap.createBitmap(w, h, Bitmap.Config.ARGB_8888);
++-            tempCanvas = new Canvas(bitmap);
++-        }
++-    }
++-
++-    @Override
++-    public void draw(Canvas canvas) {
++-        animationProgress += 0.01f;
++-        if (animationProgress >= 1f) {
++-            animationProgress = 0.01f;
++-        }
++-        // Clear the temporary canvas
++-//        canvas.drawColor(Color.WHITE);
++-
++-        bitmap.eraseColor(0);
++-
++-        // Draw the static circle with radial gradient
++-        drawCircle1(tempCanvas, circleX, circleY, circleSize);
++-        drawCircle2(tempCanvas, circleX, circleY, circleSize);
++-        drawRoundedRect(tempCanvas, circleX, circleY, circleSize);
++-
++-        // Manipulate pixels to simulate the thresholding effect
++-        applyThreshold();
++-
++-        // Draw the bitmap (containing the metaballs) onto the main canvas
++-        canvas.drawBitmap(bitmap, 0, 0, gradientPaint);
++-
++-//        drawDebugInfo(canvas);
++-        invalidateSelf();
++-    }
++-
++-    private void drawCircle1(Canvas canvas, float x, float y, float size) {
++-        // Draw circle with radial gradient
++-        float offset1 = dpToPx(20f);
++-        float offset2 = dpToPx(28f);
++-        float offset3 = dpToPx(8f);
++-        float newY;
++-
++-        if (animationProgress <= 0.5f) {
++-            // Первые 50% анимации - подъем на 20dp
++-            newY = y - animationProgress * 2 * offset1;
++-        } else if (animationProgress <= 0.9f) {
++-            // Следующие 40% анимации - опускание на 28dp
++-            float progress = (animationProgress - 0.5f) / 0.4f; // Нормализация прогресса от 0.5 до 0.9
++-            newY = y - offset1 + progress * offset2;
++-        } else {
++-            // Последние 10% анимации - подъем на 8dp
++-            float progress = (animationProgress - 0.9f) / 0.1f; // Нормализация прогресса от 0.9 до 1.0
++-            newY = y - offset1 + offset2 - progress * offset3;
++-        }
++-
++-        // Создаем градиент для круга
++-        RadialGradient gradient = new RadialGradient(
++-                x, newY, size / 1.2f,
++-                new int[]{0xFF00FF00, 0x00000000},
++-                new float[]{0.5f, 1.0f}, // Make the transition sharper
++-                Shader.TileMode.CLAMP
++-        );
++-        circlePaint.setShader(gradient);
++-
++-        // Рисуем круг
++-        canvas.drawCircle(x, newY, size, circlePaint);
++-    }
++-
++-    public void setCircleCenter(float x, float y) {
++-        circleX = x;
++-        circleY = y - dpToPx(25);
++-        popupX = circleX;
++-        popupY = circleY - dpToPx(50);
++-        invalidateSelf();
++-    }
++-
++-    private void drawCircle2(Canvas canvas, float x, float y, float size) {
++-        float currentAnimationBorder = 0.5f; // Порог для первой части анимации
++-        float currentAnimationProgress = Math.min(animationProgress / currentAnimationBorder, 1);
++-
++-        float newY, newX, newSize;
++-        float xOffset = dpToPx(0);
++-        newX = x - xOffset;
++-        newY = y - Math.abs(y - popupY) * currentAnimationProgress;
++-        newSize = size + Math.abs(size - popupSize) * currentAnimationProgress;
++-
++-        // После 50% анимации уменьшаем размер круга на 10dp
++-        if (animationProgress > 0.4f) {
++-            float additionalProgress = Math.abs((animationProgress - 0.4f)) / 0.6f; // Нормализуем прогресс от 0.5 до 1.0
++-            float sizeDecrease = dpToPx(40f);
++-            newSize -= sizeDecrease * additionalProgress; // Уменьшаем размер на 10dp
++-        }
++-
++-        // Создаем градиент для круга
++-        RadialGradient gradient = new RadialGradient(
++-                newX, newY, Math.max(newSize, 0.001f),
++-                new int[]{0xFFFF0000, 0x00000000}, // Переход от красного к прозрачному
++-                new float[]{0.5f, 1.0f}, // Сохраняем резкий переход
++-                Shader.TileMode.CLAMP
++-        );
++-        gradientPaint.setShader(gradient);
++-
++-        // Рисуем круг
++-        canvas.drawCircle(newX, newY, Math.max(newSize, 0.001f), gradientPaint);
++-    }
++-
++-    private void drawRoundedRect(Canvas canvas, float x, float y, float size) {
++-        float targetWidth = popupSize * 6;
++-        float currentAnimationExpandBorder = 0.4f; // Replace with your actual animation progress
++-        float currentAnimationBorder = 0.5f; // Replace with your actual animation progress
++-        float currentAnimationProgress = Math.min(animationProgress / currentAnimationBorder, 1);
++-        float offset = 0;
++-
++-        float newY, newX, newSize;
++-        float xOffset = dpToPx(0);
++-        newX = x - xOffset;
++-        newY = y - Math.abs(y - popupY) * currentAnimationProgress;
++-        newSize = size + Math.abs(size - popupSize) * currentAnimationProgress;
++-
++-        float rectWidth = newSize;
++-        // Draw rounded rectangle with radial gradient
++-        if (animationProgress > currentAnimationExpandBorder) {
++-            rectWidth = popupSize + (targetWidth - popupSize) * (animationProgress - currentAnimationExpandBorder);
++-            offset = dpToPx(40f) * (animationProgress - currentAnimationExpandBorder);
++-        }
++-        float rectHeight = newSize;
++-        float cornerRadius = dpToPx(500f);
++-
++-        // Define the rectangle bounds
++-        RectF rect = new RectF(
++-                newX - rectWidth / 2 - offset,
++-                newY - rectHeight / 2 - dpToPx(4),
++-                newX + rectWidth / 2 - offset,
++-                newY + rectHeight / 2 - dpToPx(4)
++-        );
++-
++-        // Draw the rounded rectangle
++-        canvas.drawRoundRect(rect, cornerRadius, cornerRadius, popupPaint);
++-    }
++-
++-    private void applyThreshold() {
++-        int[] pixels = new int[w * h];
++-        bitmap.getPixels(pixels, 0, w, 0, 0, w, h);
++-
++-        for (int i = 0; i < pixels.length; i++) {
++-            int alpha = (pixels[i] >> 24) & 0xff; // Extract alpha channel
++-            if (alpha < THRESHOLD) {
++-                pixels[i] = 0x01000000; // Apply threshold effect
++-            }
++-        }
++-
++-        // Update bitmap with modified pixels
++-        bitmap.setPixels(pixels, 0, w, 0, 0, w, h);
++-    }
++-
++-    private float animationProgress = 0f;
++-    private ValueAnimator animator;
++-
++-//    public void startAnimation() {
++-//        animator = ValueAnimator.ofFloat(0f, 1f);
++-//        animator.setDuration(700); // Adjust as needed
++-//        animator.setInterpolator(new LinearInterpolator());
++-//
++-//        animator.addUpdateListener(animation -> {
++-//            animationProgress = (float) animation.getAnimatedValue();
++-//            invalidateSelf();
++-//        });
++-//
++-//        animator.addListener(new AnimatorListenerAdapter() {
++-//            @Override
++-//            public void onAnimationEnd(Animator animation) {
++-//                animationProgress = 1f;
++-//                invalidateSelf();
++-//            }
++-//        });
++-//
++-//        animator.start();
++-//    }
++-
++-    private float dpToPx(float dp) {
++-        return AndroidUtilities.dp(dp);
++-    }
++-
++-    private void drawDebugInfo(Canvas canvas) {
++-        // Позиция текста на экране (левый верхний угол)
++-        float x = dpToPx(10f); // Отступ от левого края
++-        float y = dpToPx(70f); // Отступ от верхнего края
++-
++-        // Формирование строки с информацией о прогрессе
++-        String debugText = String.format("%.2f", animationProgress);
++-
++-        // Разбиваем текст на строки (если используем переносы строк)
++-        String[] lines = debugText.split("\n");
++-
++-        // Отрисовываем каждую строку текста
++-        for (String line : lines) {
++-            canvas.drawText(line, x, y, debugTextPaint);
++-            y += debugTextPaint.getTextSize() + dpToPx(4f); // Переходим на следующую строку с отступом
++-        }
++-    }
++-
++-    @Override
++-    public void setAlpha(int alpha) {
++-        // Set the alpha for the drawable
++-    }
++-
++-    @Override
++-    public void setColorFilter(ColorFilter colorFilter) {
++-        // Set the color filter for the drawable
++-    }
++-
++-    @Override
++-    public int getOpacity() {
++-        return PixelFormat.TRANSLUCENT;
++-    }
++-
++-    public boolean onTouch(MotionEvent event) {
++-        switch (event.getAction()) {
++-            case MotionEvent.ACTION_DOWN:
++-                return true;
++-            case MotionEvent.ACTION_MOVE:
++-                return true;
++-            case MotionEvent.ACTION_UP:
++-                return false;
++-            case MotionEvent.ACTION_CANCEL:
++-                return false; // !лайфках, телега сама посылает cancel если сработает long;
++-        }
++-        return false;
++-    }
++-}
+Index: TMessagesProj/src/main/java/org/telegram/ui/ChatActivity.java
+IDEA additional info:
+Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
+<+>UTF-8
+===================================================================
+diff --git a/TMessagesProj/src/main/java/org/telegram/ui/ChatActivity.java b/TMessagesProj/src/main/java/org/telegram/ui/ChatActivity.java
+--- a/TMessagesProj/src/main/java/org/telegram/ui/ChatActivity.java	(revision 12fd7b127ef09e95009c782c9bcea8e7eb326cab)
++++ b/TMessagesProj/src/main/java/org/telegram/ui/ChatActivity.java	(revision 92b516a8a2db084a3b52a9b20cb5b3c665717774)
+@@ -945,6 +945,7 @@
+     private FireworksOverlay fireworksOverlay;
+ 
+     private boolean swipeBackEnabled = true;
++    private long popupStartTime;
+ 
+     public static Pattern publicMsgUrlPattern;
+     public static Pattern voiceChatUrlPattern;
+@@ -36240,14 +36241,15 @@
+         @Override
+         public void didLongPress(ChatMessageCell cell, float x, float y) {
+             if (cell.drawSideButton == 1 && x >= cell.sideStartX) {
+-                if (popupView != null) {
++                if (popupView != null && popupView.getParent() != null) {
+                     contentView.removeView(popupView);
+                 }
+-                if (getParentActivity() instanceof LaunchActivity) {
+-                    ((LaunchActivity)getParentActivity()).drawerLayoutContainer.setAllowOpenDrawerBySwipe(false);
+-                }
+-                int defaultColor = Theme.blendOver(cell.getThemedColor(Theme.key_chat_inBubble), Theme.multAlpha(cell.getThemedColor(Theme.key_windowBackgroundWhiteGrayText), .85f));
+-                popupView = new MetaballViewFINAL(getContext(), getThemedDrawable(Theme.key_drawable_shareIcon), ChatActivity.this, defaultColor) {
++                swipeBackEnabled = false;
++                popupStartTime = SystemClock.elapsedRealtime();
++                popupView = new MetaballViewFINAL(getContext(), getThemedDrawable(Theme.key_drawable_shareIcon),
++                        ChatActivity.this, contentView, getResourceProvider(),
++                        contentView.getHeight(), contentView.getWidth(), contentPaddingTop
++                ) {
+                     @Override
+                     protected void onSend(TLRPC.Dialog did, int count, TLRPC.TL_forumTopic topic) {
+                         createUndoView();
+@@ -36267,11 +36269,12 @@
+ 
+                     @Override
+                     protected void onCollapseAnimationFinished() {
+-                        contentView.removeView(popupView);
+-                        popupView = null;
+-
+-                        if (getParentActivity() instanceof LaunchActivity) {
+-                            ((LaunchActivity)getParentActivity()).drawerLayoutContainer.setAllowOpenDrawerBySwipe(true);
++                        if (popupView != null && popupView.getParent() != null) {
++                            contentView.removeView(popupView);
++                            popupView = null;
++                        }
++                        if ((SystemClock.elapsedRealtime()) > popupStartTime) {
++                            swipeBackEnabled = true;
+                         }
+                     }
+                 };
+@@ -36287,16 +36290,26 @@
+                     arrayList = new ArrayList<>();
+                     arrayList.add(messageObject);
+                 }
+-                int[] position = new int[2];
+-                cell.getLocationOnScreen(position);
+-                int[] position2 = new int[2];
+-//                cell.getTransitionParams().ignoreAlpha = true;
+-//                cell.setAlpha(0.0f);
+-//                cell.setTimeAlpha(0.0f);
+-                cell.getLocationOnScreen(position2);
+-                Rect rect = new Rect();
+-                cell.getGlobalVisibleRect(rect);
+-                popupView.init(cell.sideStartX, cell.getY(), cell.getHeight(), cell.sideStartY, arrayList, x, y, position);
++
++                int height = 0;
++                int popupY;
++                popupY = (int) (chatListView.getY() + cell.getTop() + cell.sideStartY);
++                if (isInsideContainer) {
++                    int[] location = new int[2];
++                    cell.getLocationInWindow(location);
++                    popupY = (int) (location[1] + cell.sideStartY);
++
++                    chatListView.getLocationInWindow(location);
++                } else {
++                    Rect backgroundPaddings = new Rect();
++                    Drawable shadowDrawable = getParentActivity().getResources().getDrawable(R.drawable.popup_fixed_alert).mutate();
++                    shadowDrawable.getPadding(backgroundPaddings);
++                    if (height - backgroundPaddings.top - backgroundPaddings.bottom > AndroidUtilities.dp(240)) {
++                        popupY += AndroidUtilities.dp(240) - height;
++                    }
++                }
++                float finalY = popupY - ActionBar.getCurrentActionBarHeight() - AndroidUtilities.statusBarHeight + dp(16);
++                popupView.init(cell.sideStartX, arrayList, finalY);
+                 contentView.addView(popupView);
+                 cell.showSideButton1240 = true;
+             } else {
+Index: TMessagesProj/src/main/java/org/telegram/ui/MetaballViewFINAL.java
+IDEA additional info:
+Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
+<+>UTF-8
+===================================================================
+diff --git a/TMessagesProj/src/main/java/org/telegram/ui/MetaballViewFINAL.java b/TMessagesProj/src/main/java/org/telegram/ui/MetaballViewFINAL.java
+--- a/TMessagesProj/src/main/java/org/telegram/ui/MetaballViewFINAL.java	(revision 5e86e28674ba8709b9f7da45ba03f65c548e4b07)
++++ b/TMessagesProj/src/main/java/org/telegram/ui/MetaballViewFINAL.java	(revision 90807f9385ec2588e4df174dc957e7879ecade91)
+@@ -8,6 +8,7 @@
+ import android.graphics.BlurMaskFilter;
+ import android.graphics.Canvas;
+ import android.graphics.Color;
++import android.graphics.LinearGradient;
+ import android.graphics.Paint;
+ import android.graphics.Path;
+ import android.graphics.PathMeasure;
+@@ -15,22 +16,15 @@
+ import android.graphics.Rect;
+ import android.graphics.RectF;
+ import android.graphics.Shader;
+-import android.graphics.drawable.BitmapDrawable;
+ import android.graphics.drawable.Drawable;
+-import android.os.Handler;
+-import android.os.Looper;
+ import android.text.TextPaint;
+ import android.text.TextUtils;
+-import android.util.Log;
+ import android.util.Pair;
+-import android.view.Choreographer;
+ import android.view.MotionEvent;
+ import android.view.View;
+ import android.view.animation.LinearInterpolator;
+ import android.view.animation.OvershootInterpolator;
+ 
+-import androidx.core.graphics.ColorUtils;
+-
+ import org.telegram.messenger.AccountInstance;
+ import org.telegram.messenger.AndroidUtilities;
+ import org.telegram.messenger.ChatObject;
+@@ -44,7 +38,6 @@
+ import org.telegram.messenger.SendMessagesHelper;
+ import org.telegram.messenger.UserConfig;
+ import org.telegram.messenger.UserObject;
+-import org.telegram.messenger.Utilities;
+ import org.telegram.tgnet.TLRPC;
+ import org.telegram.ui.ActionBar.Theme;
+ import org.telegram.ui.Components.AlertsCreator;
+@@ -52,8 +45,6 @@
+ 
+ import java.util.ArrayList;
+ import java.util.List;
+-import java.util.concurrent.Executor;
+-import java.util.concurrent.Executors;
+ 
+ public class MetaballViewFINAL extends View {
+ 
+@@ -62,10 +53,8 @@
+     private final Drawable drawable;
+     private Paint circlePaint1;
+     private Paint circlePaint2;
+-    private Paint rectPaint;
+     private Paint popupPaint;
+     private Paint gradientPaint;
+-    private Paint avatarPaint;
+     private Paint tooltipPaint;
+     private TextPaint textPaint;
+     private int targetIconAlfa;
+@@ -79,22 +68,35 @@
+     private float popupX, popupY, popupSize;
+ 
+     private float targetWidth;
+-    private int circleColor = 0xFF646464;
+-    private int rectColor = 0xFFFFFFFF;
+-    private final int defaultAvatarColor;
++    private int circleColor;
++    private int rectColor;
++    private int contentPaddingTop;
+     private Paint shadowPaint;
+-    protected ArrayList<MessageObject> sendingMessageObjects;
++    private ArrayList<MessageObject> sendingMessageObjects;
++    private final View parentView;
++    private boolean darkTheme = Theme.getActiveTheme().isDark();
++    private Theme.ResourcesProvider resourcesProvider;
+ 
+-    public MetaballViewFINAL(Context context, Drawable drawable, ChatActivity chatActivity, int defaultAvatarColor) {
++    public MetaballViewFINAL(Context context, Drawable drawable, ChatActivity chatActivity, View parentView, Theme.ResourcesProvider resourcesProvider, int h, int w, int contentPaddingTop) {
+         super(context);
++        this.parentView = parentView;
+         this.drawable = drawable;
+-        this.defaultAvatarColor = defaultAvatarColor;
+         this.chatActivity = chatActivity;
++        this.resourcesProvider = resourcesProvider;
++        this.h = h;
++        this.w = w;
++        this.contentPaddingTop = contentPaddingTop;
+         init();
+     }
+ 
++//    private Paint thresholdPaint;
++
+     private void init() {
++//        thresholdPaint = new Paint();
++//        thresholdPaint.setFilterBitmap(true);
++//        thresholdPaint.setColorFilter(new PorterDuffColorFilter(Color.argb(THRESHOLD, 0, 0, 0), PorterDuff.Mode.DST_IN));
+ //        choreographer = Choreographer.getInstance();
++        rectColor = getThemedColor(darkTheme ? Theme.key_voipgroup_searchBackground : Theme.key_dialogSearchBackground);
+         circleColor = Theme.getThemePaint(Theme.key_paint_chatActionBackground).getColor();
+         targetIconAlfa = Color.alpha(circleColor);
+         circleColor = Color.argb(255, Color.red(circleColor), Color.green(circleColor), Color.blue(circleColor));
+@@ -110,17 +112,12 @@
+         shadowPaint.setStyle(Paint.Style.FILL);
+         shadowPaint.setMaskFilter(new BlurMaskFilter(dpToPx(80f), BlurMaskFilter.Blur.NORMAL));
+ 
+-        rectPaint = new Paint(Paint.ANTI_ALIAS_FLAG);
+-        rectPaint.setColor(rectColor);
+         gradientPaint = new Paint(Paint.ANTI_ALIAS_FLAG);
+-        avatarPaint = new Paint(Paint.ANTI_ALIAS_FLAG);
+-        avatarPaint.setColor(Color.BLUE);
++
+         circleSize = dpToPx(32f);
+         popupSize = dpToPx(58f);
+-        targetWidth = popupSize * 6;
+ 
+         tooltipPaint = new Paint(Paint.ANTI_ALIAS_FLAG);
+-        tooltipPaint.setColor(Color.parseColor("#80000000"));
+         tooltipPaint.setStyle(Paint.Style.FILL);
+ 
+         textPaint = new TextPaint(Paint.ANTI_ALIAS_FLAG);
+@@ -128,8 +125,6 @@
+         textPaint.setTextSize(dpToPx(11));
+         textPaint.setTypeface(AndroidUtilities.bold());
+         textPaint.setTextAlign(Paint.Align.CENTER);
+-
+-        setLayerType(LAYER_TYPE_HARDWARE, null);
+     }
+ 
+     float minY, maxY;
+@@ -155,20 +150,6 @@
+         minY -= padding + dpToPx(40f);
+         maxY += padding;
+ 
+-        drawingAreaTop = minY;
+-        drawingAreaBottom = maxY;
+-        drawingAreaHeight = drawingAreaBottom - drawingAreaTop;
+-    }
+-
+-
+-    @Override
+-    protected void onSizeChanged(int width, int height, int oldWidth, int oldHeight) {
+-        super.onSizeChanged(width, height, oldWidth, oldHeight);
+-
+-        // Get view dimensions
+-        w = width;
+-        h = height;
+-
+         drawingAreaTop = minY;
+         drawingAreaBottom = maxY;
+         drawingAreaHeight = drawingAreaBottom - drawingAreaTop;
+@@ -181,9 +162,199 @@
+         pixels = new int[bitmapWidth * bitmapHeight];
+     }
+ 
++    boolean skipForBitmap;
++
++    private Bitmap captureParentView() {
++        skipForBitmap = true;
++        float scaleFactor = .1f;
++        int scaledWidth = (int) (tooltipRect.width() * scaleFactor);
++        int scaledHeight = (int) (tooltipRect.height() * scaleFactor);
++
++        Bitmap bitmap = Bitmap.createBitmap(
++                scaledWidth,
++                scaledHeight,
++                Bitmap.Config.ARGB_8888
++        );
++
++        Canvas canvas = new Canvas(bitmap);
++        canvas.translate(-tooltipRect.left * scaleFactor, -tooltipRect.top * scaleFactor - dpToPx(87) * scaleFactor);
++        canvas.scale(scaleFactor, scaleFactor);
++
++        parentView.draw(canvas);
++        skipForBitmap = false;
++
++        return bitmap;
++    }
++
++    private int getAdjustedColor(Bitmap bitmap, int prevColor) {
++        int color = getAverageColorSampled(bitmap, 10);
++        float lightThreshold = 200f;
++        float darkThreshold = 55f;
++        float darkenFactor = 0.8f;
++        float lightenFactor = 1.2f;
++
++        if (isColorTooLight(color, lightThreshold)) {
++            color = darkenColor(color, darkenFactor);
++        } else if (isColorTooDark(color, darkThreshold)) {
++            color = lightenColor(color, lightenFactor);
++        }
++        if (prevColor != 0) {
++            color = AndroidUtilities.getAverageColor(prevColor, color);
++        }
++        return color;
++    }
++
++    private static int getAverageColor(Bitmap bitmap, int startX, int startY, int regionWidth, int regionHeight) {
++        long redSum = 0;
++        long greenSum = 0;
++        long blueSum = 0;
++        long pixelCount = 0;
++
++        for (int x = startX; x < startX + regionWidth; x++) {
++            for (int y = startY; y < startY + regionHeight; y++) {
++                if (x >= bitmap.getWidth() || y >= bitmap.getHeight()) {
++                    continue;
++                }
++
++                int pixel = bitmap.getPixel(x, y);
++                redSum += Color.red(pixel);
++                greenSum += Color.green(pixel);
++                blueSum += Color.blue(pixel);
++                pixelCount++;
++            }
++        }
++
++        if (pixelCount == 0) {
++            return Color.GRAY;
++        }
++
++        int avgRed = (int) (redSum / pixelCount);
++        int avgGreen = (int) (greenSum / pixelCount);
++        int avgBlue = (int) (blueSum / pixelCount);
++
++        return Color.rgb(avgRed, avgGreen, avgBlue);
++    }
++
++    public static List<Integer> getTopTwoColors(Bitmap bitmap) {
++        List<Integer> topColors = new ArrayList<>();
++
++        if (bitmap == null || bitmap.isRecycled()) {
++            return topColors;
++        }
++
++        int width = bitmap.getWidth();
++        int height = bitmap.getHeight();
++
++        int midX = width / 2;
++
++        int leftAverageColor = getAverageColor(bitmap, 0, 0, midX, height);
++        topColors.add(leftAverageColor);
++
++        int rightAverageColor = getAverageColor(bitmap, midX, 0, width - midX, height);
++        topColors.add(rightAverageColor);
++
++        return topColors;
++    }
++
++    private int[] getAdjusted2Color(Bitmap bitmap, int[] prevColor) {
++        List<Integer> topColors = getTopTwoColors(bitmap);
++        int[] adjustedColors = new int[2];
++
++        float lightThreshold = 200f;
++        float darkThreshold = 55f;
++        float darkenFactor = 0.8f;
++        float lightenFactor = 1.2f;
++
++        for (int i = 0; i < topColors.size(); i++) {
++            int color = topColors.get(i);
++
++            if (isColorTooLight(color, lightThreshold)) {
++                color = darkenColor(color, darkenFactor);
++            } else if (isColorTooDark(color, darkThreshold)) {
++                color = lightenColor(color, lightenFactor);
++            }
++            adjustedColors[i] = color;
++        }
++
++        if (prevColor[0] != 0) {
++            adjustedColors[0] = AndroidUtilities.getAverageColor(prevColor[0], adjustedColors[0]);
++            adjustedColors[1] = AndroidUtilities.getAverageColor(prevColor[1], adjustedColors[1]);
++        }
++
++        return adjustedColors;
++    }
++
++    public static int lightenColor(int color, float factor) {
++        if (isColorVeryDarkHSV(color, 55f)) return Color.GRAY;
++        float[] hsv = new float[3];
++        Color.colorToHSV(color, hsv);
++        hsv[2] = hsv[2] * factor;
++        hsv[2] = Math.min(hsv[2], 1);
++        return Color.HSVToColor(Color.alpha(color), hsv);
++    }
++
++    public static boolean isColorVeryDarkHSV(int color, float valueThreshold) {
++        float[] hsv = new float[3];
++        Color.colorToHSV(color, hsv);
++        return hsv[2] < valueThreshold;
++    }
++
++    public static int darkenColor(int color, float factor) {
++        float[] hsv = new float[3];
++        Color.colorToHSV(color, hsv);
++        hsv[2] = hsv[2] * factor;
++        hsv[2] = Math.max(hsv[2], 0);
++        return Color.HSVToColor(Color.alpha(color), hsv);
++    }
++
++    public static boolean isColorTooLight(int color, float threshold) {
++        double luminance = 0.299 * Color.red(color) +
++                0.587 * Color.green(color) +
++                0.114 * Color.blue(color);
++        return luminance > threshold;
++    }
++
++    public static boolean isColorTooDark(int color, float threshold) {
++        double luminance = 0.299 * Color.red(color) +
++                0.587 * Color.green(color) +
++                0.114 * Color.blue(color);
++        return luminance < threshold;
++    }
++
++    public int getAverageColorSampled(Bitmap bitmap, int step) {
++        long redSum = 0;
++        long greenSum = 0;
++        long blueSum = 0;
++        int width = bitmap.getWidth();
++        int height = bitmap.getHeight();
++        int count = 0;
++
++        for (int y = 0; y < height; y += step) {
++            for (int x = 0; x < width; x += step) {
++                int color = bitmap.getPixel(x, y);
++                redSum += Color.red(color);
++                greenSum += Color.green(color);
++                blueSum += Color.blue(color);
++                count++;
++            }
++        }
++
++        if (count == 0) {
++            return Color.GRAY;
++        }
++
++        int avgRed = (int) (redSum / count);
++        int avgGreen = (int) (greenSum / count);
++        int avgBlue = (int) (blueSum / count);
++
++        return Color.rgb(avgRed, avgGreen, avgBlue);
++    }
++
++
+     @Override
+     protected void onDraw(Canvas canvas) {
+         super.onDraw(canvas);
++        if (skipForBitmap) return;
+         Canvas currentCanvas = animationProgress < 1f ? tempCanvas : canvas;
+ 
+         if (!animationFinished) {
+@@ -217,54 +388,55 @@
+ 
+     }
+ 
+-    private void calculateColors() {
+-        if (!colorsSet) {
+-            for (int i = 0; i < imageReceivers.length; i++) {
+-                ImageReceiver imageReceiver = imageReceivers[i];
+-                if (imageReceiver.getStaticThumb() instanceof BitmapDrawable) {
+-                    final Bitmap bitmap = ((BitmapDrawable) imageReceiver.getStaticThumb()).getBitmap();
+-                    try {
+-                        final int bitmapColor = bitmap.getPixel(bitmap.getWidth() / 2, bitmap.getHeight() - 2);
+-                        float[] hsl = new float[3];
+-                        ColorUtils.colorToHSL(bitmapColor, hsl);
+-                        if (hsl[1] <= .05f || hsl[1] >= .95f || hsl[2] <= .02f || hsl[2] >= .98f) {
+-                            hsl[1] = 0;
+-                            hsl[2] = Theme.isCurrentThemeDark() ? .38f : .70f;
+-                        } else {
+-                            hsl[1] = .25f;
+-                            hsl[2] = Theme.isCurrentThemeDark() ? .35f : .65f;
+-                        }
+-                        colors[i] = ColorUtils.HSLToColor(hsl);
+-                    } catch (Exception e) {
+-                        FileLog.e(e);
+-                    }
+-                } else if (!colorsSet && !colorSetFromThumb) {
+-                    try {
+-                        final int color = ColorUtils.blendARGB(((AvatarDrawable) imageReceiver.getStaticThumb()).getColor(), ((AvatarDrawable) imageReceiver.getStaticThumb()).getColor2(), .5f);
+-                        float[] hsl = new float[3];
+-                        ColorUtils.colorToHSL(color, hsl);
+-                        if (hsl[1] <= .05f || hsl[1] >= .95f) {
+-                            hsl[2] = Utilities.clamp(hsl[2] - .1f, .6f, .3f);
+-                        } else {
+-                            hsl[1] = Utilities.clamp(hsl[1] - .06f, .4f, 0);
+-                            hsl[2] = Utilities.clamp(hsl[2] - .08f, .5f, .2f);
+-                        }
+-                        colors[i] = ColorUtils.HSLToColor(hsl);
+-                    } catch (Exception e) {
+-                        FileLog.e(e);
+-                    }
+-                    colorSetFromThumb = true;
+-                } else {
+-                    colors[i] = defaultAvatarColor;
+-                }
+-            }
+-        }
+-        colorsSet = true;
+-    }
++//    private void calculateColors() {
++//        if (!colorsSet) {
++//            for (int i = 0; i < imageReceivers.length; i++) {
++//                ImageReceiver imageReceiver = imageReceivers[i];
++//                if (imageReceiver.getStaticThumb() instanceof BitmapDrawable) {
++//                    final Bitmap bitmap = ((BitmapDrawable) imageReceiver.getStaticThumb()).getBitmap();
++//                    try {
++//                        final int bitmapColor = bitmap.getPixel(bitmap.getWidth() / 2, bitmap.getHeight() - 2);
++//                        float[] hsl = new float[3];
++//                        ColorUtils.colorToHSL(bitmapColor, hsl);
++//                        if (hsl[1] <= .05f || hsl[1] >= .95f || hsl[2] <= .02f || hsl[2] >= .98f) {
++//                            hsl[1] = 0;
++//                            hsl[2] = Theme.isCurrentThemeDark() ? .38f : .70f;
++//                        } else {
++//                            hsl[1] = .25f;
++//                            hsl[2] = Theme.isCurrentThemeDark() ? .35f : .65f;
++//                        }
++//                        colors[i] = ColorUtils.HSLToColor(hsl);
++//                    } catch (Exception e) {
++//                        FileLog.e(e);
++//                    }
++//                } else if (!colorsSet && !colorSetFromThumb) {
++//                    try {
++//                        final int color = ColorUtils.blendARGB(((AvatarDrawable) imageReceiver.getStaticThumb()).getColor(), ((AvatarDrawable) imageReceiver.getStaticThumb()).getColor2(), .5f);
++//                        float[] hsl = new float[3];
++//                        ColorUtils.colorToHSL(color, hsl);
++//                        if (hsl[1] <= .05f || hsl[1] >= .95f) {
++//                            hsl[2] = Utilities.clamp(hsl[2] - .1f, .6f, .3f);
++//                        } else {
++//                            hsl[1] = Utilities.clamp(hsl[1] - .06f, .4f, 0);
++//                            hsl[2] = Utilities.clamp(hsl[2] - .08f, .5f, .2f);
++//                        }
++//                        colors[i] = ColorUtils.HSLToColor(hsl);
++//                    } catch (Exception e) {
++//                        FileLog.e(e);
++//                    }
++//                    colorSetFromThumb = true;
++//                } else {
++//                    colors[i] = defaultAvatarColor;
++//                }
++//            }
++//        }
++//        colorsSet = true;
++//    }
+ 
+     float offset1 = dpToPx(12f);
+     float offset2 = dpToPx(18f);
+     float offset3 = dpToPx(6f);
++    RadialGradient gradient1;
+ 
+     private void drawCircle1(Canvas canvas, Canvas canvas1, float x, float y, float size) {
+         float newY;
+@@ -281,23 +453,23 @@
+             float progress = (animationProgress - 0.5f) / 0.4f;
+             newY = y - offset1 + progress * offset2;
+         } else {
+-            float progress = (animationProgress - 0.9f) / 0.1f;
++            float progress = (Math.min(1, animationProgress) - 0.9f) / 0.1f;
+             newY = y - offset1 + offset2 - progress * offset3;
+         }
+ 
+ 
+         if (animationProgress <= 0.80f) {
+-            RadialGradient gradient = new RadialGradient(
++            gradient1 = new RadialGradient(
+                     x, newY, size / 1.2f,
+                     new int[]{circleColor, 0x00000000},
+                     new float[]{0.5f, 1.0f},
+                     Shader.TileMode.CLAMP
+             );
+-            circlePaint1.setShader(gradient);
++            circlePaint1.setShader(gradient1);
+             canvas.drawCircle(x, newY, size, circlePaint1);
+             drawAnimatedIcon(canvas, x, newY, size);
+         } else {
+-            circlePaint2.setAlpha(Math.max(targetIconAlfa, (int) (255 * (1 - alfaProgress))));
++            circlePaint2.setAlpha(Math.max(targetIconAlfa, (int) (255 * (1 - Math.min(alfaProgress, 1)))));
+             canvas1.drawCircle(x, newY, circleSize / 2, circlePaint2);
+             drawAnimatedIcon(canvas1, x, newY, size);
+         }
+@@ -314,7 +486,7 @@
+         float iconX = circleX - halfIconSize;
+         float iconY = circleY - halfIconSize;
+ 
+-        float rotationAngle = calculateRotationAngle(animationProgress);
++        float rotationAngle = calculateRotationAngle((Math.min(1, animationProgress)));
+ 
+         canvas.save();
+ 
+@@ -342,8 +514,10 @@
+         }
+     }
+ 
++    RadialGradient gradient2;
++
+     private void drawCircle2(Canvas canvas, float x, float y, float size) {
+-        float currentAnimationBorder = 0.5f;
++        float currentAnimationBorder = 0.6f;
+         float currentAnimationProgress = Math.min(animationProgress / currentAnimationBorder, 1);
+ 
+         float newY, newX, newSize;
+@@ -358,58 +532,66 @@
+             newSize -= sizeDecrease * additionalProgress;
+         }
+ 
+-        RadialGradient gradient = new RadialGradient(
++        gradient2 = new RadialGradient(
+                 newX, newY, Math.max(newSize, 0.001f),
+                 new int[]{rectColor, 0x00000000},
+                 new float[]{0.5f, 1.0f},
+                 Shader.TileMode.CLAMP
+         );
+-        gradientPaint.setShader(gradient);
++        gradientPaint.setShader(gradient2);
+ 
+         canvas.drawCircle(newX, newY, Math.max(newSize, 0.001f), gradientPaint);
+     }
+ 
++    private RectF rect = new RectF();
++    private RectF shadowRect = new RectF();
++
+     private void drawRoundedRect(Canvas canvas, float x, float y, float size, Canvas canvas1) {
+         float currentAnimationExpandBorder = 0.4f;
+-        float currentAnimationBorder = 0.5f;
++        float currentAnimationBorder = 0.6f;
+         float currentAnimationProgress = Math.min(animationProgress / currentAnimationBorder, 1);
+         float offset = 0;
+ 
+-        float newY, newX, newSize;
+-        float xOffset = dpToPx(0);
+-        newX = x + (popupX - x) * currentAnimationProgress - xOffset;
++        float newY, newSize;
+         newY = y - Math.abs(y - popupY) * currentAnimationProgress;
+-        newSize = size + Math.abs(size - popupSize) * currentAnimationProgress;
++        if (animationProgress > currentAnimationProgress) {
++            newSize = size + Math.abs(size - popupSize) * (animationProgress - currentAnimationBorder) / (1 - currentAnimationBorder);
++        } else {
++            newSize = size + Math.abs(size - popupSize) * currentAnimationProgress;
++        }
+ 
+         float rectWidth = newSize;
+         if (animationProgress > currentAnimationExpandBorder) {
+-            rectWidth = popupSize + (targetWidth - popupSize) * (animationProgress - currentAnimationExpandBorder);
+-            offset = dpToPx(40f) * (animationProgress - currentAnimationExpandBorder);
++            float localProgress = (animationProgress - currentAnimationExpandBorder) / (1 - currentAnimationExpandBorder);
++            rectWidth = popupSize + (targetWidth - popupSize) * localProgress;
++            if (dpToPx(4) + popupX + targetWidth / 2 > w) {
++                offset = ((popupX + targetWidth / 2 + dpToPx(4)) - w) * localProgress;
++            }
+         }
+         float rectHeight = newSize;
+         float cornerRadius = popupSize;
+ 
+-        float leftBound = newX - rectWidth / 2 - offset;
+-        float rightBound = newX + rectWidth / 2;
++        float leftBound = x - rectWidth / 2 - offset;
++        float rightBound = x + rectWidth / 2 - offset;
+ 
+-        if (leftBound < dpToPx(4)) {
+-            float diff = dpToPx(4) - leftBound;
+-            leftBound += diff;
+-            rightBound += diff;
+-        }
+-        if (rightBound > w - dpToPx(4)) {
+-            float diff = rightBound - (w - dpToPx(4));
+-            leftBound -= diff;
+-            rightBound -= diff;
+-        }
++//        if (leftBound < dpToPx(4)) {
++//            float diff = dpToPx(4) - leftBound;
++//            leftBound += diff;
++//            rightBound += diff;
++//        }
++//        if (rightBound > w - dpToPx(4)) {
++//            float diff = rightBound - (w - dpToPx(4));
++//            leftBound -= diff;
++//            rightBound -= diff;
++//        }
+ 
+-        RectF rect = new RectF(
++        rect.set(
+                 leftBound,
+                 newY - rectHeight / 2 - dpToPx(4),
+                 rightBound,
+                 newY + rectHeight / 2 - dpToPx(4)
+         );
+-        RectF shadowRect = new RectF(
++        shadowRect.set(
+                 rect.left + dpToPx(20),
+                 rect.top + dpToPx(20),
+                 rect.right - dpToPx(20),
+@@ -421,37 +603,51 @@
+         drawAvatars(canvas, rect, canvas1);
+     }
+ 
+-    private final float ANIMATION_BORDER_1 = 0.42f;
+-    private final float ANIMATION_BORDER_2 = 0.60f;
+-    private final float ANIMATION_BORDER_3 = 0.89f;
+-
+ 
+     Path path = new Path();
+     PathMeasure pathMeasure;
+     float pathLength;
+     float[] pos = new float[2];
++    RectF bounds = new RectF();
++    RectF tooltipRect = new RectF();
++    //    int[] colors = new int[5];
++    int[][] colors2 = new int[5][2];
++    float avatarsPadding = dpToPx(8f);
+ 
+     private void drawAvatars(Canvas canvas, RectF rect, Canvas canvas1) {
+         int avatarCount = dialogs.size();
+-        float padding = dpToPx(8f);
+-        float avatarDiameter = rect.height() - 2 * padding;
+-        float totalAvatarWidth = avatarCount * avatarDiameter + (avatarCount - 1) * padding;
++        float avatarDiameter = rect.height() - 2 * avatarsPadding;
++        float totalAvatarWidth = avatarCount * avatarDiameter + (avatarCount - 1) * avatarsPadding;
+         float startX = rect.left + (rect.width() - totalAvatarWidth) / 2;
+         float centerY = rect.centerY();
+ 
+         for (int i = 0; i < avatarCount; i++) {
+-            float avatarX = startX + i * (avatarDiameter + padding);
++            float avatarX = startX + i * (avatarDiameter + avatarsPadding);
+             float avatarSize = 0f;
+ 
+-            if (animationProgress > ANIMATION_BORDER_3 && (i == 0 || i == 4)) {
+-                float progress = (animationProgress - ANIMATION_BORDER_3) / (1.0f - ANIMATION_BORDER_3);
+-                avatarSize = avatarDiameter * Math.min(progress, 1);
+-            } else if (animationProgress > ANIMATION_BORDER_2 && (i == 1 || i == 3)) {
+-                float progress = (animationProgress - ANIMATION_BORDER_2) / (ANIMATION_BORDER_3 - ANIMATION_BORDER_2) * 0.7f;
+-                avatarSize = avatarDiameter * Math.min(progress, 1);
+-            } else if (animationProgress > ANIMATION_BORDER_1 && i == 2) {
+-                float progress = (animationProgress - ANIMATION_BORDER_1) / (ANIMATION_BORDER_2 - ANIMATION_BORDER_1) * 0.3f;
+-                avatarSize = avatarDiameter * Math.min(progress, 1);
++            float animationBorder2 = 0.60f;
++            float animationBorder3 = 0.89f;
++            float animationBorder1 = 0.42f;
++            int centerIndex = avatarCount / 2;
++            int leftNeighbor = centerIndex - 1;
++            int rightNeighbor = centerIndex + 1;
++
++
++            if ((i == 0 || i == avatarCount - 1)) {
++                if (animationProgress > animationBorder3) {
++                    float progress = (animationProgress - animationBorder3) / (1.0f - animationBorder3);
++                    avatarSize = avatarDiameter * Math.min(progress, 1);
++                }
++            } else if ((i == leftNeighbor || i == rightNeighbor)) {
++                if (animationProgress > animationBorder2) {
++                    float progress = (animationProgress - animationBorder2) / (animationBorder3 - animationBorder2) * 0.7f;
++                    avatarSize = avatarDiameter * Math.min(progress, 1);
++                }
++            } else if (i == centerIndex) {
++                if (animationProgress > animationBorder1) {
++                    float progress = (animationProgress - animationBorder1) / (animationBorder2 - animationBorder1) * 0.3f;
++                    avatarSize = avatarDiameter * Math.min(progress, 1);
++                }
+             }
+ 
+             if (avatarSize > 0) {
+@@ -489,12 +685,11 @@
+                         alfa = .6f;
+                         scaleFactor = 0f;
+                     }
+-                    RectF bounds;
+                     if (collapseAnimationProgress != 0 && finalAvatarIndex == i) {
+                         float scale = 10 * (collapseAnimationProgress);
+                         imageReceiver.setAlpha(1);
+                         pathMeasure.getPosTan(pathLength * collapseAnimationProgress, pos, null);
+-                        bounds = new RectF(
++                        bounds.set(
+                                 -dpToPx(2) + dpToPx(scale) + pos[0] + avatarDiameter / 2 - avatarSize / 2,
+                                 -dpToPx(2) + dpToPx(scale) + pos[1] - avatarSize / 2,
+                                 -dpToPx(2) - dpToPx(scale) + pos[0] + avatarDiameter / 2 - avatarSize / 2 + avatarSize,
+@@ -502,7 +697,7 @@
+                         );
+                     } else if (collapseAnimationProgress != 0) {
+                         imageReceiver.setAlpha(alfa * (1 - collapseAnimationProgress));
+-                        bounds = new RectF(
++                        bounds.set(
+                                 -dpToPx(scaleFactor) + avatarX + avatarDiameter / 2 - avatarSize / 2,
+                                 -dpToPx(scaleFactor) + centerY - avatarSize / 2,
+                                 dpToPx(scaleFactor) + avatarX + avatarDiameter / 2 - avatarSize / 2 + avatarSize,
+@@ -510,7 +705,7 @@
+                         );
+                     } else {
+                         imageReceiver.setAlpha(alfa);
+-                        bounds = new RectF(
++                        bounds.set(
+                                 -dpToPx(scaleFactor) + avatarX + avatarDiameter / 2 - avatarSize / 2,
+                                 -dpToPx(scaleFactor) + centerY - avatarSize / 2,
+                                 dpToPx(scaleFactor) + avatarX + avatarDiameter / 2 - avatarSize / 2 + avatarSize,
+@@ -520,10 +715,10 @@
+                     if (avatarRects.size() != dialogs.size()) {
+                         avatarRects.add(
+                                 new RectF(
+-                                        -(padding / 2 + dpToPx(1)) - dpToPx(scaleFactor) + avatarX + avatarDiameter / 2 - avatarSize / 2,
+-                                        -padding - dpToPx(scaleFactor) + centerY - avatarSize / 2,
+-                                        (padding / 2 + dpToPx(1)) + dpToPx(scaleFactor) + avatarX + avatarDiameter / 2 - avatarSize / 2 + avatarSize,
+-                                        padding + dpToPx(scaleFactor) + centerY - avatarSize / 2 + avatarSize
++                                        -(avatarsPadding / 2 + dpToPx(1)) - dpToPx(scaleFactor) + avatarX + avatarDiameter / 2 - avatarSize / 2,
++                                        -avatarsPadding - dpToPx(scaleFactor) + centerY - avatarSize / 2,
++                                        (avatarsPadding / 2 + dpToPx(1)) + dpToPx(scaleFactor) + avatarX + avatarDiameter / 2 - avatarSize / 2 + avatarSize,
++                                        avatarsPadding + dpToPx(scaleFactor) + centerY - avatarSize / 2 + avatarSize
+                                 )
+                         );
+                     }
+@@ -531,7 +726,7 @@
+                     imageReceiver.draw(canvas);
+ 
+                     if ((highlightedAvatarIndex != -1 && i == highlightedAvatarIndex) || (previousHighlightedAvatarIndex != -1 && i == previousHighlightedAvatarIndex)) {
+-                        int color = colors[i];
++//                        int color = colors[i];
+                         String name = TextUtils.ellipsize(names[i].replace('\n', ' '), textPaint, dpToPx(82), TextUtils.TruncateAt.END).toString();
+                         Rect textBounds = new Rect();
+                         textPaint.getTextBounds(name, 0, name.length(), textBounds);
+@@ -545,7 +740,7 @@
+                         float tooltipHeight = textHeight + 2 * paddingVertical;
+ 
+                         float left = (bounds.left + bounds.right) / 2 - tooltipWidth / 2;
+-                        float top = bounds.top - tooltipHeight - dpToPx(9) - padding;
++                        float top = bounds.top - tooltipHeight - dpToPx(9) - avatarsPadding;
+                         float right = left + tooltipWidth;
+                         float bottom = top + tooltipHeight;
+ 
+@@ -560,15 +755,33 @@
+                             right -= diff;
+                         }
+                         float currentSelectProgress = (i == previousHighlightedAvatarIndex) ? Math.max(previousTooltipProgress - tooltipProgress, 0) : tooltipProgress;
+-                        tooltipPaint.setColor(color);
+-                        tooltipPaint.setStrokeWidth(dpToPx(1));
+-                        tooltipPaint.setAlpha((int) (currentSelectProgress * 255));
+-                        textPaint.setAlpha((int) (currentSelectProgress * 255));
+-                        canvas1.drawRoundRect(new RectF(left, top, right, bottom), tooltipHeight, tooltipHeight, tooltipPaint);
+-                        canvas1.drawText(name, (left + right) / 2, (top + bottom) / 2 + dpToPx(4), textPaint);
++                        if (currentSelectProgress != 0) {
++                            tooltipPaint.setStrokeWidth(dpToPx(1));
++                            tooltipPaint.setAlpha((int) (currentSelectProgress * 255));
++                            textPaint.setAlpha((int) (currentSelectProgress * 255));
++                            tooltipRect.set(left, top, right, bottom);
++
++                            Bitmap capturedBitmap = captureParentView();
++//                            int tooltipPaintColor = getAdjustedColor(capturedBitmap, colors[i]);
++
++                            int[] tooltipPaintColor2 = getAdjusted2Color(capturedBitmap, colors2[i]);
++                            colors2[i] = tooltipPaintColor2;
++                            Shader linearGradient = new LinearGradient(
++                                    tooltipRect.left, tooltipRect.top, tooltipRect.right, tooltipRect.bottom,
++                                    tooltipPaintColor2[0], tooltipPaintColor2[1],
++                                    Shader.TileMode.CLAMP
++                            );
++                            tooltipPaint.setShader(linearGradient);
++//                            colors[i] = tooltipPaintColor;
++//                            tooltipPaint.setColor(tooltipPaintColor);
++
++                            canvas1.drawRoundRect(tooltipRect, tooltipHeight, tooltipHeight, tooltipPaint);
++                            canvas1.drawText(name, (left + right) / 2, (top + bottom) / 2 + dpToPx(4), textPaint);
++                            invalidate();
++                        }
+                     }
+                 } else {
+-                    RectF bounds = new RectF(
++                    bounds.set(
+                             avatarX + avatarDiameter / 2 - avatarSize / 2,
+                             centerY - avatarSize / 2,
+                             avatarX + avatarDiameter / 2 - avatarSize / 2 + avatarSize,
+@@ -581,27 +794,27 @@
+         }
+     }
+ 
+-    private final Executor executor = Executors.newSingleThreadExecutor();
+-    private final Handler mainHandler = new Handler(Looper.getMainLooper());
+-
+-    private void applyThresholdAsync() {
+-        executor.execute(() -> {
+-            applyThreshold();
+-            mainHandler.post(() -> invalidate());
+-        });
+-    }
++//    private final Executor executor = Executors.newSingleThreadExecutor();
++//    private final Handler mainHandler = new Handler(Looper.getMainLooper());
++//
++//    private void applyThresholdAsync() {
++//        executor.execute(() -> {
++//            applyThreshold();
++//            mainHandler.post(() -> invalidate());
++//        });
++//    }
+ 
+     int bitmapWidth;
+     int bitmapHeight;
+     int[] pixels;
+ 
+     private void applyThreshold() {
+-
+         bitmap.getPixels(pixels, 0, bitmapWidth, 0, 0, bitmapWidth, bitmapHeight);
+ 
+         for (int i = 0; i < pixels.length; i++) {
+-            int alpha = (pixels[i] >> 24) & 0xff;
+-            if (alpha < THRESHOLD) {
++            int pixel = pixels[i];
++            int alpha = pixel & 0xFF000000;
++            if ((alpha >>> 24) < THRESHOLD) {
+                 pixels[i] = 0x01000000;
+             }
+         }
+@@ -659,9 +872,9 @@
+                             if (AccountInstance.getInstance(currentAccount).getUserConfig().isPremium()
+                                     && DialogObject.isUserDialog(dialogs.get(highlightedAvatarIndex).first)
+                                     && UserObject.isUserSelf(MessagesController.getInstance(currentAccount).getUser(dialogs.get(highlightedAvatarIndex).first))) {
+-                                path.quadTo(0, rectF.top + rectF.height() / 2, dpToPx(20), dpToPx(44));
++                                path.quadTo(0, Math.min((h + rectF.bottom) / 2, h), dpToPx(20), dpToPx(44) + contentPaddingTop);
+                             } else {
+-                                path.quadTo(0, rectF.top + rectF.height() / 2, dpToPx(20), h - dpToPx(174));
++                                path.quadTo(0, rectF.top / 2, dpToPx(20), h - dpToPx(174));
+                             }
+                             pathMeasure = new PathMeasure(path, false);
+                             pathLength = pathMeasure.getLength();
+@@ -702,18 +915,19 @@
+     }
+ 
+     private float dpToPx(float dp) {
+-        return AndroidUtilities.dp(dp);
++        return AndroidUtilities.dp2(dp);
+     }
+ 
+-    public void init(float x, float y, float height, float sideStartY, ArrayList<MessageObject> messages, float callX, float callY, int[] position) {
++    public void init(float x, ArrayList<MessageObject> messages, float finalY) {
+         circleX = x + dpToPx(16);
+-        circleY = y + sideStartY + dpToPx(17);
+-//        circleY = position[1]-sideStartY+dpToPx(11);
++        circleY = finalY;
+         popupX = circleX;
+         popupY = circleY - dpToPx(56);
+         sendingMessageObjects = messages;
+ 
+         fetchDialogs();
++        float avatarCount = dialogs.size();
++        targetWidth = (popupSize - avatarsPadding * 2) * avatarCount + (avatarCount + 1) * avatarsPadding;
+         calculateDrawingArea();
+         addAvatars();
+ 
+@@ -763,7 +977,7 @@
+         for (ImageReceiver imageReceiver : imageReceivers) {
+             imageReceiver.onAttachedToWindow();
+         }
+-        calculateColors();
++//        calculateColors();
+         startAnimation();
+ //        startFrameCallback();
+     }
+@@ -792,9 +1006,8 @@
+ 
+     ImageReceiver[] imageReceivers = {new ImageReceiver(this), new ImageReceiver(this), new ImageReceiver(this), new ImageReceiver(this), new ImageReceiver(this)};
+     String[] names = new String[5];
+-    int[] colors = new int[5];
+-    boolean colorsSet = false;
+-    boolean colorSetFromThumb = false;
++//    boolean colorsSet = false;
++//    boolean colorSetFromThumb = false;
+ 
+     public void addAvatars() {
+         for (int i = 0; i < Math.min(dialogs.size(), 5); i++) {
+@@ -940,6 +1153,10 @@
+         tooltipAnimator.start();
+     }
+ 
++    protected int getThemedColor(int key) {
++        return Theme.getColor(key, resourcesProvider);
++    }
++
+ 
+ //    private Choreographer choreographer;
+ //    private Choreographer.FrameCallback frameCallback;
Index: contest.patch
===================================================================
diff --git a/contest.patch b/contest.patch
new file mode 100644
--- /dev/null	(revision 515eebbc36fcedfc483dc6284ce905b185157fdd)
+++ b/contest.patch	(revision 515eebbc36fcedfc483dc6284ce905b185157fdd)
@@ -0,0 +1,703 @@
+Index: TMessagesProj/src/main/java/org/telegram/messenger/BuildVars.java
+IDEA additional info:
+Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
+<+>UTF-8
+===================================================================
+diff --git a/TMessagesProj/src/main/java/org/telegram/messenger/BuildVars.java b/TMessagesProj/src/main/java/org/telegram/messenger/BuildVars.java
+--- a/TMessagesProj/src/main/java/org/telegram/messenger/BuildVars.java	(revision 9b78d437de6ec1bbf067e2f17221b38db49f064d)
++++ b/TMessagesProj/src/main/java/org/telegram/messenger/BuildVars.java	(revision 4e4969b8d6bb1141f45b17e1fe695a0503d5c5dd)
+@@ -25,8 +25,8 @@
+     public static boolean CHECK_UPDATES = true;
+     public static boolean NO_SCOPED_STORAGE = Build.VERSION.SDK_INT <= 29;
+     public static String BUILD_VERSION_STRING = BuildConfig.BUILD_VERSION_STRING;
+-    public static int APP_ID = 4;
+-    public static String APP_HASH = "014b35b6184100b085b0d0572f9b5103";
++    public static int APP_ID = 45468;
++    public static String APP_HASH = "0310d3f5664107f13d2e9cd27fbac556";
+ 
+     // SafetyNet key for Google Identity SDK, set it to empty to disable
+     public static String SAFETYNET_KEY = "AIzaSyDqt8P-7F7CPCseMkOiVRgb1LY8RN1bvH8";
+Index: TMessagesProj/src/main/java/org/telegram/ui/ChatActivity.java
+IDEA additional info:
+Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
+<+>UTF-8
+===================================================================
+diff --git a/TMessagesProj/src/main/java/org/telegram/ui/ChatActivity.java b/TMessagesProj/src/main/java/org/telegram/ui/ChatActivity.java
+--- a/TMessagesProj/src/main/java/org/telegram/ui/ChatActivity.java	(revision 9b78d437de6ec1bbf067e2f17221b38db49f064d)
++++ b/TMessagesProj/src/main/java/org/telegram/ui/ChatActivity.java	(revision 4e4969b8d6bb1141f45b17e1fe695a0503d5c5dd)
+@@ -404,6 +404,7 @@
+     private boolean requestClearSearchPages;
+     private HashtagHistoryView hashtagHistoryView;
+ 
++    private HintView2 startBotHint;
+     private HintView2 savedMessagesHint;
+ 	private HintView2 savedMessagesSearchHint;
+     private HintView2 savedMessagesTagHint;
+@@ -1467,7 +1468,7 @@
+     private final static int share_business_link = 66;
+     private final static int rename_business_link = 67;
+     private final static int delete_business_link = 68;
+-    
++
+     private final static int share = 69;
+ 
+     private final static int id_chat_compose_panel = 1000;
+@@ -7912,6 +7913,16 @@
+                 }
+                 super.dispatchDraw(canvas);
+             }
++
++            @Override
++            public void setVisibility(int visibility) {
++                super.setVisibility(visibility);
++                if (visibility == VISIBLE && bottomOverlayStartButton.getVisibility() == VISIBLE) {
++                    startBotHint.show();
++                } else if (startBotHint != null) {
++                    startBotHint.hide();
++                }
++            }
+         };
+         bottomOverlayChat.isTopView = false;
+         bottomOverlayChat.drawBlur = false;
+@@ -7944,6 +7955,12 @@
+ 
+                 ViewGroup.LayoutParams params = bottomOverlayChat.getLayoutParams();
+                 params.height = AndroidUtilities.dp(visibility == VISIBLE ? 51 + 8 * 2 : 51);
++
++                if (visibility == VISIBLE && bottomOverlayChat.getVisibility() == VISIBLE && startBotHint != null) {
++                    startBotHint.show();
++                } else if (startBotHint != null) {
++                    startBotHint.hide();
++                }
+             }
+         };
+         bottomOverlayStartButton.setBackground(Theme.AdaptiveRipple.filledRect(getThemedColor(Theme.key_featuredStickers_addButton), 8));
+@@ -7955,6 +7972,16 @@
+         bottomOverlayStartButton.setVisibility(View.GONE);
+         bottomOverlayStartButton.setOnClickListener(v -> bottomOverlayChatText.callOnClick());
+         bottomOverlayChat.addView(bottomOverlayStartButton, LayoutHelper.createFrame(LayoutHelper.MATCH_PARENT, LayoutHelper.MATCH_PARENT, Gravity.CENTER, 8, 8, 8, 8));
++        startBotHint = new HintView2(context, HintView2.DIRECTION_BOTTOM)
++                .setMultilineText(true)
++                .setTextAlign(Layout.Alignment.ALIGN_CENTER)
++                .setHideByTouch(true)
++                .useScale(true)
++                .setJointPx(0.5f, 0)
++                .setIcon(new BouncingArrowsDrawable())
++                .setRounding(12);
++        startBotHint.setText(LocaleController.getString(R.string.BotStartButtonHint));
++        contentView.addView(startBotHint, LayoutHelper.createFrame(LayoutHelper.MATCH_PARENT, 120, Gravity.BOTTOM | Gravity.FILL_HORIZONTAL, 0, 0, 0, 51 + 8 * 2 + 8));
+ 
+         if (currentUser != null && currentUser.bot && currentUser.id != UserObject.VERIFY && !UserObject.isDeleted(currentUser) && !UserObject.isReplyUser(currentUser) && !isInScheduleMode() && chatMode != MODE_PINNED && chatMode != MODE_SAVED && !isReport()) {
+             bottomOverlayStartButton.setVisibility(View.VISIBLE);
+@@ -8535,7 +8562,7 @@
+             botMessageHint.show();
+         });
+     }
+-    
++
+     private void hideHints() {
+         if (savedMessagesTagHint != null && savedMessagesTagHint.shown()) {
+             savedMessagesTagHint.hide();
+@@ -9824,7 +9851,7 @@
+                 scrimViewAlphaAnimator.cancel();
+             }
+             animators.add(scrimPaintAlphaAnimator = ValueAnimator.ofFloat(0, value));
+-            
++
+             if (blur) {
+                 AndroidUtilities.makeGlobalBlurBitmap(bitmap -> {
+                     scrimBlurBitmap = bitmap;
+@@ -39375,7 +39402,7 @@
+             clip[1] = chatListView.getMeasuredHeight() - (chatListView.getPaddingBottom() - AndroidUtilities.dp(3));
+         }
+     }
+-    
++
+     private void updateVisibleWallpaperActions() {
+         if (chatListView != null && chatAdapter != null) {
+             for (int i = 0; i < chatListView.getChildCount(); ++i) {
+Index: TMessagesProj/src/main/java/org/telegram/ui/Components/BouncingArrowsDrawable.java
+IDEA additional info:
+Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
+<+>UTF-8
+===================================================================
+diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Components/BouncingArrowsDrawable.java b/TMessagesProj/src/main/java/org/telegram/ui/Components/BouncingArrowsDrawable.java
+new file mode 100644
+--- /dev/null	(revision 4e4969b8d6bb1141f45b17e1fe695a0503d5c5dd)
++++ b/TMessagesProj/src/main/java/org/telegram/ui/Components/BouncingArrowsDrawable.java	(revision 4e4969b8d6bb1141f45b17e1fe695a0503d5c5dd)
+@@ -0,0 +1,152 @@
++package org.telegram.ui.Components;
++
++import android.graphics.Canvas;
++import android.graphics.Color;
++import android.graphics.ColorFilter;
++import android.graphics.Paint;
++import android.graphics.Path;
++import android.graphics.PixelFormat;
++import android.graphics.Rect;
++import android.graphics.drawable.Drawable;
++import android.os.SystemClock;
++
++import androidx.annotation.Keep;
++import androidx.annotation.NonNull;
++import androidx.annotation.Nullable;
++
++import org.telegram.messenger.AndroidUtilities;
++
++public class BouncingArrowsDrawable extends Drawable {
++
++    private Paint paint;
++    private Path path = new Path();
++    private float animProgress;
++    private float animateToProgress;
++    private long lastUpdateTime;
++
++    public BouncingArrowsDrawable() {
++        paint = new Paint(Paint.ANTI_ALIAS_FLAG);
++        paint.setColor(Color.WHITE);
++        paint.setStyle(Paint.Style.STROKE);
++        paint.setStrokeWidth(4);
++        paint.setStrokeCap(Paint.Cap.ROUND);
++        paint.setStrokeJoin(Paint.Join.ROUND);
++
++        animProgress = 0f;
++        animateToProgress = 0f;
++        lastUpdateTime = SystemClock.elapsedRealtime();
++
++    }
++
++    @Override
++    public void draw(@NonNull Canvas canvas) {
++        updateAnimation();
++        updatePath();
++        canvas.drawPath(path, paint);
++    }
++
++    private void updatePath() {
++        path.reset();
++
++        float p = animProgress * 2 - 1;
++
++        Rect bounds = getBounds();
++
++        float chevronWidth = bounds.width() * 0.6f;
++        float chevronHeight = bounds.height() * 0.25f;
++
++        float centerX = bounds.centerX() + 6;
++        float centerY = bounds.centerY() - 6;
++
++        float bounceOffset = (bounds.height() * 0.08f) * p;
++
++        path.moveTo(centerX - chevronWidth / 2, centerY - 2 - chevronHeight / 2 - bounceOffset);
++        path.lineTo(centerX, centerY - 2 + chevronHeight / 2 - bounceOffset);
++        path.lineTo(centerX + chevronWidth / 2, centerY - 2 - chevronHeight / 2 - bounceOffset);
++
++        path.moveTo(centerX - chevronWidth / 2, centerY + 2 + chevronHeight / 2 - bounceOffset);
++        path.lineTo(centerX, centerY + 2 + (3 * chevronHeight / 2) - bounceOffset);
++        path.lineTo(centerX + chevronWidth / 2, centerY + 2 + chevronHeight / 2 - bounceOffset);
++    }
++
++    private void updateAnimation() {
++        if (animProgress != animateToProgress) {
++            long currentTime = SystemClock.elapsedRealtime();
++            long deltaTime = currentTime - lastUpdateTime;
++            lastUpdateTime = currentTime;
++
++            float animationSpeed = deltaTime / 600f;
++
++            if (animProgress < animateToProgress) {
++                animProgress += animationSpeed;
++                if (animProgress > animateToProgress) {
++                    animProgress = animateToProgress;
++                }
++            } else {
++                animProgress -= animationSpeed;
++                if (animProgress < animateToProgress) {
++                    animProgress = animateToProgress;
++                }
++            }
++
++            invalidateSelf();
++        } else {
++            animateToProgress = animProgress == 0f ? 1f : 0f;
++            lastUpdateTime = SystemClock.elapsedRealtime();
++            invalidateSelf();
++        }
++    }
++
++    public void startAnimation() {
++        animateToProgress = 1f;
++        lastUpdateTime = SystemClock.elapsedRealtime();
++        invalidateSelf();
++    }
++
++    public void stopAnimation() {
++        animateToProgress = 0f;
++        lastUpdateTime = SystemClock.elapsedRealtime();
++        invalidateSelf();
++    }
++
++    public void setColor(int color) {
++        paint.setColor(color);
++        invalidateSelf();
++    }
++
++    @Keep
++    public float getAnimationProgress() {
++        return animProgress;
++    }
++
++    @Override
++    public int getIntrinsicWidth() {
++        return AndroidUtilities.dp(12);
++    }
++
++    @Override
++    public int getIntrinsicHeight() {
++        return AndroidUtilities.dp(16);
++    }
++
++    @Override
++    public void setAlpha(int alpha) {
++        paint.setAlpha(alpha);
++    }
++
++    @Override
++    public int getAlpha() {
++        return paint.getAlpha();
++    }
++
++    @Override
++    public void setColorFilter(@Nullable ColorFilter colorFilter) {
++        paint.setColorFilter(colorFilter);
++    }
++
++    @Override
++    public int getOpacity() {
++        return paint.getAlpha() == 255 ? PixelFormat.OPAQUE : PixelFormat.TRANSLUCENT;
++    }
++}
++
+Index: TMessagesProj/src/main/java/org/telegram/ui/Components/LinkActionView.java
+IDEA additional info:
+Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
+<+>UTF-8
+===================================================================
+diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Components/LinkActionView.java b/TMessagesProj/src/main/java/org/telegram/ui/Components/LinkActionView.java
+--- a/TMessagesProj/src/main/java/org/telegram/ui/Components/LinkActionView.java	(revision 9b78d437de6ec1bbf067e2f17221b38db49f064d)
++++ b/TMessagesProj/src/main/java/org/telegram/ui/Components/LinkActionView.java	(revision 4e4969b8d6bb1141f45b17e1fe695a0503d5c5dd)
+@@ -7,7 +7,6 @@
+ import android.animation.AnimatorListenerAdapter;
+ import android.content.Context;
+ import android.content.DialogInterface;
+-import android.content.Intent;
+ import android.graphics.Canvas;
+ import android.graphics.Color;
+ import android.graphics.drawable.ColorDrawable;
+@@ -34,7 +33,6 @@
+ 
+ import org.telegram.messenger.AndroidUtilities;
+ import org.telegram.messenger.ApplicationLoader;
+-import org.telegram.messenger.DialogObject;
+ import org.telegram.messenger.FileLog;
+ import org.telegram.messenger.LocaleController;
+ import org.telegram.messenger.MessagesController;
+@@ -49,9 +47,9 @@
+ import org.telegram.ui.ActionBar.BottomSheet;
+ import org.telegram.ui.ActionBar.Theme;
+ import org.telegram.ui.Cells.DialogCell;
+-import org.telegram.ui.ManageLinksActivity;
+ 
+ import java.util.ArrayList;
++import java.util.List;
+ 
+ public class LinkActionView extends LinearLayout {
+ 
+@@ -217,131 +215,137 @@
+             builder.setNegativeButton(LocaleController.getString(R.string.Cancel), null);
+             fragment.showDialog(builder.create());
+         });
+-
+-        optionsView.setOnClickListener(view -> {
+-            if (actionBarPopupWindow != null) {
+-                return;
+-            }
+-            ActionBarPopupWindow.ActionBarPopupWindowLayout layout = new ActionBarPopupWindow.ActionBarPopupWindowLayout(context);
++        updateOptionsView();
++        if (getAvailableOptions().size() == 1) {
++            optionsView.setOnClickListener(view -> {
++                getAvailableOptions().get(0).action.run();
++            });
++        } else {
++            optionsView.setOnClickListener(view -> {
++                if (actionBarPopupWindow != null) {
++                    return;
++                }
++                ActionBarPopupWindow.ActionBarPopupWindowLayout layout = new ActionBarPopupWindow.ActionBarPopupWindowLayout(context);
+ 
+-            ActionBarMenuSubItem subItem;
+-            if (!this.permanent && canEdit) {
+-                subItem = new ActionBarMenuSubItem(context, true, false);
+-                subItem.setTextAndIcon(LocaleController.getString(R.string.Edit), R.drawable.msg_edit);
+-                layout.addView(subItem, LayoutHelper.createLinear(LayoutHelper.MATCH_PARENT, 48));
+-                subItem.setOnClickListener(view12 -> {
+-                    if (actionBarPopupWindow != null) {
+-                        actionBarPopupWindow.dismiss();
+-                    }
+-                    delegate.editLink();
+-                });
+-            }
++                ActionBarMenuSubItem subItem;
++                if (!this.permanent && canEdit) {
++                    subItem = new ActionBarMenuSubItem(context, true, false);
++                    subItem.setTextAndIcon(LocaleController.getString(R.string.Edit), R.drawable.msg_edit);
++                    layout.addView(subItem, LayoutHelper.createLinear(LayoutHelper.MATCH_PARENT, 48));
++                    subItem.setOnClickListener(view12 -> {
++                        if (actionBarPopupWindow != null) {
++                            actionBarPopupWindow.dismiss();
++                        }
++                        delegate.editLink();
++                    });
++                }
+ 
+-            subItem = new ActionBarMenuSubItem(context, true, false);
+-            subItem.setTextAndIcon(LocaleController.getString(R.string.GetQRCode), R.drawable.msg_qrcode);
+-            layout.addView(subItem, LayoutHelper.createLinear(LayoutHelper.MATCH_PARENT, 48));
+-            subItem.setOnClickListener(view12 -> {
+-                showQrCode();
+-            });
++                subItem = new ActionBarMenuSubItem(context, true, false);
++                subItem.setTextAndIcon(LocaleController.getString(R.string.GetQRCode), R.drawable.msg_qrcode);
++                layout.addView(subItem, LayoutHelper.createLinear(LayoutHelper.MATCH_PARENT, 48));
++                subItem.setOnClickListener(view12 -> {
++                    showQrCode();
++                });
+ 
+-            if (!hideRevokeOption) {
+-                subItem = new ActionBarMenuSubItem(context, false, true);
+-                subItem.setTextAndIcon(LocaleController.getString(R.string.RevokeLink), R.drawable.msg_delete);
+-                subItem.setColors(Theme.getColor(Theme.key_text_RedRegular), Theme.getColor(Theme.key_text_RedRegular));
+-                subItem.setOnClickListener(view1 -> {
+-                    if (actionBarPopupWindow != null) {
+-                        actionBarPopupWindow.dismiss();
+-                    }
+-                    revokeLink();
+-                });
+-                layout.addView(subItem, LayoutHelper.createLinear(LayoutHelper.MATCH_PARENT, 48));
+-            }
++                if (!hideRevokeOption) {
++                    subItem = new ActionBarMenuSubItem(context, false, true);
++                    subItem.setTextAndIcon(LocaleController.getString(R.string.RevokeLink), R.drawable.msg_delete);
++                    subItem.setColors(Theme.getColor(Theme.key_text_RedRegular), Theme.getColor(Theme.key_text_RedRegular));
++                    subItem.setOnClickListener(view1 -> {
++                        if (actionBarPopupWindow != null) {
++                            actionBarPopupWindow.dismiss();
++                        }
++                        revokeLink();
++                    });
++                    layout.addView(subItem, LayoutHelper.createLinear(LayoutHelper.MATCH_PARENT, 48));
++                }
+ 
+-            FrameLayout container;
+-            if (bottomSheet == null) {
+-                container = (FrameLayout) fragment.getParentLayout().getOverlayContainerView();
+-            } else {
+-                container = bottomSheet.getContainer();
+-            }
++                FrameLayout container;
++                if (bottomSheet == null) {
++                    container = (FrameLayout) fragment.getParentLayout().getOverlayContainerView();
++                } else {
++                    container = bottomSheet.getContainer();
++                }
+ 
+ 
+-            if (container != null) {
+-                float x = 0;
+-                float y;
+-                getPointOnScreen(frameLayout, container, point);
+-                y = point[1];
++                if (container != null) {
++                    float x = 0;
++                    float y;
++                    getPointOnScreen(frameLayout, container, point);
++                    y = point[1];
+ 
+-                final FrameLayout finalContainer = container;
+-                View dimView = new View(context) {
++                    final FrameLayout finalContainer = container;
++                    View dimView = new View(context) {
+ 
+-                    @Override
+-                    protected void onDraw(Canvas canvas) {
+-                        canvas.drawColor(0x33000000);
+-                        getPointOnScreen(frameLayout, finalContainer, point);
+-                        canvas.save();
+-                        float clipTop = ((View) frameLayout.getParent()).getY() + frameLayout.getY();
+-                        if (clipTop < 1) {
+-                            canvas.clipRect(0, point[1] - clipTop + 1, getMeasuredWidth(), getMeasuredHeight());
+-                        }
+-                        canvas.translate(point[0], point[1]);
++                        @Override
++                        protected void onDraw(Canvas canvas) {
++                            canvas.drawColor(0x33000000);
++                            getPointOnScreen(frameLayout, finalContainer, point);
++                            canvas.save();
++                            float clipTop = ((View) frameLayout.getParent()).getY() + frameLayout.getY();
++                            if (clipTop < 1) {
++                                canvas.clipRect(0, point[1] - clipTop + 1, getMeasuredWidth(), getMeasuredHeight());
++                            }
++                            canvas.translate(point[0], point[1]);
+ 
+-                        frameLayout.draw(canvas);
+-                        canvas.restore();
+-                    }
+-                };
++                            frameLayout.draw(canvas);
++                            canvas.restore();
++                        }
++                    };
+ 
+-                ViewTreeObserver.OnPreDrawListener preDrawListener = new ViewTreeObserver.OnPreDrawListener() {
+-                    @Override
+-                    public boolean onPreDraw() {
+-                        dimView.invalidate();
+-                        return true;
+-                    }
+-                };
+-                finalContainer.getViewTreeObserver().addOnPreDrawListener(preDrawListener);
+-                container.addView(dimView, LayoutHelper.createFrame(LayoutHelper.MATCH_PARENT, LayoutHelper.MATCH_PARENT));
+-                dimView.setAlpha(0);
+-                dimView.animate().alpha(1f).setDuration(150);
+-                layout.measure(MeasureSpec.makeMeasureSpec(container.getMeasuredWidth(), MeasureSpec.UNSPECIFIED), MeasureSpec.makeMeasureSpec(container.getMeasuredHeight(), MeasureSpec.UNSPECIFIED));
++                    ViewTreeObserver.OnPreDrawListener preDrawListener = new ViewTreeObserver.OnPreDrawListener() {
++                        @Override
++                        public boolean onPreDraw() {
++                            dimView.invalidate();
++                            return true;
++                        }
++                    };
++                    finalContainer.getViewTreeObserver().addOnPreDrawListener(preDrawListener);
++                    container.addView(dimView, LayoutHelper.createFrame(LayoutHelper.MATCH_PARENT, LayoutHelper.MATCH_PARENT));
++                    dimView.setAlpha(0);
++                    dimView.animate().alpha(1f).setDuration(150);
++                    layout.measure(MeasureSpec.makeMeasureSpec(container.getMeasuredWidth(), MeasureSpec.UNSPECIFIED), MeasureSpec.makeMeasureSpec(container.getMeasuredHeight(), MeasureSpec.UNSPECIFIED));
+ 
+ 
+-                actionBarPopupWindow = new ActionBarPopupWindow(layout, LayoutHelper.WRAP_CONTENT, LayoutHelper.WRAP_CONTENT);
+-                actionBarPopupWindow.setOnDismissListener(new PopupWindow.OnDismissListener() {
+-                    @Override
+-                    public void onDismiss() {
+-                        actionBarPopupWindow = null;
+-                        dimView.animate().cancel();
+-                        dimView.animate().alpha(0).setDuration(150).setListener(new AnimatorListenerAdapter() {
+-                            @Override
+-                            public void onAnimationEnd(Animator animation) {
+-                                if (dimView.getParent() != null) {
+-                                    finalContainer.removeView(dimView);
+-                                }
+-                                finalContainer.getViewTreeObserver().removeOnPreDrawListener(preDrawListener);
+-                            }
+-                        });
+-                    }
+-                });
+-                actionBarPopupWindow.setOutsideTouchable(true);
+-                actionBarPopupWindow.setFocusable(true);
+-                actionBarPopupWindow.setBackgroundDrawable(new ColorDrawable(Color.TRANSPARENT));
+-                actionBarPopupWindow.setAnimationStyle(R.style.PopupContextAnimation);
+-                actionBarPopupWindow.setInputMethodMode(ActionBarPopupWindow.INPUT_METHOD_NOT_NEEDED);
+-                actionBarPopupWindow.setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_STATE_UNSPECIFIED);
++                    actionBarPopupWindow = new ActionBarPopupWindow(layout, LayoutHelper.WRAP_CONTENT, LayoutHelper.WRAP_CONTENT);
++                    actionBarPopupWindow.setOnDismissListener(new PopupWindow.OnDismissListener() {
++                        @Override
++                        public void onDismiss() {
++                            actionBarPopupWindow = null;
++                            dimView.animate().cancel();
++                            dimView.animate().alpha(0).setDuration(150).setListener(new AnimatorListenerAdapter() {
++                                @Override
++                                public void onAnimationEnd(Animator animation) {
++                                    if (dimView.getParent() != null) {
++                                        finalContainer.removeView(dimView);
++                                    }
++                                    finalContainer.getViewTreeObserver().removeOnPreDrawListener(preDrawListener);
++                                }
++                            });
++                        }
++                    });
++                    actionBarPopupWindow.setOutsideTouchable(true);
++                    actionBarPopupWindow.setFocusable(true);
++                    actionBarPopupWindow.setBackgroundDrawable(new ColorDrawable(Color.TRANSPARENT));
++                    actionBarPopupWindow.setAnimationStyle(R.style.PopupContextAnimation);
++                    actionBarPopupWindow.setInputMethodMode(ActionBarPopupWindow.INPUT_METHOD_NOT_NEEDED);
++                    actionBarPopupWindow.setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_STATE_UNSPECIFIED);
+ 
+-                layout.setDispatchKeyEventListener(keyEvent -> {
+-                    if (keyEvent.getKeyCode() == KeyEvent.KEYCODE_BACK && keyEvent.getRepeatCount() == 0 && actionBarPopupWindow.isShowing()) {
+-                        actionBarPopupWindow.dismiss(true);
+-                    }
+-                });
++                    layout.setDispatchKeyEventListener(keyEvent -> {
++                        if (keyEvent.getKeyCode() == KeyEvent.KEYCODE_BACK && keyEvent.getRepeatCount() == 0 && actionBarPopupWindow.isShowing()) {
++                            actionBarPopupWindow.dismiss(true);
++                        }
++                    });
+ 
+-                if (AndroidUtilities.isTablet()) {
+-                    y += container.getPaddingTop();
+-                    x -= container.getPaddingLeft();
+-                }
+-                actionBarPopupWindow.showAtLocation(container, 0, (int) (container.getMeasuredWidth() - layout.getMeasuredWidth() - AndroidUtilities.dp(16) + container.getX() + x), (int) (y + frameLayout.getMeasuredHeight() + container.getY()));
+-            }
++                    if (AndroidUtilities.isTablet()) {
++                        y += container.getPaddingTop();
++                        x -= container.getPaddingLeft();
++                    }
++                    actionBarPopupWindow.showAtLocation(container, 0, (int) (container.getMeasuredWidth() - layout.getMeasuredWidth() - AndroidUtilities.dp(16) + container.getX() + x), (int) (y + frameLayout.getMeasuredHeight() + container.getY()));
++                }
+ 
+-        });
++            });
++        }
+ 
+         frameLayout.setOnClickListener(new OnClickListener() {
+             @Override
+@@ -452,11 +456,10 @@
+         optionsView.setVisibility(b ? View.VISIBLE : View.GONE);
+     }
+ 
+-    public void hideRevokeOption(boolean b) {
+-        if (hideRevokeOption != b) {
+-            hideRevokeOption = b;
+-            optionsView.setVisibility(View.VISIBLE);
+-            optionsView.setImageDrawable(ContextCompat.getDrawable(optionsView.getContext(), R.drawable.ic_ab_other));
++    public void hideRevokeOption(boolean hide) {
++        if (hideRevokeOption != hide) {
++            hideRevokeOption = hide;
++            updateOptionsView();
+         }
+     }
+ 
+@@ -617,4 +620,67 @@
+     public void setCanEdit(boolean canEdit) {
+         this.canEdit = canEdit;
+     }
++
++    private static class Option {
++        String text;
++        int iconResId;
++        Runnable action;
++        Integer textColor;
++
++        Option(String text, int iconResId, Runnable action) {
++            this(text, iconResId, action, null);
++        }
++
++        Option(String text, int iconResId, Runnable action, Integer textColor) {
++            this.text = text;
++            this.iconResId = iconResId;
++            this.action = action;
++            this.textColor = textColor;
++        }
++    }
++
++    private List<Option> getAvailableOptions() {
++        List<Option> options = new ArrayList<>();
++
++        if (!this.permanent && canEdit) {
++            options.add(new Option(LocaleController.getString(R.string.Edit), R.drawable.msg_edit, () -> {
++                if (actionBarPopupWindow != null) {
++                    actionBarPopupWindow.dismiss();
++                }
++                delegate.editLink();
++            }));
++        }
++
++        options.add(new Option(LocaleController.getString(R.string.GetQRCode), R.drawable.msg_qrcode, () -> {
++            showQrCode();
++        }));
++
++        if (!hideRevokeOption) {
++            options.add(new Option(LocaleController.getString(R.string.RevokeLink), R.drawable.msg_delete, () -> {
++                if (actionBarPopupWindow != null) {
++                    actionBarPopupWindow.dismiss();
++                }
++                revokeLink();
++            }, Theme.getColor(Theme.key_text_RedRegular)));
++        }
++
++        return options;
++    }
++
++    private void updateOptionsView() {
++        List<Option> options = getAvailableOptions();
++
++        if (options.size() == 1) {
++            Option singleOption = options.get(0);
++            optionsView.setImageDrawable(ContextCompat.getDrawable(getContext(), singleOption.iconResId));
++            optionsView.setContentDescription(singleOption.text);
++            optionsView.setOnClickListener(view -> {
++                singleOption.action.run();
++            });
++        } else if (options.size() > 1) {
++            optionsView.setImageDrawable(ContextCompat.getDrawable(getContext(), R.drawable.ic_ab_other));
++            optionsView.setContentDescription(LocaleController.getString(R.string.AccDescrMoreOptions));
++        }
++    }
++
+ }
+Index: TMessagesProj/src/main/java/org/telegram/ui/ManageLinksActivity.java
+IDEA additional info:
+Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
+<+>UTF-8
+===================================================================
+diff --git a/TMessagesProj/src/main/java/org/telegram/ui/ManageLinksActivity.java b/TMessagesProj/src/main/java/org/telegram/ui/ManageLinksActivity.java
+--- a/TMessagesProj/src/main/java/org/telegram/ui/ManageLinksActivity.java	(revision 9b78d437de6ec1bbf067e2f17221b38db49f064d)
++++ b/TMessagesProj/src/main/java/org/telegram/ui/ManageLinksActivity.java	(revision 4e4969b8d6bb1141f45b17e1fe695a0503d5c5dd)
+@@ -5,7 +5,6 @@
+ import static org.telegram.messenger.LocaleController.getString;
+ 
+ import android.content.Context;
+-import android.content.Intent;
+ import android.graphics.Canvas;
+ import android.graphics.Color;
+ import android.graphics.Paint;
+@@ -41,7 +40,6 @@
+ import org.telegram.messenger.ApplicationLoader;
+ import org.telegram.messenger.ChatObject;
+ import org.telegram.messenger.ContactsController;
+-import org.telegram.messenger.DialogObject;
+ import org.telegram.messenger.DocumentObject;
+ import org.telegram.messenger.Emoji;
+ import org.telegram.messenger.FileLog;
+Index: TMessagesProj/src/main/res/values/strings.xml
+IDEA additional info:
+Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
+<+>UTF-8
+===================================================================
+diff --git a/TMessagesProj/src/main/res/values/strings.xml b/TMessagesProj/src/main/res/values/strings.xml
+--- a/TMessagesProj/src/main/res/values/strings.xml	(revision 9b78d437de6ec1bbf067e2f17221b38db49f064d)
++++ b/TMessagesProj/src/main/res/values/strings.xml	(revision 4e4969b8d6bb1141f45b17e1fe695a0503d5c5dd)
+@@ -8179,4 +8179,5 @@
+     <string name="Gift2ButtonSendGift">send a gift</string>
+     <string name="Gift2ButtonSell_one">sell for %d Star</string>
+     <string name="Gift2ButtonSell_other">sell for %d Stars</string>
++    <string name="BotStartButtonHint">Tap here to use this bot</string>
+ </resources>
+\ No newline at end of file
+Index: gradle/wrapper/gradle-wrapper.properties
+IDEA additional info:
+Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
+<+>ISO-8859-1
+===================================================================
+diff --git a/gradle/wrapper/gradle-wrapper.properties b/gradle/wrapper/gradle-wrapper.properties
+--- a/gradle/wrapper/gradle-wrapper.properties	(revision 9b78d437de6ec1bbf067e2f17221b38db49f064d)
++++ b/gradle/wrapper/gradle-wrapper.properties	(revision 4e4969b8d6bb1141f45b17e1fe695a0503d5c5dd)
+@@ -1,6 +1,6 @@
+-#Mon Oct 19 01:57:36 MSK 2020
++#Fri Oct 18 23:24:41 MSK 2024
+ distributionBase=GRADLE_USER_HOME
+ distributionPath=wrapper/dists
++distributionUrl=https\://services.gradle.org/distributions/gradle-8.6-bin.zip
+ zipStoreBase=GRADLE_USER_HOME
+ zipStorePath=wrapper/dists
+-distributionUrl=https\://services.gradle.org/distributions/gradle-7.0.2-bin.zip
diff --git a/TMessagesProj/config/release.keystore b/TMessagesProj/config/release.keystore
index 4c32fd31eca1db3836f220b60b96c8bd2fcc3dba..08d7229a58bc2011b54143099b0180f531ab95d8
GIT binary patch
literal 2752
zc$|%tX*d*$8pmhG493=AhGZMcHdHgVhDHdXkS+U&m}Eap3)zP(CqhCfGq&twImUj-
zHH0$ueT|V4Dk(e1eeQiu_kOzf!~6W7_xFFF_u~&u;%Ei|S<obo+pJJjv_bS1H;@fT
zA#qrPNgNi(_&S;dsr|1CQV1qN@{Te2c(PbI|6Or$071v4)-lAPe?5b6qixaHUn>_{
z9t=M?GbyRqi%FHT$l=+g6;tF9-I^ef3=9NBqPbYv|8)z3LI7w{R;W|70g%7~2BN^Q
zw{FUUegWh?J(3b$A&tiaOak|t;F}nZ;^A03NCUY(#AzXATIi&X;2to=JnVwP74P6q
z@0zw3%2^uMzpEB}E`pI+4i(o!nC?}k1&rHu+aLAr_x*giIA~Y<f;qmR5|G6If$!Tl
zPQCged%c$Ct4X{Xcannq^>Miqk)YyJHjIk&cZoZrB602PhL)NgHrhn|1`i)%gh(eu
z5quJw+p(6KxUc)V+<y3W@$<d}F~DIeqS&qUVq6dNqNRoAR8-!ZYzU!O>r45*Da;Dz
zeXuU{g2JFCHQ^N`3}iqa99^IW`}xWIm7FJnKSm_7E(<h<7KFC3y$$VZDd9ye$F?~6
z%Yz#UZrO1;IiIx>i7sU*pic!CkBq@7+bG3D4Y!HXmaRc#>H>F<1svEhPMQ}EGG@5#
zJ+2L44(9oZoS#mDTbbAp{R3#-GGR^2g-KWAt|K#VZ|%{fCmK-SzHj<mde(t_LgjyY
zu+FTo2*pCp%Oze;m`USnMrkJ&EX9*I_y=RlK(_Zzheu@gba?2}gzt*^K;4T)g1H@r
z?qEg>2SYtnhjeG>eCgMkWu9_!iRdO|3z){f6b<1W0xwHTf1w5L^K==Ty_JFuF_U7#
z7D6XS;yQI6_}SnTo2eTLUSeh0Uh3xK{%i~w<z?twVMamJ2|puVrYkY$nJ)s8(%W^&
zR!n6G5mHeZfehEpTbw&=e2#SL$(1Ab8dbeqDlKt*sPGFUL5P|Rv3izefIs81Y&#Mk
z%ReI;=ok}U_KdaW_2qlwqmEuTep_Vvt!voEOD(?D^bc%cd0a!J`NBU7E+fsS_XbwW
zY+fPeEvZje&KRJ4?N+O444Ht3vQL|ObL<MPTT$y?NiHrqPb(zgrOvAML>&lZ=nAUr
zv>r77RF5qsH{@I1AU>^u>qlmu^nCyB?rM*OCpCO_A{VE3M^&E?wE#8PTJ2cL*<A_P
zgXtRxb_fRLg*>AtUQ(aJr;l|nmYP(~1na#pOFbu|F^qSF<eqWUxwjsh>i&~mlBq0O
zEw-c=5*E``>@%j|D_p4MQqF&fT4H#LLU*=hB0sT4SO8JDrPxS2{MuR7>U2I`qo&(8
zg3iH?ri0+`GhkR@i!Z7ygjG_^$1>kN999;co!&J*mHPb$x!<$Z?)DxaQk}K^&-E|*
zYugr*!N{j=-(sK*D>C+hBhGYx&4n9v{V5c?qk)7%-d<s{VKJ|d>=pe#XO#r9y49EN
zSvb`_ifAc|rkz%YTaoHVT>baU1Jtm=#-TCkliY@~#fZDj`xoO)AGwyVf9Wryt4KB~
z@?=|gxtQs^uG*E&aEL0pk9btg?sOHQnRxTbY}iI;8{xutRJRlhCY*kwrQ5J_qX>$n
zdq%HnzAY=*<}%@kkOgfm`~gd)Bs|_yyw0PSxtZZr=3{({yZ^uzn-Cg^*=2j<sc_#W
z!gjp^wQ=f9dcLK@Cvqva-g51ET1`dX@`>5T3H5_R)fp#OW@YXTt?%2V1G_O{Sr~DI
zpvj4`4;zn&KlJ02A5NbZyc=MhpFkcyaF(;7nfNr%B^FJUaHl{5+}9-1!jJCZ1ABMB
z%`|6yMWkv{3)Zi}U;V?uY>*i%7ki0MC@F5ci}=0vbmrD_2(<4O&SyvO`4V>6+$^LN
zJA^SnpZ;5yP&h_F3=VJx_yAl1{s3Qq`*C^#2!KGe#IGX+1`g)4boVA8F&C837z{=Y
zt%Oy^qDkQ7U*=||kiev46bb?Yj^n|9IQ@U=+6~?@eox%5T`qILP*r}881mkc@c-!g
zsA|}#ex(HShs)T<pyy^&;Uq9%F@Z7okgxKBFwIF+nn^$8+i5>(*E%*l`*9{U0!U|z
zaw=O6hcfuFUd}J_dCs`X-Gm(2yfd<(Dh)LE0r?5>hfh!}t2knd{1INrk#=PUqF*$J
z9E9|YxMU6|`a4+Vw*A~iy0SdpU46*VaS!ox9G;*Oa_MBw^9^d_k-uLPr>784D)4Tl
zk0mS7DZ?x4mvwvs)?u-C)y2xq2CD{SX)0r)Yb5~-HcA&Z_v6D`V?&U${2OCmA`qf*
zd&y6(_;cl*w`Er!_NttWGGUF0-<ii%oIAI)O(DIJ-04X;ks~D+3mtT~2A&zRFQR@G
zGkDLdwHlq$Ui>=R?1Aoz=Wd1v$3TYb9{7p<9lI-vCEa=8b0f`dA+<=wlCOZ@q>?q0
zKIppShL6k#op(Y8x?B4_ppAzs|LEw0wobk*F|UewP223yISh?BySX%h;_2>gDrZko
zs6BC1F^j`ozL-OFyxODP|HDeV5jcHIBlVPiiq*5+WX<6anU)u$#J3l{Vjw0QMe51J
zY4)vZlmuh}sIsNEtx+Hcapk0^EPvxol|SijPkag^198`#^afM34P8u8u#E>jN8%@z
zo75z|s@TOMv-vFg5nj%j%&<tW%YXEWFKvUz2+K;^VwKYS1w_A~f;i9d_GL~h!LIXD
zQ9I;Ote;Tt1e@ZA%m_incE>sAz66ftHB6`O*@NdQy*5Xnv$^WdZhXSEk}&zOuQb$_
zXHR=+%oXXc;5qjdR<j4~mq~fD-ITr-)!5igx@OjsEm7}%W*yl`g)2(lWwWEc<AYQu
zu6k&B@3zq6`|i-{Ncj!@G{H-}AuG-*PD4fxT^MuD`LuVRse-C~>FFaCVjuOzwEXAt
zsw#LXeSO3EwRjCfBXYyg9k>ZbM!uD(Z%M<!L<}$YMFZ|=F1mc$u;+X{PUCIDRM#nG
zwR$uzc3Wpkp7J_7F!@wTK;6RRx!zC8P3q9B1WAHXE>0e?le5(&Q&A<t>r-CtQNllO
zMKQhMx5gYsC@ihm%xWCY?V>qiR5WKafc1^yXE!K$PdITB)zy<xC)eiPEdL4w7VM|O
z$uY2rqY?4$-nHP~*J^M?%sGqreB|Mnup{bQqfYOev9X$d)3}?TuT~iwl91?vgF<b{
zhm1Ip4G_EJ4<nDx_Uai>{Dz}xsdi>9oP(vkt&@AM+%_;ZI61BSbyZtkDwy_pA#Am*
z8>yyYt?+KrKwwR*Q^NcEfG0Sup2s?EUwJY#yvu{TVBMUpLnM1FEo{MU`0o5t!IHPO
zZOGotRj!73jUV<a_MqBZ3N{E+3l?=L*?=zXFq=vkpk`0rvuDH|<VCn>EX<-uNy=J7
z(9p(c44V6IO@M$902ukO-~5xd{Wn#!7gBv&*AD6~4JPTB1*2^98H4b-v`jHDT<zw<
Yrjx6!dJ|gc!i?na$YR;t-G3_RFI{c=9RL6T

